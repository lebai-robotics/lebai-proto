/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
"use strict";

var $protobuf = require("protobufjs/minimal");

// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.lebai = (function() {

    /**
     * Namespace lebai.
     * @exports lebai
     * @namespace
     */
    var lebai = {};

    lebai.auto = (function() {

        /**
         * Namespace auto.
         * @memberof lebai
         * @namespace
         */
        var auto = {};

        /**
         * AutoCfg enum.
         * @name lebai.auto.AutoCfg
         * @enum {number}
         * @property {number} ARM_POWER=0 ARM_POWER value
         * @property {number} ENABLE_JOINT=1 ENABLE_JOINT value
         * @property {number} INIT_CLAW=2 INIT_CLAW value
         */
        auto.AutoCfg = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "ARM_POWER"] = 0;
            values[valuesById[1] = "ENABLE_JOINT"] = 1;
            values[valuesById[2] = "INIT_CLAW"] = 2;
            return values;
        })();

        auto.SetAutoRequest = (function() {

            /**
             * Properties of a SetAutoRequest.
             * @memberof lebai.auto
             * @interface ISetAutoRequest
             * @property {lebai.auto.AutoCfg|null} [name] SetAutoRequest name
             * @property {boolean|null} [value] SetAutoRequest value
             */

            /**
             * Constructs a new SetAutoRequest.
             * @memberof lebai.auto
             * @classdesc Represents a SetAutoRequest.
             * @implements ISetAutoRequest
             * @constructor
             * @param {lebai.auto.ISetAutoRequest=} [properties] Properties to set
             */
            function SetAutoRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SetAutoRequest name.
             * @member {lebai.auto.AutoCfg} name
             * @memberof lebai.auto.SetAutoRequest
             * @instance
             */
            SetAutoRequest.prototype.name = 0;

            /**
             * SetAutoRequest value.
             * @member {boolean} value
             * @memberof lebai.auto.SetAutoRequest
             * @instance
             */
            SetAutoRequest.prototype.value = false;

            /**
             * Creates a new SetAutoRequest instance using the specified properties.
             * @function create
             * @memberof lebai.auto.SetAutoRequest
             * @static
             * @param {lebai.auto.ISetAutoRequest=} [properties] Properties to set
             * @returns {lebai.auto.SetAutoRequest} SetAutoRequest instance
             */
            SetAutoRequest.create = function create(properties) {
                return new SetAutoRequest(properties);
            };

            /**
             * Encodes the specified SetAutoRequest message. Does not implicitly {@link lebai.auto.SetAutoRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.auto.SetAutoRequest
             * @static
             * @param {lebai.auto.ISetAutoRequest} message SetAutoRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetAutoRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.name);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.value);
                return writer;
            };

            /**
             * Encodes the specified SetAutoRequest message, length delimited. Does not implicitly {@link lebai.auto.SetAutoRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.auto.SetAutoRequest
             * @static
             * @param {lebai.auto.ISetAutoRequest} message SetAutoRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetAutoRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetAutoRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.auto.SetAutoRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.auto.SetAutoRequest} SetAutoRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetAutoRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.auto.SetAutoRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.name = reader.int32();
                            break;
                        }
                    case 2: {
                            message.value = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetAutoRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.auto.SetAutoRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.auto.SetAutoRequest} SetAutoRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetAutoRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetAutoRequest message.
             * @function verify
             * @memberof lebai.auto.SetAutoRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetAutoRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    switch (message.name) {
                    default:
                        return "name: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.value != null && message.hasOwnProperty("value"))
                    if (typeof message.value !== "boolean")
                        return "value: boolean expected";
                return null;
            };

            /**
             * Creates a SetAutoRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.auto.SetAutoRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.auto.SetAutoRequest} SetAutoRequest
             */
            SetAutoRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.auto.SetAutoRequest)
                    return object;
                var message = new $root.lebai.auto.SetAutoRequest();
                switch (object.name) {
                default:
                    if (typeof object.name === "number") {
                        message.name = object.name;
                        break;
                    }
                    break;
                case "ARM_POWER":
                case 0:
                    message.name = 0;
                    break;
                case "ENABLE_JOINT":
                case 1:
                    message.name = 1;
                    break;
                case "INIT_CLAW":
                case 2:
                    message.name = 2;
                    break;
                }
                if (object.value != null)
                    message.value = Boolean(object.value);
                return message;
            };

            /**
             * Creates a plain object from a SetAutoRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.auto.SetAutoRequest
             * @static
             * @param {lebai.auto.SetAutoRequest} message SetAutoRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetAutoRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = options.enums === String ? "ARM_POWER" : 0;
                    object.value = false;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = options.enums === String ? $root.lebai.auto.AutoCfg[message.name] === undefined ? message.name : $root.lebai.auto.AutoCfg[message.name] : message.name;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                return object;
            };

            /**
             * Converts this SetAutoRequest to JSON.
             * @function toJSON
             * @memberof lebai.auto.SetAutoRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetAutoRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetAutoRequest
             * @function getTypeUrl
             * @memberof lebai.auto.SetAutoRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetAutoRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.auto.SetAutoRequest";
            };

            return SetAutoRequest;
        })();

        auto.GetAutoRequest = (function() {

            /**
             * Properties of a GetAutoRequest.
             * @memberof lebai.auto
             * @interface IGetAutoRequest
             * @property {lebai.auto.AutoCfg|null} [name] GetAutoRequest name
             */

            /**
             * Constructs a new GetAutoRequest.
             * @memberof lebai.auto
             * @classdesc Represents a GetAutoRequest.
             * @implements IGetAutoRequest
             * @constructor
             * @param {lebai.auto.IGetAutoRequest=} [properties] Properties to set
             */
            function GetAutoRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetAutoRequest name.
             * @member {lebai.auto.AutoCfg} name
             * @memberof lebai.auto.GetAutoRequest
             * @instance
             */
            GetAutoRequest.prototype.name = 0;

            /**
             * Creates a new GetAutoRequest instance using the specified properties.
             * @function create
             * @memberof lebai.auto.GetAutoRequest
             * @static
             * @param {lebai.auto.IGetAutoRequest=} [properties] Properties to set
             * @returns {lebai.auto.GetAutoRequest} GetAutoRequest instance
             */
            GetAutoRequest.create = function create(properties) {
                return new GetAutoRequest(properties);
            };

            /**
             * Encodes the specified GetAutoRequest message. Does not implicitly {@link lebai.auto.GetAutoRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.auto.GetAutoRequest
             * @static
             * @param {lebai.auto.IGetAutoRequest} message GetAutoRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetAutoRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.name);
                return writer;
            };

            /**
             * Encodes the specified GetAutoRequest message, length delimited. Does not implicitly {@link lebai.auto.GetAutoRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.auto.GetAutoRequest
             * @static
             * @param {lebai.auto.IGetAutoRequest} message GetAutoRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetAutoRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetAutoRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.auto.GetAutoRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.auto.GetAutoRequest} GetAutoRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetAutoRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.auto.GetAutoRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.name = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetAutoRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.auto.GetAutoRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.auto.GetAutoRequest} GetAutoRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetAutoRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetAutoRequest message.
             * @function verify
             * @memberof lebai.auto.GetAutoRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetAutoRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    switch (message.name) {
                    default:
                        return "name: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                return null;
            };

            /**
             * Creates a GetAutoRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.auto.GetAutoRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.auto.GetAutoRequest} GetAutoRequest
             */
            GetAutoRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.auto.GetAutoRequest)
                    return object;
                var message = new $root.lebai.auto.GetAutoRequest();
                switch (object.name) {
                default:
                    if (typeof object.name === "number") {
                        message.name = object.name;
                        break;
                    }
                    break;
                case "ARM_POWER":
                case 0:
                    message.name = 0;
                    break;
                case "ENABLE_JOINT":
                case 1:
                    message.name = 1;
                    break;
                case "INIT_CLAW":
                case 2:
                    message.name = 2;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a GetAutoRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.auto.GetAutoRequest
             * @static
             * @param {lebai.auto.GetAutoRequest} message GetAutoRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetAutoRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.name = options.enums === String ? "ARM_POWER" : 0;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = options.enums === String ? $root.lebai.auto.AutoCfg[message.name] === undefined ? message.name : $root.lebai.auto.AutoCfg[message.name] : message.name;
                return object;
            };

            /**
             * Converts this GetAutoRequest to JSON.
             * @function toJSON
             * @memberof lebai.auto.GetAutoRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetAutoRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetAutoRequest
             * @function getTypeUrl
             * @memberof lebai.auto.GetAutoRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetAutoRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.auto.GetAutoRequest";
            };

            return GetAutoRequest;
        })();

        auto.GetAutoResponse = (function() {

            /**
             * Properties of a GetAutoResponse.
             * @memberof lebai.auto
             * @interface IGetAutoResponse
             * @property {boolean|null} [value] GetAutoResponse value
             */

            /**
             * Constructs a new GetAutoResponse.
             * @memberof lebai.auto
             * @classdesc Represents a GetAutoResponse.
             * @implements IGetAutoResponse
             * @constructor
             * @param {lebai.auto.IGetAutoResponse=} [properties] Properties to set
             */
            function GetAutoResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetAutoResponse value.
             * @member {boolean|null|undefined} value
             * @memberof lebai.auto.GetAutoResponse
             * @instance
             */
            GetAutoResponse.prototype.value = null;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * GetAutoResponse _value.
             * @member {"value"|undefined} _value
             * @memberof lebai.auto.GetAutoResponse
             * @instance
             */
            Object.defineProperty(GetAutoResponse.prototype, "_value", {
                get: $util.oneOfGetter($oneOfFields = ["value"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new GetAutoResponse instance using the specified properties.
             * @function create
             * @memberof lebai.auto.GetAutoResponse
             * @static
             * @param {lebai.auto.IGetAutoResponse=} [properties] Properties to set
             * @returns {lebai.auto.GetAutoResponse} GetAutoResponse instance
             */
            GetAutoResponse.create = function create(properties) {
                return new GetAutoResponse(properties);
            };

            /**
             * Encodes the specified GetAutoResponse message. Does not implicitly {@link lebai.auto.GetAutoResponse.verify|verify} messages.
             * @function encode
             * @memberof lebai.auto.GetAutoResponse
             * @static
             * @param {lebai.auto.IGetAutoResponse} message GetAutoResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetAutoResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.value);
                return writer;
            };

            /**
             * Encodes the specified GetAutoResponse message, length delimited. Does not implicitly {@link lebai.auto.GetAutoResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.auto.GetAutoResponse
             * @static
             * @param {lebai.auto.IGetAutoResponse} message GetAutoResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetAutoResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetAutoResponse message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.auto.GetAutoResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.auto.GetAutoResponse} GetAutoResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetAutoResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.auto.GetAutoResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2: {
                            message.value = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetAutoResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.auto.GetAutoResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.auto.GetAutoResponse} GetAutoResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetAutoResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetAutoResponse message.
             * @function verify
             * @memberof lebai.auto.GetAutoResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetAutoResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.value != null && message.hasOwnProperty("value")) {
                    properties._value = 1;
                    if (typeof message.value !== "boolean")
                        return "value: boolean expected";
                }
                return null;
            };

            /**
             * Creates a GetAutoResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.auto.GetAutoResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.auto.GetAutoResponse} GetAutoResponse
             */
            GetAutoResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.auto.GetAutoResponse)
                    return object;
                var message = new $root.lebai.auto.GetAutoResponse();
                if (object.value != null)
                    message.value = Boolean(object.value);
                return message;
            };

            /**
             * Creates a plain object from a GetAutoResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.auto.GetAutoResponse
             * @static
             * @param {lebai.auto.GetAutoResponse} message GetAutoResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetAutoResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.value != null && message.hasOwnProperty("value")) {
                    object.value = message.value;
                    if (options.oneofs)
                        object._value = "value";
                }
                return object;
            };

            /**
             * Converts this GetAutoResponse to JSON.
             * @function toJSON
             * @memberof lebai.auto.GetAutoResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetAutoResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetAutoResponse
             * @function getTypeUrl
             * @memberof lebai.auto.GetAutoResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetAutoResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.auto.GetAutoResponse";
            };

            return GetAutoResponse;
        })();

        auto.AutoService = (function() {

            /**
             * Constructs a new AutoService service.
             * @memberof lebai.auto
             * @classdesc Represents an AutoService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function AutoService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (AutoService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = AutoService;

            /**
             * Creates new AutoService service using the specified rpc implementation.
             * @function create
             * @memberof lebai.auto.AutoService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {AutoService} RPC service. Useful where requests and/or responses are streamed.
             */
            AutoService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link lebai.auto.AutoService#setAuto}.
             * @memberof lebai.auto.AutoService
             * @typedef SetAutoCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls SetAuto.
             * @function setAuto
             * @memberof lebai.auto.AutoService
             * @instance
             * @param {lebai.auto.ISetAutoRequest} request SetAutoRequest message or plain object
             * @param {lebai.auto.AutoService.SetAutoCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(AutoService.prototype.setAuto = function setAuto(request, callback) {
                return this.rpcCall(setAuto, $root.lebai.auto.SetAutoRequest, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "SetAuto" });

            /**
             * Calls SetAuto.
             * @function setAuto
             * @memberof lebai.auto.AutoService
             * @instance
             * @param {lebai.auto.ISetAutoRequest} request SetAutoRequest message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.auto.AutoService#getAuto}.
             * @memberof lebai.auto.AutoService
             * @typedef GetAutoCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.auto.GetAutoResponse} [response] GetAutoResponse
             */

            /**
             * Calls GetAuto.
             * @function getAuto
             * @memberof lebai.auto.AutoService
             * @instance
             * @param {lebai.auto.IGetAutoRequest} request GetAutoRequest message or plain object
             * @param {lebai.auto.AutoService.GetAutoCallback} callback Node-style callback called with the error, if any, and GetAutoResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(AutoService.prototype.getAuto = function getAuto(request, callback) {
                return this.rpcCall(getAuto, $root.lebai.auto.GetAutoRequest, $root.lebai.auto.GetAutoResponse, request, callback);
            }, "name", { value: "GetAuto" });

            /**
             * Calls GetAuto.
             * @function getAuto
             * @memberof lebai.auto.AutoService
             * @instance
             * @param {lebai.auto.IGetAutoRequest} request GetAutoRequest message or plain object
             * @returns {Promise<lebai.auto.GetAutoResponse>} Promise
             * @variation 2
             */

            return AutoService;
        })();

        return auto;
    })();

    lebai.backup = (function() {

        /**
         * Namespace backup.
         * @memberof lebai
         * @namespace
         */
        var backup = {};

        backup.BackupInfo = (function() {

            /**
             * Properties of a BackupInfo.
             * @memberof lebai.backup
             * @interface IBackupInfo
             * @property {lebai.system.ISystemInfo|null} [system] BackupInfo system
             * @property {lebai.system.IRobotInfo|null} [robot] BackupInfo robot
             * @property {lebai.system.IHardwareInfo|null} [hardware] BackupInfo hardware
             * @property {lebai.system.ISoftwareInfo|null} [software] BackupInfo software
             * @property {google.protobuf.ITimestamp|null} [timestamp] BackupInfo timestamp
             * @property {lebai.backup.IOptions|null} [option] BackupInfo option
             */

            /**
             * Constructs a new BackupInfo.
             * @memberof lebai.backup
             * @classdesc Represents a BackupInfo.
             * @implements IBackupInfo
             * @constructor
             * @param {lebai.backup.IBackupInfo=} [properties] Properties to set
             */
            function BackupInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BackupInfo system.
             * @member {lebai.system.ISystemInfo|null|undefined} system
             * @memberof lebai.backup.BackupInfo
             * @instance
             */
            BackupInfo.prototype.system = null;

            /**
             * BackupInfo robot.
             * @member {lebai.system.IRobotInfo|null|undefined} robot
             * @memberof lebai.backup.BackupInfo
             * @instance
             */
            BackupInfo.prototype.robot = null;

            /**
             * BackupInfo hardware.
             * @member {lebai.system.IHardwareInfo|null|undefined} hardware
             * @memberof lebai.backup.BackupInfo
             * @instance
             */
            BackupInfo.prototype.hardware = null;

            /**
             * BackupInfo software.
             * @member {lebai.system.ISoftwareInfo|null|undefined} software
             * @memberof lebai.backup.BackupInfo
             * @instance
             */
            BackupInfo.prototype.software = null;

            /**
             * BackupInfo timestamp.
             * @member {google.protobuf.ITimestamp|null|undefined} timestamp
             * @memberof lebai.backup.BackupInfo
             * @instance
             */
            BackupInfo.prototype.timestamp = null;

            /**
             * BackupInfo option.
             * @member {lebai.backup.IOptions|null|undefined} option
             * @memberof lebai.backup.BackupInfo
             * @instance
             */
            BackupInfo.prototype.option = null;

            /**
             * Creates a new BackupInfo instance using the specified properties.
             * @function create
             * @memberof lebai.backup.BackupInfo
             * @static
             * @param {lebai.backup.IBackupInfo=} [properties] Properties to set
             * @returns {lebai.backup.BackupInfo} BackupInfo instance
             */
            BackupInfo.create = function create(properties) {
                return new BackupInfo(properties);
            };

            /**
             * Encodes the specified BackupInfo message. Does not implicitly {@link lebai.backup.BackupInfo.verify|verify} messages.
             * @function encode
             * @memberof lebai.backup.BackupInfo
             * @static
             * @param {lebai.backup.IBackupInfo} message BackupInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BackupInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.system != null && Object.hasOwnProperty.call(message, "system"))
                    $root.lebai.system.SystemInfo.encode(message.system, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.robot != null && Object.hasOwnProperty.call(message, "robot"))
                    $root.lebai.system.RobotInfo.encode(message.robot, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.hardware != null && Object.hasOwnProperty.call(message, "hardware"))
                    $root.lebai.system.HardwareInfo.encode(message.hardware, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.software != null && Object.hasOwnProperty.call(message, "software"))
                    $root.lebai.system.SoftwareInfo.encode(message.software, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    $root.google.protobuf.Timestamp.encode(message.timestamp, writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
                if (message.option != null && Object.hasOwnProperty.call(message, "option"))
                    $root.lebai.backup.Options.encode(message.option, writer.uint32(/* id 22, wireType 2 =*/178).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified BackupInfo message, length delimited. Does not implicitly {@link lebai.backup.BackupInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.backup.BackupInfo
             * @static
             * @param {lebai.backup.IBackupInfo} message BackupInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BackupInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BackupInfo message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.backup.BackupInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.backup.BackupInfo} BackupInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BackupInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.backup.BackupInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.system = $root.lebai.system.SystemInfo.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.robot = $root.lebai.system.RobotInfo.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            message.hardware = $root.lebai.system.HardwareInfo.decode(reader, reader.uint32());
                            break;
                        }
                    case 4: {
                            message.software = $root.lebai.system.SoftwareInfo.decode(reader, reader.uint32());
                            break;
                        }
                    case 21: {
                            message.timestamp = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        }
                    case 22: {
                            message.option = $root.lebai.backup.Options.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BackupInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.backup.BackupInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.backup.BackupInfo} BackupInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BackupInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BackupInfo message.
             * @function verify
             * @memberof lebai.backup.BackupInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BackupInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.system != null && message.hasOwnProperty("system")) {
                    var error = $root.lebai.system.SystemInfo.verify(message.system);
                    if (error)
                        return "system." + error;
                }
                if (message.robot != null && message.hasOwnProperty("robot")) {
                    var error = $root.lebai.system.RobotInfo.verify(message.robot);
                    if (error)
                        return "robot." + error;
                }
                if (message.hardware != null && message.hasOwnProperty("hardware")) {
                    var error = $root.lebai.system.HardwareInfo.verify(message.hardware);
                    if (error)
                        return "hardware." + error;
                }
                if (message.software != null && message.hasOwnProperty("software")) {
                    var error = $root.lebai.system.SoftwareInfo.verify(message.software);
                    if (error)
                        return "software." + error;
                }
                if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
                    var error = $root.google.protobuf.Timestamp.verify(message.timestamp);
                    if (error)
                        return "timestamp." + error;
                }
                if (message.option != null && message.hasOwnProperty("option")) {
                    var error = $root.lebai.backup.Options.verify(message.option);
                    if (error)
                        return "option." + error;
                }
                return null;
            };

            /**
             * Creates a BackupInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.backup.BackupInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.backup.BackupInfo} BackupInfo
             */
            BackupInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.backup.BackupInfo)
                    return object;
                var message = new $root.lebai.backup.BackupInfo();
                if (object.system != null) {
                    if (typeof object.system !== "object")
                        throw TypeError(".lebai.backup.BackupInfo.system: object expected");
                    message.system = $root.lebai.system.SystemInfo.fromObject(object.system);
                }
                if (object.robot != null) {
                    if (typeof object.robot !== "object")
                        throw TypeError(".lebai.backup.BackupInfo.robot: object expected");
                    message.robot = $root.lebai.system.RobotInfo.fromObject(object.robot);
                }
                if (object.hardware != null) {
                    if (typeof object.hardware !== "object")
                        throw TypeError(".lebai.backup.BackupInfo.hardware: object expected");
                    message.hardware = $root.lebai.system.HardwareInfo.fromObject(object.hardware);
                }
                if (object.software != null) {
                    if (typeof object.software !== "object")
                        throw TypeError(".lebai.backup.BackupInfo.software: object expected");
                    message.software = $root.lebai.system.SoftwareInfo.fromObject(object.software);
                }
                if (object.timestamp != null) {
                    if (typeof object.timestamp !== "object")
                        throw TypeError(".lebai.backup.BackupInfo.timestamp: object expected");
                    message.timestamp = $root.google.protobuf.Timestamp.fromObject(object.timestamp);
                }
                if (object.option != null) {
                    if (typeof object.option !== "object")
                        throw TypeError(".lebai.backup.BackupInfo.option: object expected");
                    message.option = $root.lebai.backup.Options.fromObject(object.option);
                }
                return message;
            };

            /**
             * Creates a plain object from a BackupInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.backup.BackupInfo
             * @static
             * @param {lebai.backup.BackupInfo} message BackupInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BackupInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.system = null;
                    object.robot = null;
                    object.hardware = null;
                    object.software = null;
                    object.timestamp = null;
                    object.option = null;
                }
                if (message.system != null && message.hasOwnProperty("system"))
                    object.system = $root.lebai.system.SystemInfo.toObject(message.system, options);
                if (message.robot != null && message.hasOwnProperty("robot"))
                    object.robot = $root.lebai.system.RobotInfo.toObject(message.robot, options);
                if (message.hardware != null && message.hasOwnProperty("hardware"))
                    object.hardware = $root.lebai.system.HardwareInfo.toObject(message.hardware, options);
                if (message.software != null && message.hasOwnProperty("software"))
                    object.software = $root.lebai.system.SoftwareInfo.toObject(message.software, options);
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    object.timestamp = $root.google.protobuf.Timestamp.toObject(message.timestamp, options);
                if (message.option != null && message.hasOwnProperty("option"))
                    object.option = $root.lebai.backup.Options.toObject(message.option, options);
                return object;
            };

            /**
             * Converts this BackupInfo to JSON.
             * @function toJSON
             * @memberof lebai.backup.BackupInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BackupInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for BackupInfo
             * @function getTypeUrl
             * @memberof lebai.backup.BackupInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            BackupInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.backup.BackupInfo";
            };

            return BackupInfo;
        })();

        backup.Options = (function() {

            /**
             * Properties of an Options.
             * @memberof lebai.backup
             * @interface IOptions
             * @property {boolean|null} [tmp] Options tmp
             * @property {boolean|null} [arm] Options arm
             * @property {boolean|null} [config] Options config
             * @property {boolean|null} [data] Options data
             * @property {boolean|null} [file] Options file
             * @property {boolean|null} [docker] Options docker
             * @property {boolean|null} [ds] Options ds
             */

            /**
             * Constructs a new Options.
             * @memberof lebai.backup
             * @classdesc Represents an Options.
             * @implements IOptions
             * @constructor
             * @param {lebai.backup.IOptions=} [properties] Properties to set
             */
            function Options(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Options tmp.
             * @member {boolean} tmp
             * @memberof lebai.backup.Options
             * @instance
             */
            Options.prototype.tmp = false;

            /**
             * Options arm.
             * @member {boolean} arm
             * @memberof lebai.backup.Options
             * @instance
             */
            Options.prototype.arm = false;

            /**
             * Options config.
             * @member {boolean} config
             * @memberof lebai.backup.Options
             * @instance
             */
            Options.prototype.config = false;

            /**
             * Options data.
             * @member {boolean} data
             * @memberof lebai.backup.Options
             * @instance
             */
            Options.prototype.data = false;

            /**
             * Options file.
             * @member {boolean} file
             * @memberof lebai.backup.Options
             * @instance
             */
            Options.prototype.file = false;

            /**
             * Options docker.
             * @member {boolean} docker
             * @memberof lebai.backup.Options
             * @instance
             */
            Options.prototype.docker = false;

            /**
             * Options ds.
             * @member {boolean} ds
             * @memberof lebai.backup.Options
             * @instance
             */
            Options.prototype.ds = false;

            /**
             * Creates a new Options instance using the specified properties.
             * @function create
             * @memberof lebai.backup.Options
             * @static
             * @param {lebai.backup.IOptions=} [properties] Properties to set
             * @returns {lebai.backup.Options} Options instance
             */
            Options.create = function create(properties) {
                return new Options(properties);
            };

            /**
             * Encodes the specified Options message. Does not implicitly {@link lebai.backup.Options.verify|verify} messages.
             * @function encode
             * @memberof lebai.backup.Options
             * @static
             * @param {lebai.backup.IOptions} message Options message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Options.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tmp != null && Object.hasOwnProperty.call(message, "tmp"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.tmp);
                if (message.arm != null && Object.hasOwnProperty.call(message, "arm"))
                    writer.uint32(/* id 11, wireType 0 =*/88).bool(message.arm);
                if (message.config != null && Object.hasOwnProperty.call(message, "config"))
                    writer.uint32(/* id 21, wireType 0 =*/168).bool(message.config);
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    writer.uint32(/* id 22, wireType 0 =*/176).bool(message.data);
                if (message.file != null && Object.hasOwnProperty.call(message, "file"))
                    writer.uint32(/* id 23, wireType 0 =*/184).bool(message.file);
                if (message.docker != null && Object.hasOwnProperty.call(message, "docker"))
                    writer.uint32(/* id 24, wireType 0 =*/192).bool(message.docker);
                if (message.ds != null && Object.hasOwnProperty.call(message, "ds"))
                    writer.uint32(/* id 81, wireType 0 =*/648).bool(message.ds);
                return writer;
            };

            /**
             * Encodes the specified Options message, length delimited. Does not implicitly {@link lebai.backup.Options.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.backup.Options
             * @static
             * @param {lebai.backup.IOptions} message Options message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Options.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Options message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.backup.Options
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.backup.Options} Options
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Options.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.backup.Options();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.tmp = reader.bool();
                            break;
                        }
                    case 11: {
                            message.arm = reader.bool();
                            break;
                        }
                    case 21: {
                            message.config = reader.bool();
                            break;
                        }
                    case 22: {
                            message.data = reader.bool();
                            break;
                        }
                    case 23: {
                            message.file = reader.bool();
                            break;
                        }
                    case 24: {
                            message.docker = reader.bool();
                            break;
                        }
                    case 81: {
                            message.ds = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Options message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.backup.Options
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.backup.Options} Options
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Options.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Options message.
             * @function verify
             * @memberof lebai.backup.Options
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Options.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tmp != null && message.hasOwnProperty("tmp"))
                    if (typeof message.tmp !== "boolean")
                        return "tmp: boolean expected";
                if (message.arm != null && message.hasOwnProperty("arm"))
                    if (typeof message.arm !== "boolean")
                        return "arm: boolean expected";
                if (message.config != null && message.hasOwnProperty("config"))
                    if (typeof message.config !== "boolean")
                        return "config: boolean expected";
                if (message.data != null && message.hasOwnProperty("data"))
                    if (typeof message.data !== "boolean")
                        return "data: boolean expected";
                if (message.file != null && message.hasOwnProperty("file"))
                    if (typeof message.file !== "boolean")
                        return "file: boolean expected";
                if (message.docker != null && message.hasOwnProperty("docker"))
                    if (typeof message.docker !== "boolean")
                        return "docker: boolean expected";
                if (message.ds != null && message.hasOwnProperty("ds"))
                    if (typeof message.ds !== "boolean")
                        return "ds: boolean expected";
                return null;
            };

            /**
             * Creates an Options message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.backup.Options
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.backup.Options} Options
             */
            Options.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.backup.Options)
                    return object;
                var message = new $root.lebai.backup.Options();
                if (object.tmp != null)
                    message.tmp = Boolean(object.tmp);
                if (object.arm != null)
                    message.arm = Boolean(object.arm);
                if (object.config != null)
                    message.config = Boolean(object.config);
                if (object.data != null)
                    message.data = Boolean(object.data);
                if (object.file != null)
                    message.file = Boolean(object.file);
                if (object.docker != null)
                    message.docker = Boolean(object.docker);
                if (object.ds != null)
                    message.ds = Boolean(object.ds);
                return message;
            };

            /**
             * Creates a plain object from an Options message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.backup.Options
             * @static
             * @param {lebai.backup.Options} message Options
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Options.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.tmp = false;
                    object.arm = false;
                    object.config = false;
                    object.data = false;
                    object.file = false;
                    object.docker = false;
                    object.ds = false;
                }
                if (message.tmp != null && message.hasOwnProperty("tmp"))
                    object.tmp = message.tmp;
                if (message.arm != null && message.hasOwnProperty("arm"))
                    object.arm = message.arm;
                if (message.config != null && message.hasOwnProperty("config"))
                    object.config = message.config;
                if (message.data != null && message.hasOwnProperty("data"))
                    object.data = message.data;
                if (message.file != null && message.hasOwnProperty("file"))
                    object.file = message.file;
                if (message.docker != null && message.hasOwnProperty("docker"))
                    object.docker = message.docker;
                if (message.ds != null && message.hasOwnProperty("ds"))
                    object.ds = message.ds;
                return object;
            };

            /**
             * Converts this Options to JSON.
             * @function toJSON
             * @memberof lebai.backup.Options
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Options.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Options
             * @function getTypeUrl
             * @memberof lebai.backup.Options
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Options.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.backup.Options";
            };

            return Options;
        })();

        backup.BackupRequest = (function() {

            /**
             * Properties of a BackupRequest.
             * @memberof lebai.backup
             * @interface IBackupRequest
             * @property {string|null} [file] BackupRequest file
             * @property {lebai.backup.IOptions|null} [option] BackupRequest option
             */

            /**
             * Constructs a new BackupRequest.
             * @memberof lebai.backup
             * @classdesc Represents a BackupRequest.
             * @implements IBackupRequest
             * @constructor
             * @param {lebai.backup.IBackupRequest=} [properties] Properties to set
             */
            function BackupRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BackupRequest file.
             * @member {string} file
             * @memberof lebai.backup.BackupRequest
             * @instance
             */
            BackupRequest.prototype.file = "";

            /**
             * BackupRequest option.
             * @member {lebai.backup.IOptions|null|undefined} option
             * @memberof lebai.backup.BackupRequest
             * @instance
             */
            BackupRequest.prototype.option = null;

            /**
             * Creates a new BackupRequest instance using the specified properties.
             * @function create
             * @memberof lebai.backup.BackupRequest
             * @static
             * @param {lebai.backup.IBackupRequest=} [properties] Properties to set
             * @returns {lebai.backup.BackupRequest} BackupRequest instance
             */
            BackupRequest.create = function create(properties) {
                return new BackupRequest(properties);
            };

            /**
             * Encodes the specified BackupRequest message. Does not implicitly {@link lebai.backup.BackupRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.backup.BackupRequest
             * @static
             * @param {lebai.backup.IBackupRequest} message BackupRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BackupRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.file != null && Object.hasOwnProperty.call(message, "file"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.file);
                if (message.option != null && Object.hasOwnProperty.call(message, "option"))
                    $root.lebai.backup.Options.encode(message.option, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified BackupRequest message, length delimited. Does not implicitly {@link lebai.backup.BackupRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.backup.BackupRequest
             * @static
             * @param {lebai.backup.IBackupRequest} message BackupRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BackupRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BackupRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.backup.BackupRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.backup.BackupRequest} BackupRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BackupRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.backup.BackupRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.file = reader.string();
                            break;
                        }
                    case 10: {
                            message.option = $root.lebai.backup.Options.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BackupRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.backup.BackupRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.backup.BackupRequest} BackupRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BackupRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BackupRequest message.
             * @function verify
             * @memberof lebai.backup.BackupRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BackupRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.file != null && message.hasOwnProperty("file"))
                    if (!$util.isString(message.file))
                        return "file: string expected";
                if (message.option != null && message.hasOwnProperty("option")) {
                    var error = $root.lebai.backup.Options.verify(message.option);
                    if (error)
                        return "option." + error;
                }
                return null;
            };

            /**
             * Creates a BackupRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.backup.BackupRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.backup.BackupRequest} BackupRequest
             */
            BackupRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.backup.BackupRequest)
                    return object;
                var message = new $root.lebai.backup.BackupRequest();
                if (object.file != null)
                    message.file = String(object.file);
                if (object.option != null) {
                    if (typeof object.option !== "object")
                        throw TypeError(".lebai.backup.BackupRequest.option: object expected");
                    message.option = $root.lebai.backup.Options.fromObject(object.option);
                }
                return message;
            };

            /**
             * Creates a plain object from a BackupRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.backup.BackupRequest
             * @static
             * @param {lebai.backup.BackupRequest} message BackupRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BackupRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.file = "";
                    object.option = null;
                }
                if (message.file != null && message.hasOwnProperty("file"))
                    object.file = message.file;
                if (message.option != null && message.hasOwnProperty("option"))
                    object.option = $root.lebai.backup.Options.toObject(message.option, options);
                return object;
            };

            /**
             * Converts this BackupRequest to JSON.
             * @function toJSON
             * @memberof lebai.backup.BackupRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BackupRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for BackupRequest
             * @function getTypeUrl
             * @memberof lebai.backup.BackupRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            BackupRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.backup.BackupRequest";
            };

            return BackupRequest;
        })();

        backup.GetBackupInfoRequest = (function() {

            /**
             * Properties of a GetBackupInfoRequest.
             * @memberof lebai.backup
             * @interface IGetBackupInfoRequest
             * @property {string|null} [file] GetBackupInfoRequest file
             */

            /**
             * Constructs a new GetBackupInfoRequest.
             * @memberof lebai.backup
             * @classdesc Represents a GetBackupInfoRequest.
             * @implements IGetBackupInfoRequest
             * @constructor
             * @param {lebai.backup.IGetBackupInfoRequest=} [properties] Properties to set
             */
            function GetBackupInfoRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetBackupInfoRequest file.
             * @member {string} file
             * @memberof lebai.backup.GetBackupInfoRequest
             * @instance
             */
            GetBackupInfoRequest.prototype.file = "";

            /**
             * Creates a new GetBackupInfoRequest instance using the specified properties.
             * @function create
             * @memberof lebai.backup.GetBackupInfoRequest
             * @static
             * @param {lebai.backup.IGetBackupInfoRequest=} [properties] Properties to set
             * @returns {lebai.backup.GetBackupInfoRequest} GetBackupInfoRequest instance
             */
            GetBackupInfoRequest.create = function create(properties) {
                return new GetBackupInfoRequest(properties);
            };

            /**
             * Encodes the specified GetBackupInfoRequest message. Does not implicitly {@link lebai.backup.GetBackupInfoRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.backup.GetBackupInfoRequest
             * @static
             * @param {lebai.backup.IGetBackupInfoRequest} message GetBackupInfoRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetBackupInfoRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.file != null && Object.hasOwnProperty.call(message, "file"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.file);
                return writer;
            };

            /**
             * Encodes the specified GetBackupInfoRequest message, length delimited. Does not implicitly {@link lebai.backup.GetBackupInfoRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.backup.GetBackupInfoRequest
             * @static
             * @param {lebai.backup.IGetBackupInfoRequest} message GetBackupInfoRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetBackupInfoRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetBackupInfoRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.backup.GetBackupInfoRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.backup.GetBackupInfoRequest} GetBackupInfoRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetBackupInfoRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.backup.GetBackupInfoRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.file = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetBackupInfoRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.backup.GetBackupInfoRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.backup.GetBackupInfoRequest} GetBackupInfoRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetBackupInfoRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetBackupInfoRequest message.
             * @function verify
             * @memberof lebai.backup.GetBackupInfoRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetBackupInfoRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.file != null && message.hasOwnProperty("file"))
                    if (!$util.isString(message.file))
                        return "file: string expected";
                return null;
            };

            /**
             * Creates a GetBackupInfoRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.backup.GetBackupInfoRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.backup.GetBackupInfoRequest} GetBackupInfoRequest
             */
            GetBackupInfoRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.backup.GetBackupInfoRequest)
                    return object;
                var message = new $root.lebai.backup.GetBackupInfoRequest();
                if (object.file != null)
                    message.file = String(object.file);
                return message;
            };

            /**
             * Creates a plain object from a GetBackupInfoRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.backup.GetBackupInfoRequest
             * @static
             * @param {lebai.backup.GetBackupInfoRequest} message GetBackupInfoRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetBackupInfoRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.file = "";
                if (message.file != null && message.hasOwnProperty("file"))
                    object.file = message.file;
                return object;
            };

            /**
             * Converts this GetBackupInfoRequest to JSON.
             * @function toJSON
             * @memberof lebai.backup.GetBackupInfoRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetBackupInfoRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetBackupInfoRequest
             * @function getTypeUrl
             * @memberof lebai.backup.GetBackupInfoRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetBackupInfoRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.backup.GetBackupInfoRequest";
            };

            return GetBackupInfoRequest;
        })();

        backup.RestoreRequest = (function() {

            /**
             * Properties of a RestoreRequest.
             * @memberof lebai.backup
             * @interface IRestoreRequest
             * @property {string|null} [file] RestoreRequest file
             * @property {lebai.backup.IOptions|null} [option] RestoreRequest option
             */

            /**
             * Constructs a new RestoreRequest.
             * @memberof lebai.backup
             * @classdesc Represents a RestoreRequest.
             * @implements IRestoreRequest
             * @constructor
             * @param {lebai.backup.IRestoreRequest=} [properties] Properties to set
             */
            function RestoreRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RestoreRequest file.
             * @member {string} file
             * @memberof lebai.backup.RestoreRequest
             * @instance
             */
            RestoreRequest.prototype.file = "";

            /**
             * RestoreRequest option.
             * @member {lebai.backup.IOptions|null|undefined} option
             * @memberof lebai.backup.RestoreRequest
             * @instance
             */
            RestoreRequest.prototype.option = null;

            /**
             * Creates a new RestoreRequest instance using the specified properties.
             * @function create
             * @memberof lebai.backup.RestoreRequest
             * @static
             * @param {lebai.backup.IRestoreRequest=} [properties] Properties to set
             * @returns {lebai.backup.RestoreRequest} RestoreRequest instance
             */
            RestoreRequest.create = function create(properties) {
                return new RestoreRequest(properties);
            };

            /**
             * Encodes the specified RestoreRequest message. Does not implicitly {@link lebai.backup.RestoreRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.backup.RestoreRequest
             * @static
             * @param {lebai.backup.IRestoreRequest} message RestoreRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RestoreRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.file != null && Object.hasOwnProperty.call(message, "file"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.file);
                if (message.option != null && Object.hasOwnProperty.call(message, "option"))
                    $root.lebai.backup.Options.encode(message.option, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RestoreRequest message, length delimited. Does not implicitly {@link lebai.backup.RestoreRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.backup.RestoreRequest
             * @static
             * @param {lebai.backup.IRestoreRequest} message RestoreRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RestoreRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RestoreRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.backup.RestoreRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.backup.RestoreRequest} RestoreRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RestoreRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.backup.RestoreRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.file = reader.string();
                            break;
                        }
                    case 10: {
                            message.option = $root.lebai.backup.Options.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RestoreRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.backup.RestoreRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.backup.RestoreRequest} RestoreRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RestoreRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RestoreRequest message.
             * @function verify
             * @memberof lebai.backup.RestoreRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RestoreRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.file != null && message.hasOwnProperty("file"))
                    if (!$util.isString(message.file))
                        return "file: string expected";
                if (message.option != null && message.hasOwnProperty("option")) {
                    var error = $root.lebai.backup.Options.verify(message.option);
                    if (error)
                        return "option." + error;
                }
                return null;
            };

            /**
             * Creates a RestoreRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.backup.RestoreRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.backup.RestoreRequest} RestoreRequest
             */
            RestoreRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.backup.RestoreRequest)
                    return object;
                var message = new $root.lebai.backup.RestoreRequest();
                if (object.file != null)
                    message.file = String(object.file);
                if (object.option != null) {
                    if (typeof object.option !== "object")
                        throw TypeError(".lebai.backup.RestoreRequest.option: object expected");
                    message.option = $root.lebai.backup.Options.fromObject(object.option);
                }
                return message;
            };

            /**
             * Creates a plain object from a RestoreRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.backup.RestoreRequest
             * @static
             * @param {lebai.backup.RestoreRequest} message RestoreRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RestoreRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.file = "";
                    object.option = null;
                }
                if (message.file != null && message.hasOwnProperty("file"))
                    object.file = message.file;
                if (message.option != null && message.hasOwnProperty("option"))
                    object.option = $root.lebai.backup.Options.toObject(message.option, options);
                return object;
            };

            /**
             * Converts this RestoreRequest to JSON.
             * @function toJSON
             * @memberof lebai.backup.RestoreRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RestoreRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for RestoreRequest
             * @function getTypeUrl
             * @memberof lebai.backup.RestoreRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            RestoreRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.backup.RestoreRequest";
            };

            return RestoreRequest;
        })();

        backup.BackupService = (function() {

            /**
             * Constructs a new BackupService service.
             * @memberof lebai.backup
             * @classdesc Represents a BackupService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function BackupService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (BackupService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = BackupService;

            /**
             * Creates new BackupService service using the specified rpc implementation.
             * @function create
             * @memberof lebai.backup.BackupService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {BackupService} RPC service. Useful where requests and/or responses are streamed.
             */
            BackupService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link lebai.backup.BackupService#clean}.
             * @memberof lebai.backup.BackupService
             * @typedef CleanCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls Clean.
             * @function clean
             * @memberof lebai.backup.BackupService
             * @instance
             * @param {lebai.backup.IOptions} request Options message or plain object
             * @param {lebai.backup.BackupService.CleanCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(BackupService.prototype.clean = function clean(request, callback) {
                return this.rpcCall(clean, $root.lebai.backup.Options, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "Clean" });

            /**
             * Calls Clean.
             * @function clean
             * @memberof lebai.backup.BackupService
             * @instance
             * @param {lebai.backup.IOptions} request Options message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.backup.BackupService#backup}.
             * @memberof lebai.backup.BackupService
             * @typedef BackupCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls Backup.
             * @function backup
             * @memberof lebai.backup.BackupService
             * @instance
             * @param {lebai.backup.IBackupRequest} request BackupRequest message or plain object
             * @param {lebai.backup.BackupService.BackupCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(BackupService.prototype.backup = function backup(request, callback) {
                return this.rpcCall(backup, $root.lebai.backup.BackupRequest, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "Backup" });

            /**
             * Calls Backup.
             * @function backup
             * @memberof lebai.backup.BackupService
             * @instance
             * @param {lebai.backup.IBackupRequest} request BackupRequest message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.backup.BackupService#getBackupInfo}.
             * @memberof lebai.backup.BackupService
             * @typedef GetBackupInfoCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.backup.BackupInfo} [response] BackupInfo
             */

            /**
             * Calls GetBackupInfo.
             * @function getBackupInfo
             * @memberof lebai.backup.BackupService
             * @instance
             * @param {lebai.backup.IGetBackupInfoRequest} request GetBackupInfoRequest message or plain object
             * @param {lebai.backup.BackupService.GetBackupInfoCallback} callback Node-style callback called with the error, if any, and BackupInfo
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(BackupService.prototype.getBackupInfo = function getBackupInfo(request, callback) {
                return this.rpcCall(getBackupInfo, $root.lebai.backup.GetBackupInfoRequest, $root.lebai.backup.BackupInfo, request, callback);
            }, "name", { value: "GetBackupInfo" });

            /**
             * Calls GetBackupInfo.
             * @function getBackupInfo
             * @memberof lebai.backup.BackupService
             * @instance
             * @param {lebai.backup.IGetBackupInfoRequest} request GetBackupInfoRequest message or plain object
             * @returns {Promise<lebai.backup.BackupInfo>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.backup.BackupService#restore}.
             * @memberof lebai.backup.BackupService
             * @typedef RestoreCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls Restore.
             * @function restore
             * @memberof lebai.backup.BackupService
             * @instance
             * @param {lebai.backup.IRestoreRequest} request RestoreRequest message or plain object
             * @param {lebai.backup.BackupService.RestoreCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(BackupService.prototype.restore = function restore(request, callback) {
                return this.rpcCall(restore, $root.lebai.backup.RestoreRequest, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "Restore" });

            /**
             * Calls Restore.
             * @function restore
             * @memberof lebai.backup.BackupService
             * @instance
             * @param {lebai.backup.IRestoreRequest} request RestoreRequest message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            return BackupService;
        })();

        return backup;
    })();

    lebai.system = (function() {

        /**
         * Namespace system.
         * @memberof lebai
         * @namespace
         */
        var system = {};

        system.HelloData = (function() {

            /**
             * Properties of a HelloData.
             * @memberof lebai.system
             * @interface IHelloData
             * @property {string|null} [data] HelloData data
             */

            /**
             * Constructs a new HelloData.
             * @memberof lebai.system
             * @classdesc Represents a HelloData.
             * @implements IHelloData
             * @constructor
             * @param {lebai.system.IHelloData=} [properties] Properties to set
             */
            function HelloData(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * HelloData data.
             * @member {string} data
             * @memberof lebai.system.HelloData
             * @instance
             */
            HelloData.prototype.data = "";

            /**
             * Creates a new HelloData instance using the specified properties.
             * @function create
             * @memberof lebai.system.HelloData
             * @static
             * @param {lebai.system.IHelloData=} [properties] Properties to set
             * @returns {lebai.system.HelloData} HelloData instance
             */
            HelloData.create = function create(properties) {
                return new HelloData(properties);
            };

            /**
             * Encodes the specified HelloData message. Does not implicitly {@link lebai.system.HelloData.verify|verify} messages.
             * @function encode
             * @memberof lebai.system.HelloData
             * @static
             * @param {lebai.system.IHelloData} message HelloData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HelloData.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.data);
                return writer;
            };

            /**
             * Encodes the specified HelloData message, length delimited. Does not implicitly {@link lebai.system.HelloData.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.system.HelloData
             * @static
             * @param {lebai.system.IHelloData} message HelloData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HelloData.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a HelloData message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.system.HelloData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.system.HelloData} HelloData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HelloData.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.system.HelloData();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.data = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a HelloData message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.system.HelloData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.system.HelloData} HelloData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HelloData.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a HelloData message.
             * @function verify
             * @memberof lebai.system.HelloData
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            HelloData.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.data != null && message.hasOwnProperty("data"))
                    if (!$util.isString(message.data))
                        return "data: string expected";
                return null;
            };

            /**
             * Creates a HelloData message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.system.HelloData
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.system.HelloData} HelloData
             */
            HelloData.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.system.HelloData)
                    return object;
                var message = new $root.lebai.system.HelloData();
                if (object.data != null)
                    message.data = String(object.data);
                return message;
            };

            /**
             * Creates a plain object from a HelloData message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.system.HelloData
             * @static
             * @param {lebai.system.HelloData} message HelloData
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            HelloData.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.data = "";
                if (message.data != null && message.hasOwnProperty("data"))
                    object.data = message.data;
                return object;
            };

            /**
             * Converts this HelloData to JSON.
             * @function toJSON
             * @memberof lebai.system.HelloData
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            HelloData.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for HelloData
             * @function getTypeUrl
             * @memberof lebai.system.HelloData
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            HelloData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.system.HelloData";
            };

            return HelloData;
        })();

        system.MemoryInfo = (function() {

            /**
             * Properties of a MemoryInfo.
             * @memberof lebai.system
             * @interface IMemoryInfo
             * @property {number|Long|null} [used] MemoryInfo used
             * @property {number|Long|null} [total] MemoryInfo total
             * @property {number|Long|null} [usedSwap] MemoryInfo usedSwap
             * @property {number|Long|null} [totalSwap] MemoryInfo totalSwap
             */

            /**
             * Constructs a new MemoryInfo.
             * @memberof lebai.system
             * @classdesc Represents a MemoryInfo.
             * @implements IMemoryInfo
             * @constructor
             * @param {lebai.system.IMemoryInfo=} [properties] Properties to set
             */
            function MemoryInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MemoryInfo used.
             * @member {number|Long} used
             * @memberof lebai.system.MemoryInfo
             * @instance
             */
            MemoryInfo.prototype.used = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * MemoryInfo total.
             * @member {number|Long} total
             * @memberof lebai.system.MemoryInfo
             * @instance
             */
            MemoryInfo.prototype.total = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * MemoryInfo usedSwap.
             * @member {number|Long} usedSwap
             * @memberof lebai.system.MemoryInfo
             * @instance
             */
            MemoryInfo.prototype.usedSwap = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * MemoryInfo totalSwap.
             * @member {number|Long} totalSwap
             * @memberof lebai.system.MemoryInfo
             * @instance
             */
            MemoryInfo.prototype.totalSwap = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new MemoryInfo instance using the specified properties.
             * @function create
             * @memberof lebai.system.MemoryInfo
             * @static
             * @param {lebai.system.IMemoryInfo=} [properties] Properties to set
             * @returns {lebai.system.MemoryInfo} MemoryInfo instance
             */
            MemoryInfo.create = function create(properties) {
                return new MemoryInfo(properties);
            };

            /**
             * Encodes the specified MemoryInfo message. Does not implicitly {@link lebai.system.MemoryInfo.verify|verify} messages.
             * @function encode
             * @memberof lebai.system.MemoryInfo
             * @static
             * @param {lebai.system.IMemoryInfo} message MemoryInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MemoryInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.used != null && Object.hasOwnProperty.call(message, "used"))
                    writer.uint32(/* id 11, wireType 0 =*/88).uint64(message.used);
                if (message.total != null && Object.hasOwnProperty.call(message, "total"))
                    writer.uint32(/* id 12, wireType 0 =*/96).uint64(message.total);
                if (message.usedSwap != null && Object.hasOwnProperty.call(message, "usedSwap"))
                    writer.uint32(/* id 21, wireType 0 =*/168).uint64(message.usedSwap);
                if (message.totalSwap != null && Object.hasOwnProperty.call(message, "totalSwap"))
                    writer.uint32(/* id 22, wireType 0 =*/176).uint64(message.totalSwap);
                return writer;
            };

            /**
             * Encodes the specified MemoryInfo message, length delimited. Does not implicitly {@link lebai.system.MemoryInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.system.MemoryInfo
             * @static
             * @param {lebai.system.IMemoryInfo} message MemoryInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MemoryInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MemoryInfo message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.system.MemoryInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.system.MemoryInfo} MemoryInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MemoryInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.system.MemoryInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 11: {
                            message.used = reader.uint64();
                            break;
                        }
                    case 12: {
                            message.total = reader.uint64();
                            break;
                        }
                    case 21: {
                            message.usedSwap = reader.uint64();
                            break;
                        }
                    case 22: {
                            message.totalSwap = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MemoryInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.system.MemoryInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.system.MemoryInfo} MemoryInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MemoryInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MemoryInfo message.
             * @function verify
             * @memberof lebai.system.MemoryInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MemoryInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.used != null && message.hasOwnProperty("used"))
                    if (!$util.isInteger(message.used) && !(message.used && $util.isInteger(message.used.low) && $util.isInteger(message.used.high)))
                        return "used: integer|Long expected";
                if (message.total != null && message.hasOwnProperty("total"))
                    if (!$util.isInteger(message.total) && !(message.total && $util.isInteger(message.total.low) && $util.isInteger(message.total.high)))
                        return "total: integer|Long expected";
                if (message.usedSwap != null && message.hasOwnProperty("usedSwap"))
                    if (!$util.isInteger(message.usedSwap) && !(message.usedSwap && $util.isInteger(message.usedSwap.low) && $util.isInteger(message.usedSwap.high)))
                        return "usedSwap: integer|Long expected";
                if (message.totalSwap != null && message.hasOwnProperty("totalSwap"))
                    if (!$util.isInteger(message.totalSwap) && !(message.totalSwap && $util.isInteger(message.totalSwap.low) && $util.isInteger(message.totalSwap.high)))
                        return "totalSwap: integer|Long expected";
                return null;
            };

            /**
             * Creates a MemoryInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.system.MemoryInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.system.MemoryInfo} MemoryInfo
             */
            MemoryInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.system.MemoryInfo)
                    return object;
                var message = new $root.lebai.system.MemoryInfo();
                if (object.used != null)
                    if ($util.Long)
                        (message.used = $util.Long.fromValue(object.used)).unsigned = true;
                    else if (typeof object.used === "string")
                        message.used = parseInt(object.used, 10);
                    else if (typeof object.used === "number")
                        message.used = object.used;
                    else if (typeof object.used === "object")
                        message.used = new $util.LongBits(object.used.low >>> 0, object.used.high >>> 0).toNumber(true);
                if (object.total != null)
                    if ($util.Long)
                        (message.total = $util.Long.fromValue(object.total)).unsigned = true;
                    else if (typeof object.total === "string")
                        message.total = parseInt(object.total, 10);
                    else if (typeof object.total === "number")
                        message.total = object.total;
                    else if (typeof object.total === "object")
                        message.total = new $util.LongBits(object.total.low >>> 0, object.total.high >>> 0).toNumber(true);
                if (object.usedSwap != null)
                    if ($util.Long)
                        (message.usedSwap = $util.Long.fromValue(object.usedSwap)).unsigned = true;
                    else if (typeof object.usedSwap === "string")
                        message.usedSwap = parseInt(object.usedSwap, 10);
                    else if (typeof object.usedSwap === "number")
                        message.usedSwap = object.usedSwap;
                    else if (typeof object.usedSwap === "object")
                        message.usedSwap = new $util.LongBits(object.usedSwap.low >>> 0, object.usedSwap.high >>> 0).toNumber(true);
                if (object.totalSwap != null)
                    if ($util.Long)
                        (message.totalSwap = $util.Long.fromValue(object.totalSwap)).unsigned = true;
                    else if (typeof object.totalSwap === "string")
                        message.totalSwap = parseInt(object.totalSwap, 10);
                    else if (typeof object.totalSwap === "number")
                        message.totalSwap = object.totalSwap;
                    else if (typeof object.totalSwap === "object")
                        message.totalSwap = new $util.LongBits(object.totalSwap.low >>> 0, object.totalSwap.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a MemoryInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.system.MemoryInfo
             * @static
             * @param {lebai.system.MemoryInfo} message MemoryInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MemoryInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.used = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.used = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.total = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.total = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.usedSwap = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.usedSwap = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.totalSwap = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.totalSwap = options.longs === String ? "0" : 0;
                }
                if (message.used != null && message.hasOwnProperty("used"))
                    if (typeof message.used === "number")
                        object.used = options.longs === String ? String(message.used) : message.used;
                    else
                        object.used = options.longs === String ? $util.Long.prototype.toString.call(message.used) : options.longs === Number ? new $util.LongBits(message.used.low >>> 0, message.used.high >>> 0).toNumber(true) : message.used;
                if (message.total != null && message.hasOwnProperty("total"))
                    if (typeof message.total === "number")
                        object.total = options.longs === String ? String(message.total) : message.total;
                    else
                        object.total = options.longs === String ? $util.Long.prototype.toString.call(message.total) : options.longs === Number ? new $util.LongBits(message.total.low >>> 0, message.total.high >>> 0).toNumber(true) : message.total;
                if (message.usedSwap != null && message.hasOwnProperty("usedSwap"))
                    if (typeof message.usedSwap === "number")
                        object.usedSwap = options.longs === String ? String(message.usedSwap) : message.usedSwap;
                    else
                        object.usedSwap = options.longs === String ? $util.Long.prototype.toString.call(message.usedSwap) : options.longs === Number ? new $util.LongBits(message.usedSwap.low >>> 0, message.usedSwap.high >>> 0).toNumber(true) : message.usedSwap;
                if (message.totalSwap != null && message.hasOwnProperty("totalSwap"))
                    if (typeof message.totalSwap === "number")
                        object.totalSwap = options.longs === String ? String(message.totalSwap) : message.totalSwap;
                    else
                        object.totalSwap = options.longs === String ? $util.Long.prototype.toString.call(message.totalSwap) : options.longs === Number ? new $util.LongBits(message.totalSwap.low >>> 0, message.totalSwap.high >>> 0).toNumber(true) : message.totalSwap;
                return object;
            };

            /**
             * Converts this MemoryInfo to JSON.
             * @function toJSON
             * @memberof lebai.system.MemoryInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MemoryInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MemoryInfo
             * @function getTypeUrl
             * @memberof lebai.system.MemoryInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MemoryInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.system.MemoryInfo";
            };

            return MemoryInfo;
        })();

        system.DiskInfo = (function() {

            /**
             * Properties of a DiskInfo.
             * @memberof lebai.system
             * @interface IDiskInfo
             * @property {string|null} [name] DiskInfo name
             * @property {number|Long|null} [used] DiskInfo used
             * @property {number|Long|null} [total] DiskInfo total
             */

            /**
             * Constructs a new DiskInfo.
             * @memberof lebai.system
             * @classdesc Represents a DiskInfo.
             * @implements IDiskInfo
             * @constructor
             * @param {lebai.system.IDiskInfo=} [properties] Properties to set
             */
            function DiskInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DiskInfo name.
             * @member {string} name
             * @memberof lebai.system.DiskInfo
             * @instance
             */
            DiskInfo.prototype.name = "";

            /**
             * DiskInfo used.
             * @member {number|Long} used
             * @memberof lebai.system.DiskInfo
             * @instance
             */
            DiskInfo.prototype.used = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * DiskInfo total.
             * @member {number|Long} total
             * @memberof lebai.system.DiskInfo
             * @instance
             */
            DiskInfo.prototype.total = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new DiskInfo instance using the specified properties.
             * @function create
             * @memberof lebai.system.DiskInfo
             * @static
             * @param {lebai.system.IDiskInfo=} [properties] Properties to set
             * @returns {lebai.system.DiskInfo} DiskInfo instance
             */
            DiskInfo.create = function create(properties) {
                return new DiskInfo(properties);
            };

            /**
             * Encodes the specified DiskInfo message. Does not implicitly {@link lebai.system.DiskInfo.verify|verify} messages.
             * @function encode
             * @memberof lebai.system.DiskInfo
             * @static
             * @param {lebai.system.IDiskInfo} message DiskInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DiskInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.used != null && Object.hasOwnProperty.call(message, "used"))
                    writer.uint32(/* id 11, wireType 0 =*/88).uint64(message.used);
                if (message.total != null && Object.hasOwnProperty.call(message, "total"))
                    writer.uint32(/* id 12, wireType 0 =*/96).uint64(message.total);
                return writer;
            };

            /**
             * Encodes the specified DiskInfo message, length delimited. Does not implicitly {@link lebai.system.DiskInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.system.DiskInfo
             * @static
             * @param {lebai.system.IDiskInfo} message DiskInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DiskInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DiskInfo message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.system.DiskInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.system.DiskInfo} DiskInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DiskInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.system.DiskInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.name = reader.string();
                            break;
                        }
                    case 11: {
                            message.used = reader.uint64();
                            break;
                        }
                    case 12: {
                            message.total = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DiskInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.system.DiskInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.system.DiskInfo} DiskInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DiskInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DiskInfo message.
             * @function verify
             * @memberof lebai.system.DiskInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DiskInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.used != null && message.hasOwnProperty("used"))
                    if (!$util.isInteger(message.used) && !(message.used && $util.isInteger(message.used.low) && $util.isInteger(message.used.high)))
                        return "used: integer|Long expected";
                if (message.total != null && message.hasOwnProperty("total"))
                    if (!$util.isInteger(message.total) && !(message.total && $util.isInteger(message.total.low) && $util.isInteger(message.total.high)))
                        return "total: integer|Long expected";
                return null;
            };

            /**
             * Creates a DiskInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.system.DiskInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.system.DiskInfo} DiskInfo
             */
            DiskInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.system.DiskInfo)
                    return object;
                var message = new $root.lebai.system.DiskInfo();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.used != null)
                    if ($util.Long)
                        (message.used = $util.Long.fromValue(object.used)).unsigned = true;
                    else if (typeof object.used === "string")
                        message.used = parseInt(object.used, 10);
                    else if (typeof object.used === "number")
                        message.used = object.used;
                    else if (typeof object.used === "object")
                        message.used = new $util.LongBits(object.used.low >>> 0, object.used.high >>> 0).toNumber(true);
                if (object.total != null)
                    if ($util.Long)
                        (message.total = $util.Long.fromValue(object.total)).unsigned = true;
                    else if (typeof object.total === "string")
                        message.total = parseInt(object.total, 10);
                    else if (typeof object.total === "number")
                        message.total = object.total;
                    else if (typeof object.total === "object")
                        message.total = new $util.LongBits(object.total.low >>> 0, object.total.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a DiskInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.system.DiskInfo
             * @static
             * @param {lebai.system.DiskInfo} message DiskInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DiskInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.used = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.used = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.total = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.total = options.longs === String ? "0" : 0;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.used != null && message.hasOwnProperty("used"))
                    if (typeof message.used === "number")
                        object.used = options.longs === String ? String(message.used) : message.used;
                    else
                        object.used = options.longs === String ? $util.Long.prototype.toString.call(message.used) : options.longs === Number ? new $util.LongBits(message.used.low >>> 0, message.used.high >>> 0).toNumber(true) : message.used;
                if (message.total != null && message.hasOwnProperty("total"))
                    if (typeof message.total === "number")
                        object.total = options.longs === String ? String(message.total) : message.total;
                    else
                        object.total = options.longs === String ? $util.Long.prototype.toString.call(message.total) : options.longs === Number ? new $util.LongBits(message.total.low >>> 0, message.total.high >>> 0).toNumber(true) : message.total;
                return object;
            };

            /**
             * Converts this DiskInfo to JSON.
             * @function toJSON
             * @memberof lebai.system.DiskInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DiskInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DiskInfo
             * @function getTypeUrl
             * @memberof lebai.system.DiskInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DiskInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.system.DiskInfo";
            };

            return DiskInfo;
        })();

        /**
         * NetworkKind enum.
         * @name lebai.system.NetworkKind
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} LOOPBACK=1 LOOPBACK value
         * @property {number} ETHERNET=2 ETHERNET value
         * @property {number} WIRELESS=3 WIRELESS value
         * @property {number} CELLULAR=4 CELLULAR value
         * @property {number} USB=5 USB value
         * @property {number} DOCKER=11 DOCKER value
         */
        system.NetworkKind = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "LOOPBACK"] = 1;
            values[valuesById[2] = "ETHERNET"] = 2;
            values[valuesById[3] = "WIRELESS"] = 3;
            values[valuesById[4] = "CELLULAR"] = 4;
            values[valuesById[5] = "USB"] = 5;
            values[valuesById[11] = "DOCKER"] = 11;
            return values;
        })();

        system.NetworkInfo = (function() {

            /**
             * Properties of a NetworkInfo.
             * @memberof lebai.system
             * @interface INetworkInfo
             * @property {string|null} [ifname] NetworkInfo ifname
             * @property {lebai.system.NetworkKind|null} [kind] NetworkInfo kind
             * @property {string|null} [mac] NetworkInfo mac
             * @property {Array.<string>|null} [ips] NetworkInfo ips
             * @property {Array.<string>|null} [virtualIps] NetworkInfo virtualIps
             * @property {string|null} [gateway] NetworkInfo gateway
             * @property {string|null} [netmask] NetworkInfo netmask
             */

            /**
             * Constructs a new NetworkInfo.
             * @memberof lebai.system
             * @classdesc Represents a NetworkInfo.
             * @implements INetworkInfo
             * @constructor
             * @param {lebai.system.INetworkInfo=} [properties] Properties to set
             */
            function NetworkInfo(properties) {
                this.ips = [];
                this.virtualIps = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NetworkInfo ifname.
             * @member {string} ifname
             * @memberof lebai.system.NetworkInfo
             * @instance
             */
            NetworkInfo.prototype.ifname = "";

            /**
             * NetworkInfo kind.
             * @member {lebai.system.NetworkKind} kind
             * @memberof lebai.system.NetworkInfo
             * @instance
             */
            NetworkInfo.prototype.kind = 0;

            /**
             * NetworkInfo mac.
             * @member {string} mac
             * @memberof lebai.system.NetworkInfo
             * @instance
             */
            NetworkInfo.prototype.mac = "";

            /**
             * NetworkInfo ips.
             * @member {Array.<string>} ips
             * @memberof lebai.system.NetworkInfo
             * @instance
             */
            NetworkInfo.prototype.ips = $util.emptyArray;

            /**
             * NetworkInfo virtualIps.
             * @member {Array.<string>} virtualIps
             * @memberof lebai.system.NetworkInfo
             * @instance
             */
            NetworkInfo.prototype.virtualIps = $util.emptyArray;

            /**
             * NetworkInfo gateway.
             * @member {string} gateway
             * @memberof lebai.system.NetworkInfo
             * @instance
             */
            NetworkInfo.prototype.gateway = "";

            /**
             * NetworkInfo netmask.
             * @member {string} netmask
             * @memberof lebai.system.NetworkInfo
             * @instance
             */
            NetworkInfo.prototype.netmask = "";

            /**
             * Creates a new NetworkInfo instance using the specified properties.
             * @function create
             * @memberof lebai.system.NetworkInfo
             * @static
             * @param {lebai.system.INetworkInfo=} [properties] Properties to set
             * @returns {lebai.system.NetworkInfo} NetworkInfo instance
             */
            NetworkInfo.create = function create(properties) {
                return new NetworkInfo(properties);
            };

            /**
             * Encodes the specified NetworkInfo message. Does not implicitly {@link lebai.system.NetworkInfo.verify|verify} messages.
             * @function encode
             * @memberof lebai.system.NetworkInfo
             * @static
             * @param {lebai.system.INetworkInfo} message NetworkInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NetworkInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.ifname != null && Object.hasOwnProperty.call(message, "ifname"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.ifname);
                if (message.kind != null && Object.hasOwnProperty.call(message, "kind"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.kind);
                if (message.mac != null && Object.hasOwnProperty.call(message, "mac"))
                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.mac);
                if (message.ips != null && message.ips.length)
                    for (var i = 0; i < message.ips.length; ++i)
                        writer.uint32(/* id 11, wireType 2 =*/90).string(message.ips[i]);
                if (message.virtualIps != null && message.virtualIps.length)
                    for (var i = 0; i < message.virtualIps.length; ++i)
                        writer.uint32(/* id 12, wireType 2 =*/98).string(message.virtualIps[i]);
                if (message.gateway != null && Object.hasOwnProperty.call(message, "gateway"))
                    writer.uint32(/* id 21, wireType 2 =*/170).string(message.gateway);
                if (message.netmask != null && Object.hasOwnProperty.call(message, "netmask"))
                    writer.uint32(/* id 22, wireType 2 =*/178).string(message.netmask);
                return writer;
            };

            /**
             * Encodes the specified NetworkInfo message, length delimited. Does not implicitly {@link lebai.system.NetworkInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.system.NetworkInfo
             * @static
             * @param {lebai.system.INetworkInfo} message NetworkInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NetworkInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NetworkInfo message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.system.NetworkInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.system.NetworkInfo} NetworkInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NetworkInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.system.NetworkInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.ifname = reader.string();
                            break;
                        }
                    case 2: {
                            message.kind = reader.int32();
                            break;
                        }
                    case 9: {
                            message.mac = reader.string();
                            break;
                        }
                    case 11: {
                            if (!(message.ips && message.ips.length))
                                message.ips = [];
                            message.ips.push(reader.string());
                            break;
                        }
                    case 12: {
                            if (!(message.virtualIps && message.virtualIps.length))
                                message.virtualIps = [];
                            message.virtualIps.push(reader.string());
                            break;
                        }
                    case 21: {
                            message.gateway = reader.string();
                            break;
                        }
                    case 22: {
                            message.netmask = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NetworkInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.system.NetworkInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.system.NetworkInfo} NetworkInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NetworkInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NetworkInfo message.
             * @function verify
             * @memberof lebai.system.NetworkInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NetworkInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.ifname != null && message.hasOwnProperty("ifname"))
                    if (!$util.isString(message.ifname))
                        return "ifname: string expected";
                if (message.kind != null && message.hasOwnProperty("kind"))
                    switch (message.kind) {
                    default:
                        return "kind: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 11:
                        break;
                    }
                if (message.mac != null && message.hasOwnProperty("mac"))
                    if (!$util.isString(message.mac))
                        return "mac: string expected";
                if (message.ips != null && message.hasOwnProperty("ips")) {
                    if (!Array.isArray(message.ips))
                        return "ips: array expected";
                    for (var i = 0; i < message.ips.length; ++i)
                        if (!$util.isString(message.ips[i]))
                            return "ips: string[] expected";
                }
                if (message.virtualIps != null && message.hasOwnProperty("virtualIps")) {
                    if (!Array.isArray(message.virtualIps))
                        return "virtualIps: array expected";
                    for (var i = 0; i < message.virtualIps.length; ++i)
                        if (!$util.isString(message.virtualIps[i]))
                            return "virtualIps: string[] expected";
                }
                if (message.gateway != null && message.hasOwnProperty("gateway"))
                    if (!$util.isString(message.gateway))
                        return "gateway: string expected";
                if (message.netmask != null && message.hasOwnProperty("netmask"))
                    if (!$util.isString(message.netmask))
                        return "netmask: string expected";
                return null;
            };

            /**
             * Creates a NetworkInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.system.NetworkInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.system.NetworkInfo} NetworkInfo
             */
            NetworkInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.system.NetworkInfo)
                    return object;
                var message = new $root.lebai.system.NetworkInfo();
                if (object.ifname != null)
                    message.ifname = String(object.ifname);
                switch (object.kind) {
                default:
                    if (typeof object.kind === "number") {
                        message.kind = object.kind;
                        break;
                    }
                    break;
                case "UNKNOWN":
                case 0:
                    message.kind = 0;
                    break;
                case "LOOPBACK":
                case 1:
                    message.kind = 1;
                    break;
                case "ETHERNET":
                case 2:
                    message.kind = 2;
                    break;
                case "WIRELESS":
                case 3:
                    message.kind = 3;
                    break;
                case "CELLULAR":
                case 4:
                    message.kind = 4;
                    break;
                case "USB":
                case 5:
                    message.kind = 5;
                    break;
                case "DOCKER":
                case 11:
                    message.kind = 11;
                    break;
                }
                if (object.mac != null)
                    message.mac = String(object.mac);
                if (object.ips) {
                    if (!Array.isArray(object.ips))
                        throw TypeError(".lebai.system.NetworkInfo.ips: array expected");
                    message.ips = [];
                    for (var i = 0; i < object.ips.length; ++i)
                        message.ips[i] = String(object.ips[i]);
                }
                if (object.virtualIps) {
                    if (!Array.isArray(object.virtualIps))
                        throw TypeError(".lebai.system.NetworkInfo.virtualIps: array expected");
                    message.virtualIps = [];
                    for (var i = 0; i < object.virtualIps.length; ++i)
                        message.virtualIps[i] = String(object.virtualIps[i]);
                }
                if (object.gateway != null)
                    message.gateway = String(object.gateway);
                if (object.netmask != null)
                    message.netmask = String(object.netmask);
                return message;
            };

            /**
             * Creates a plain object from a NetworkInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.system.NetworkInfo
             * @static
             * @param {lebai.system.NetworkInfo} message NetworkInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NetworkInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.ips = [];
                    object.virtualIps = [];
                }
                if (options.defaults) {
                    object.ifname = "";
                    object.kind = options.enums === String ? "UNKNOWN" : 0;
                    object.mac = "";
                    object.gateway = "";
                    object.netmask = "";
                }
                if (message.ifname != null && message.hasOwnProperty("ifname"))
                    object.ifname = message.ifname;
                if (message.kind != null && message.hasOwnProperty("kind"))
                    object.kind = options.enums === String ? $root.lebai.system.NetworkKind[message.kind] === undefined ? message.kind : $root.lebai.system.NetworkKind[message.kind] : message.kind;
                if (message.mac != null && message.hasOwnProperty("mac"))
                    object.mac = message.mac;
                if (message.ips && message.ips.length) {
                    object.ips = [];
                    for (var j = 0; j < message.ips.length; ++j)
                        object.ips[j] = message.ips[j];
                }
                if (message.virtualIps && message.virtualIps.length) {
                    object.virtualIps = [];
                    for (var j = 0; j < message.virtualIps.length; ++j)
                        object.virtualIps[j] = message.virtualIps[j];
                }
                if (message.gateway != null && message.hasOwnProperty("gateway"))
                    object.gateway = message.gateway;
                if (message.netmask != null && message.hasOwnProperty("netmask"))
                    object.netmask = message.netmask;
                return object;
            };

            /**
             * Converts this NetworkInfo to JSON.
             * @function toJSON
             * @memberof lebai.system.NetworkInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NetworkInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for NetworkInfo
             * @function getTypeUrl
             * @memberof lebai.system.NetworkInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            NetworkInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.system.NetworkInfo";
            };

            return NetworkInfo;
        })();

        system.CpuInfo = (function() {

            /**
             * Properties of a CpuInfo.
             * @memberof lebai.system
             * @interface ICpuInfo
             * @property {string|null} [brand] CpuInfo brand
             * @property {number|null} [num] CpuInfo num
             * @property {number|Long|null} [frequency] CpuInfo frequency
             * @property {number|null} [temperature] CpuInfo temperature
             * @property {number|null} [critical] CpuInfo critical
             */

            /**
             * Constructs a new CpuInfo.
             * @memberof lebai.system
             * @classdesc Represents a CpuInfo.
             * @implements ICpuInfo
             * @constructor
             * @param {lebai.system.ICpuInfo=} [properties] Properties to set
             */
            function CpuInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CpuInfo brand.
             * @member {string} brand
             * @memberof lebai.system.CpuInfo
             * @instance
             */
            CpuInfo.prototype.brand = "";

            /**
             * CpuInfo num.
             * @member {number} num
             * @memberof lebai.system.CpuInfo
             * @instance
             */
            CpuInfo.prototype.num = 0;

            /**
             * CpuInfo frequency.
             * @member {number|Long} frequency
             * @memberof lebai.system.CpuInfo
             * @instance
             */
            CpuInfo.prototype.frequency = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * CpuInfo temperature.
             * @member {number} temperature
             * @memberof lebai.system.CpuInfo
             * @instance
             */
            CpuInfo.prototype.temperature = 0;

            /**
             * CpuInfo critical.
             * @member {number} critical
             * @memberof lebai.system.CpuInfo
             * @instance
             */
            CpuInfo.prototype.critical = 0;

            /**
             * Creates a new CpuInfo instance using the specified properties.
             * @function create
             * @memberof lebai.system.CpuInfo
             * @static
             * @param {lebai.system.ICpuInfo=} [properties] Properties to set
             * @returns {lebai.system.CpuInfo} CpuInfo instance
             */
            CpuInfo.create = function create(properties) {
                return new CpuInfo(properties);
            };

            /**
             * Encodes the specified CpuInfo message. Does not implicitly {@link lebai.system.CpuInfo.verify|verify} messages.
             * @function encode
             * @memberof lebai.system.CpuInfo
             * @static
             * @param {lebai.system.ICpuInfo} message CpuInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CpuInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.brand != null && Object.hasOwnProperty.call(message, "brand"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.brand);
                if (message.num != null && Object.hasOwnProperty.call(message, "num"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.num);
                if (message.frequency != null && Object.hasOwnProperty.call(message, "frequency"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.frequency);
                if (message.temperature != null && Object.hasOwnProperty.call(message, "temperature"))
                    writer.uint32(/* id 21, wireType 5 =*/173).float(message.temperature);
                if (message.critical != null && Object.hasOwnProperty.call(message, "critical"))
                    writer.uint32(/* id 22, wireType 5 =*/181).float(message.critical);
                return writer;
            };

            /**
             * Encodes the specified CpuInfo message, length delimited. Does not implicitly {@link lebai.system.CpuInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.system.CpuInfo
             * @static
             * @param {lebai.system.ICpuInfo} message CpuInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CpuInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CpuInfo message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.system.CpuInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.system.CpuInfo} CpuInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CpuInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.system.CpuInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.brand = reader.string();
                            break;
                        }
                    case 2: {
                            message.num = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.frequency = reader.uint64();
                            break;
                        }
                    case 21: {
                            message.temperature = reader.float();
                            break;
                        }
                    case 22: {
                            message.critical = reader.float();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CpuInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.system.CpuInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.system.CpuInfo} CpuInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CpuInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CpuInfo message.
             * @function verify
             * @memberof lebai.system.CpuInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CpuInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.brand != null && message.hasOwnProperty("brand"))
                    if (!$util.isString(message.brand))
                        return "brand: string expected";
                if (message.num != null && message.hasOwnProperty("num"))
                    if (!$util.isInteger(message.num))
                        return "num: integer expected";
                if (message.frequency != null && message.hasOwnProperty("frequency"))
                    if (!$util.isInteger(message.frequency) && !(message.frequency && $util.isInteger(message.frequency.low) && $util.isInteger(message.frequency.high)))
                        return "frequency: integer|Long expected";
                if (message.temperature != null && message.hasOwnProperty("temperature"))
                    if (typeof message.temperature !== "number")
                        return "temperature: number expected";
                if (message.critical != null && message.hasOwnProperty("critical"))
                    if (typeof message.critical !== "number")
                        return "critical: number expected";
                return null;
            };

            /**
             * Creates a CpuInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.system.CpuInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.system.CpuInfo} CpuInfo
             */
            CpuInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.system.CpuInfo)
                    return object;
                var message = new $root.lebai.system.CpuInfo();
                if (object.brand != null)
                    message.brand = String(object.brand);
                if (object.num != null)
                    message.num = object.num >>> 0;
                if (object.frequency != null)
                    if ($util.Long)
                        (message.frequency = $util.Long.fromValue(object.frequency)).unsigned = true;
                    else if (typeof object.frequency === "string")
                        message.frequency = parseInt(object.frequency, 10);
                    else if (typeof object.frequency === "number")
                        message.frequency = object.frequency;
                    else if (typeof object.frequency === "object")
                        message.frequency = new $util.LongBits(object.frequency.low >>> 0, object.frequency.high >>> 0).toNumber(true);
                if (object.temperature != null)
                    message.temperature = Number(object.temperature);
                if (object.critical != null)
                    message.critical = Number(object.critical);
                return message;
            };

            /**
             * Creates a plain object from a CpuInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.system.CpuInfo
             * @static
             * @param {lebai.system.CpuInfo} message CpuInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CpuInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.brand = "";
                    object.num = 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.frequency = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.frequency = options.longs === String ? "0" : 0;
                    object.temperature = 0;
                    object.critical = 0;
                }
                if (message.brand != null && message.hasOwnProperty("brand"))
                    object.brand = message.brand;
                if (message.num != null && message.hasOwnProperty("num"))
                    object.num = message.num;
                if (message.frequency != null && message.hasOwnProperty("frequency"))
                    if (typeof message.frequency === "number")
                        object.frequency = options.longs === String ? String(message.frequency) : message.frequency;
                    else
                        object.frequency = options.longs === String ? $util.Long.prototype.toString.call(message.frequency) : options.longs === Number ? new $util.LongBits(message.frequency.low >>> 0, message.frequency.high >>> 0).toNumber(true) : message.frequency;
                if (message.temperature != null && message.hasOwnProperty("temperature"))
                    object.temperature = options.json && !isFinite(message.temperature) ? String(message.temperature) : message.temperature;
                if (message.critical != null && message.hasOwnProperty("critical"))
                    object.critical = options.json && !isFinite(message.critical) ? String(message.critical) : message.critical;
                return object;
            };

            /**
             * Converts this CpuInfo to JSON.
             * @function toJSON
             * @memberof lebai.system.CpuInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CpuInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for CpuInfo
             * @function getTypeUrl
             * @memberof lebai.system.CpuInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            CpuInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.system.CpuInfo";
            };

            return CpuInfo;
        })();

        system.SystemInfo = (function() {

            /**
             * Properties of a SystemInfo.
             * @memberof lebai.system
             * @interface ISystemInfo
             * @property {string|null} [name] SystemInfo name
             * @property {string|null} [kernelVersion] SystemInfo kernelVersion
             * @property {string|null} [osVersion] SystemInfo osVersion
             * @property {string|null} [hostName] SystemInfo hostName
             * @property {lebai.system.IMemoryInfo|null} [memory] SystemInfo memory
             * @property {Array.<lebai.system.IDiskInfo>|null} [disks] SystemInfo disks
             * @property {Array.<lebai.system.INetworkInfo>|null} [networks] SystemInfo networks
             * @property {lebai.system.ICpuInfo|null} [cpu] SystemInfo cpu
             */

            /**
             * Constructs a new SystemInfo.
             * @memberof lebai.system
             * @classdesc Represents a SystemInfo.
             * @implements ISystemInfo
             * @constructor
             * @param {lebai.system.ISystemInfo=} [properties] Properties to set
             */
            function SystemInfo(properties) {
                this.disks = [];
                this.networks = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SystemInfo name.
             * @member {string} name
             * @memberof lebai.system.SystemInfo
             * @instance
             */
            SystemInfo.prototype.name = "";

            /**
             * SystemInfo kernelVersion.
             * @member {string} kernelVersion
             * @memberof lebai.system.SystemInfo
             * @instance
             */
            SystemInfo.prototype.kernelVersion = "";

            /**
             * SystemInfo osVersion.
             * @member {string} osVersion
             * @memberof lebai.system.SystemInfo
             * @instance
             */
            SystemInfo.prototype.osVersion = "";

            /**
             * SystemInfo hostName.
             * @member {string} hostName
             * @memberof lebai.system.SystemInfo
             * @instance
             */
            SystemInfo.prototype.hostName = "";

            /**
             * SystemInfo memory.
             * @member {lebai.system.IMemoryInfo|null|undefined} memory
             * @memberof lebai.system.SystemInfo
             * @instance
             */
            SystemInfo.prototype.memory = null;

            /**
             * SystemInfo disks.
             * @member {Array.<lebai.system.IDiskInfo>} disks
             * @memberof lebai.system.SystemInfo
             * @instance
             */
            SystemInfo.prototype.disks = $util.emptyArray;

            /**
             * SystemInfo networks.
             * @member {Array.<lebai.system.INetworkInfo>} networks
             * @memberof lebai.system.SystemInfo
             * @instance
             */
            SystemInfo.prototype.networks = $util.emptyArray;

            /**
             * SystemInfo cpu.
             * @member {lebai.system.ICpuInfo|null|undefined} cpu
             * @memberof lebai.system.SystemInfo
             * @instance
             */
            SystemInfo.prototype.cpu = null;

            /**
             * Creates a new SystemInfo instance using the specified properties.
             * @function create
             * @memberof lebai.system.SystemInfo
             * @static
             * @param {lebai.system.ISystemInfo=} [properties] Properties to set
             * @returns {lebai.system.SystemInfo} SystemInfo instance
             */
            SystemInfo.create = function create(properties) {
                return new SystemInfo(properties);
            };

            /**
             * Encodes the specified SystemInfo message. Does not implicitly {@link lebai.system.SystemInfo.verify|verify} messages.
             * @function encode
             * @memberof lebai.system.SystemInfo
             * @static
             * @param {lebai.system.ISystemInfo} message SystemInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SystemInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.kernelVersion != null && Object.hasOwnProperty.call(message, "kernelVersion"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.kernelVersion);
                if (message.osVersion != null && Object.hasOwnProperty.call(message, "osVersion"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.osVersion);
                if (message.hostName != null && Object.hasOwnProperty.call(message, "hostName"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.hostName);
                if (message.memory != null && Object.hasOwnProperty.call(message, "memory"))
                    $root.lebai.system.MemoryInfo.encode(message.memory, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                if (message.disks != null && message.disks.length)
                    for (var i = 0; i < message.disks.length; ++i)
                        $root.lebai.system.DiskInfo.encode(message.disks[i], writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
                if (message.networks != null && message.networks.length)
                    for (var i = 0; i < message.networks.length; ++i)
                        $root.lebai.system.NetworkInfo.encode(message.networks[i], writer.uint32(/* id 31, wireType 2 =*/250).fork()).ldelim();
                if (message.cpu != null && Object.hasOwnProperty.call(message, "cpu"))
                    $root.lebai.system.CpuInfo.encode(message.cpu, writer.uint32(/* id 41, wireType 2 =*/330).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified SystemInfo message, length delimited. Does not implicitly {@link lebai.system.SystemInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.system.SystemInfo
             * @static
             * @param {lebai.system.ISystemInfo} message SystemInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SystemInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SystemInfo message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.system.SystemInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.system.SystemInfo} SystemInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SystemInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.system.SystemInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.name = reader.string();
                            break;
                        }
                    case 2: {
                            message.kernelVersion = reader.string();
                            break;
                        }
                    case 3: {
                            message.osVersion = reader.string();
                            break;
                        }
                    case 4: {
                            message.hostName = reader.string();
                            break;
                        }
                    case 11: {
                            message.memory = $root.lebai.system.MemoryInfo.decode(reader, reader.uint32());
                            break;
                        }
                    case 21: {
                            if (!(message.disks && message.disks.length))
                                message.disks = [];
                            message.disks.push($root.lebai.system.DiskInfo.decode(reader, reader.uint32()));
                            break;
                        }
                    case 31: {
                            if (!(message.networks && message.networks.length))
                                message.networks = [];
                            message.networks.push($root.lebai.system.NetworkInfo.decode(reader, reader.uint32()));
                            break;
                        }
                    case 41: {
                            message.cpu = $root.lebai.system.CpuInfo.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SystemInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.system.SystemInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.system.SystemInfo} SystemInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SystemInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SystemInfo message.
             * @function verify
             * @memberof lebai.system.SystemInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SystemInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.kernelVersion != null && message.hasOwnProperty("kernelVersion"))
                    if (!$util.isString(message.kernelVersion))
                        return "kernelVersion: string expected";
                if (message.osVersion != null && message.hasOwnProperty("osVersion"))
                    if (!$util.isString(message.osVersion))
                        return "osVersion: string expected";
                if (message.hostName != null && message.hasOwnProperty("hostName"))
                    if (!$util.isString(message.hostName))
                        return "hostName: string expected";
                if (message.memory != null && message.hasOwnProperty("memory")) {
                    var error = $root.lebai.system.MemoryInfo.verify(message.memory);
                    if (error)
                        return "memory." + error;
                }
                if (message.disks != null && message.hasOwnProperty("disks")) {
                    if (!Array.isArray(message.disks))
                        return "disks: array expected";
                    for (var i = 0; i < message.disks.length; ++i) {
                        var error = $root.lebai.system.DiskInfo.verify(message.disks[i]);
                        if (error)
                            return "disks." + error;
                    }
                }
                if (message.networks != null && message.hasOwnProperty("networks")) {
                    if (!Array.isArray(message.networks))
                        return "networks: array expected";
                    for (var i = 0; i < message.networks.length; ++i) {
                        var error = $root.lebai.system.NetworkInfo.verify(message.networks[i]);
                        if (error)
                            return "networks." + error;
                    }
                }
                if (message.cpu != null && message.hasOwnProperty("cpu")) {
                    var error = $root.lebai.system.CpuInfo.verify(message.cpu);
                    if (error)
                        return "cpu." + error;
                }
                return null;
            };

            /**
             * Creates a SystemInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.system.SystemInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.system.SystemInfo} SystemInfo
             */
            SystemInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.system.SystemInfo)
                    return object;
                var message = new $root.lebai.system.SystemInfo();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.kernelVersion != null)
                    message.kernelVersion = String(object.kernelVersion);
                if (object.osVersion != null)
                    message.osVersion = String(object.osVersion);
                if (object.hostName != null)
                    message.hostName = String(object.hostName);
                if (object.memory != null) {
                    if (typeof object.memory !== "object")
                        throw TypeError(".lebai.system.SystemInfo.memory: object expected");
                    message.memory = $root.lebai.system.MemoryInfo.fromObject(object.memory);
                }
                if (object.disks) {
                    if (!Array.isArray(object.disks))
                        throw TypeError(".lebai.system.SystemInfo.disks: array expected");
                    message.disks = [];
                    for (var i = 0; i < object.disks.length; ++i) {
                        if (typeof object.disks[i] !== "object")
                            throw TypeError(".lebai.system.SystemInfo.disks: object expected");
                        message.disks[i] = $root.lebai.system.DiskInfo.fromObject(object.disks[i]);
                    }
                }
                if (object.networks) {
                    if (!Array.isArray(object.networks))
                        throw TypeError(".lebai.system.SystemInfo.networks: array expected");
                    message.networks = [];
                    for (var i = 0; i < object.networks.length; ++i) {
                        if (typeof object.networks[i] !== "object")
                            throw TypeError(".lebai.system.SystemInfo.networks: object expected");
                        message.networks[i] = $root.lebai.system.NetworkInfo.fromObject(object.networks[i]);
                    }
                }
                if (object.cpu != null) {
                    if (typeof object.cpu !== "object")
                        throw TypeError(".lebai.system.SystemInfo.cpu: object expected");
                    message.cpu = $root.lebai.system.CpuInfo.fromObject(object.cpu);
                }
                return message;
            };

            /**
             * Creates a plain object from a SystemInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.system.SystemInfo
             * @static
             * @param {lebai.system.SystemInfo} message SystemInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SystemInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.disks = [];
                    object.networks = [];
                }
                if (options.defaults) {
                    object.name = "";
                    object.kernelVersion = "";
                    object.osVersion = "";
                    object.hostName = "";
                    object.memory = null;
                    object.cpu = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.kernelVersion != null && message.hasOwnProperty("kernelVersion"))
                    object.kernelVersion = message.kernelVersion;
                if (message.osVersion != null && message.hasOwnProperty("osVersion"))
                    object.osVersion = message.osVersion;
                if (message.hostName != null && message.hasOwnProperty("hostName"))
                    object.hostName = message.hostName;
                if (message.memory != null && message.hasOwnProperty("memory"))
                    object.memory = $root.lebai.system.MemoryInfo.toObject(message.memory, options);
                if (message.disks && message.disks.length) {
                    object.disks = [];
                    for (var j = 0; j < message.disks.length; ++j)
                        object.disks[j] = $root.lebai.system.DiskInfo.toObject(message.disks[j], options);
                }
                if (message.networks && message.networks.length) {
                    object.networks = [];
                    for (var j = 0; j < message.networks.length; ++j)
                        object.networks[j] = $root.lebai.system.NetworkInfo.toObject(message.networks[j], options);
                }
                if (message.cpu != null && message.hasOwnProperty("cpu"))
                    object.cpu = $root.lebai.system.CpuInfo.toObject(message.cpu, options);
                return object;
            };

            /**
             * Converts this SystemInfo to JSON.
             * @function toJSON
             * @memberof lebai.system.SystemInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SystemInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SystemInfo
             * @function getTypeUrl
             * @memberof lebai.system.SystemInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SystemInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.system.SystemInfo";
            };

            return SystemInfo;
        })();

        system.SetVirtualIpRequest = (function() {

            /**
             * Properties of a SetVirtualIpRequest.
             * @memberof lebai.system
             * @interface ISetVirtualIpRequest
             * @property {string|null} [ifname] SetVirtualIpRequest ifname
             * @property {string|null} [ip] SetVirtualIpRequest ip
             */

            /**
             * Constructs a new SetVirtualIpRequest.
             * @memberof lebai.system
             * @classdesc Represents a SetVirtualIpRequest.
             * @implements ISetVirtualIpRequest
             * @constructor
             * @param {lebai.system.ISetVirtualIpRequest=} [properties] Properties to set
             */
            function SetVirtualIpRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SetVirtualIpRequest ifname.
             * @member {string} ifname
             * @memberof lebai.system.SetVirtualIpRequest
             * @instance
             */
            SetVirtualIpRequest.prototype.ifname = "";

            /**
             * SetVirtualIpRequest ip.
             * @member {string} ip
             * @memberof lebai.system.SetVirtualIpRequest
             * @instance
             */
            SetVirtualIpRequest.prototype.ip = "";

            /**
             * Creates a new SetVirtualIpRequest instance using the specified properties.
             * @function create
             * @memberof lebai.system.SetVirtualIpRequest
             * @static
             * @param {lebai.system.ISetVirtualIpRequest=} [properties] Properties to set
             * @returns {lebai.system.SetVirtualIpRequest} SetVirtualIpRequest instance
             */
            SetVirtualIpRequest.create = function create(properties) {
                return new SetVirtualIpRequest(properties);
            };

            /**
             * Encodes the specified SetVirtualIpRequest message. Does not implicitly {@link lebai.system.SetVirtualIpRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.system.SetVirtualIpRequest
             * @static
             * @param {lebai.system.ISetVirtualIpRequest} message SetVirtualIpRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetVirtualIpRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.ifname != null && Object.hasOwnProperty.call(message, "ifname"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.ifname);
                if (message.ip != null && Object.hasOwnProperty.call(message, "ip"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.ip);
                return writer;
            };

            /**
             * Encodes the specified SetVirtualIpRequest message, length delimited. Does not implicitly {@link lebai.system.SetVirtualIpRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.system.SetVirtualIpRequest
             * @static
             * @param {lebai.system.ISetVirtualIpRequest} message SetVirtualIpRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetVirtualIpRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetVirtualIpRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.system.SetVirtualIpRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.system.SetVirtualIpRequest} SetVirtualIpRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetVirtualIpRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.system.SetVirtualIpRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.ifname = reader.string();
                            break;
                        }
                    case 11: {
                            message.ip = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetVirtualIpRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.system.SetVirtualIpRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.system.SetVirtualIpRequest} SetVirtualIpRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetVirtualIpRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetVirtualIpRequest message.
             * @function verify
             * @memberof lebai.system.SetVirtualIpRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetVirtualIpRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.ifname != null && message.hasOwnProperty("ifname"))
                    if (!$util.isString(message.ifname))
                        return "ifname: string expected";
                if (message.ip != null && message.hasOwnProperty("ip"))
                    if (!$util.isString(message.ip))
                        return "ip: string expected";
                return null;
            };

            /**
             * Creates a SetVirtualIpRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.system.SetVirtualIpRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.system.SetVirtualIpRequest} SetVirtualIpRequest
             */
            SetVirtualIpRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.system.SetVirtualIpRequest)
                    return object;
                var message = new $root.lebai.system.SetVirtualIpRequest();
                if (object.ifname != null)
                    message.ifname = String(object.ifname);
                if (object.ip != null)
                    message.ip = String(object.ip);
                return message;
            };

            /**
             * Creates a plain object from a SetVirtualIpRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.system.SetVirtualIpRequest
             * @static
             * @param {lebai.system.SetVirtualIpRequest} message SetVirtualIpRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetVirtualIpRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.ifname = "";
                    object.ip = "";
                }
                if (message.ifname != null && message.hasOwnProperty("ifname"))
                    object.ifname = message.ifname;
                if (message.ip != null && message.hasOwnProperty("ip"))
                    object.ip = message.ip;
                return object;
            };

            /**
             * Converts this SetVirtualIpRequest to JSON.
             * @function toJSON
             * @memberof lebai.system.SetVirtualIpRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetVirtualIpRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetVirtualIpRequest
             * @function getTypeUrl
             * @memberof lebai.system.SetVirtualIpRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetVirtualIpRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.system.SetVirtualIpRequest";
            };

            return SetVirtualIpRequest;
        })();

        /**
         * BoxModel enum.
         * @name lebai.system.BoxModel
         * @enum {number}
         * @property {number} LM3=0 LM3 value
         * @property {number} LA3=10 LA3 value
         */
        system.BoxModel = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "LM3"] = 0;
            values[valuesById[10] = "LA3"] = 10;
            return values;
        })();

        /**
         * ArmModel enum.
         * @name lebai.system.ArmModel
         * @enum {number}
         * @property {number} J6M1=0 J6M1 value
         * @property {number} J6L1=1 J6L1 value
         * @property {number} J5L1=11 J5L1 value
         */
        system.ArmModel = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "J6M1"] = 0;
            values[valuesById[1] = "J6L1"] = 1;
            values[valuesById[11] = "J5L1"] = 11;
            return values;
        })();

        system.RobotInfo = (function() {

            /**
             * Properties of a RobotInfo.
             * @memberof lebai.system
             * @interface IRobotInfo
             * @property {string|null} [name] RobotInfo name
             * @property {string|null} [mac] RobotInfo mac
             * @property {lebai.system.BoxModel|null} [boxModel] RobotInfo boxModel
             * @property {string|null} [boxSn] RobotInfo boxSn
             * @property {lebai.system.ArmModel|null} [armModel] RobotInfo armModel
             * @property {string|null} [armSn] RobotInfo armSn
             */

            /**
             * Constructs a new RobotInfo.
             * @memberof lebai.system
             * @classdesc Represents a RobotInfo.
             * @implements IRobotInfo
             * @constructor
             * @param {lebai.system.IRobotInfo=} [properties] Properties to set
             */
            function RobotInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RobotInfo name.
             * @member {string} name
             * @memberof lebai.system.RobotInfo
             * @instance
             */
            RobotInfo.prototype.name = "";

            /**
             * RobotInfo mac.
             * @member {string} mac
             * @memberof lebai.system.RobotInfo
             * @instance
             */
            RobotInfo.prototype.mac = "";

            /**
             * RobotInfo boxModel.
             * @member {lebai.system.BoxModel} boxModel
             * @memberof lebai.system.RobotInfo
             * @instance
             */
            RobotInfo.prototype.boxModel = 0;

            /**
             * RobotInfo boxSn.
             * @member {string} boxSn
             * @memberof lebai.system.RobotInfo
             * @instance
             */
            RobotInfo.prototype.boxSn = "";

            /**
             * RobotInfo armModel.
             * @member {lebai.system.ArmModel} armModel
             * @memberof lebai.system.RobotInfo
             * @instance
             */
            RobotInfo.prototype.armModel = 0;

            /**
             * RobotInfo armSn.
             * @member {string} armSn
             * @memberof lebai.system.RobotInfo
             * @instance
             */
            RobotInfo.prototype.armSn = "";

            /**
             * Creates a new RobotInfo instance using the specified properties.
             * @function create
             * @memberof lebai.system.RobotInfo
             * @static
             * @param {lebai.system.IRobotInfo=} [properties] Properties to set
             * @returns {lebai.system.RobotInfo} RobotInfo instance
             */
            RobotInfo.create = function create(properties) {
                return new RobotInfo(properties);
            };

            /**
             * Encodes the specified RobotInfo message. Does not implicitly {@link lebai.system.RobotInfo.verify|verify} messages.
             * @function encode
             * @memberof lebai.system.RobotInfo
             * @static
             * @param {lebai.system.IRobotInfo} message RobotInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RobotInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.mac != null && Object.hasOwnProperty.call(message, "mac"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.mac);
                if (message.boxModel != null && Object.hasOwnProperty.call(message, "boxModel"))
                    writer.uint32(/* id 21, wireType 0 =*/168).int32(message.boxModel);
                if (message.boxSn != null && Object.hasOwnProperty.call(message, "boxSn"))
                    writer.uint32(/* id 22, wireType 2 =*/178).string(message.boxSn);
                if (message.armModel != null && Object.hasOwnProperty.call(message, "armModel"))
                    writer.uint32(/* id 31, wireType 0 =*/248).int32(message.armModel);
                if (message.armSn != null && Object.hasOwnProperty.call(message, "armSn"))
                    writer.uint32(/* id 32, wireType 2 =*/258).string(message.armSn);
                return writer;
            };

            /**
             * Encodes the specified RobotInfo message, length delimited. Does not implicitly {@link lebai.system.RobotInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.system.RobotInfo
             * @static
             * @param {lebai.system.IRobotInfo} message RobotInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RobotInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RobotInfo message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.system.RobotInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.system.RobotInfo} RobotInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RobotInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.system.RobotInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.name = reader.string();
                            break;
                        }
                    case 3: {
                            message.mac = reader.string();
                            break;
                        }
                    case 21: {
                            message.boxModel = reader.int32();
                            break;
                        }
                    case 22: {
                            message.boxSn = reader.string();
                            break;
                        }
                    case 31: {
                            message.armModel = reader.int32();
                            break;
                        }
                    case 32: {
                            message.armSn = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RobotInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.system.RobotInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.system.RobotInfo} RobotInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RobotInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RobotInfo message.
             * @function verify
             * @memberof lebai.system.RobotInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RobotInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.mac != null && message.hasOwnProperty("mac"))
                    if (!$util.isString(message.mac))
                        return "mac: string expected";
                if (message.boxModel != null && message.hasOwnProperty("boxModel"))
                    switch (message.boxModel) {
                    default:
                        return "boxModel: enum value expected";
                    case 0:
                    case 10:
                        break;
                    }
                if (message.boxSn != null && message.hasOwnProperty("boxSn"))
                    if (!$util.isString(message.boxSn))
                        return "boxSn: string expected";
                if (message.armModel != null && message.hasOwnProperty("armModel"))
                    switch (message.armModel) {
                    default:
                        return "armModel: enum value expected";
                    case 0:
                    case 1:
                    case 11:
                        break;
                    }
                if (message.armSn != null && message.hasOwnProperty("armSn"))
                    if (!$util.isString(message.armSn))
                        return "armSn: string expected";
                return null;
            };

            /**
             * Creates a RobotInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.system.RobotInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.system.RobotInfo} RobotInfo
             */
            RobotInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.system.RobotInfo)
                    return object;
                var message = new $root.lebai.system.RobotInfo();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.mac != null)
                    message.mac = String(object.mac);
                switch (object.boxModel) {
                default:
                    if (typeof object.boxModel === "number") {
                        message.boxModel = object.boxModel;
                        break;
                    }
                    break;
                case "LM3":
                case 0:
                    message.boxModel = 0;
                    break;
                case "LA3":
                case 10:
                    message.boxModel = 10;
                    break;
                }
                if (object.boxSn != null)
                    message.boxSn = String(object.boxSn);
                switch (object.armModel) {
                default:
                    if (typeof object.armModel === "number") {
                        message.armModel = object.armModel;
                        break;
                    }
                    break;
                case "J6M1":
                case 0:
                    message.armModel = 0;
                    break;
                case "J6L1":
                case 1:
                    message.armModel = 1;
                    break;
                case "J5L1":
                case 11:
                    message.armModel = 11;
                    break;
                }
                if (object.armSn != null)
                    message.armSn = String(object.armSn);
                return message;
            };

            /**
             * Creates a plain object from a RobotInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.system.RobotInfo
             * @static
             * @param {lebai.system.RobotInfo} message RobotInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RobotInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.mac = "";
                    object.boxModel = options.enums === String ? "LM3" : 0;
                    object.boxSn = "";
                    object.armModel = options.enums === String ? "J6M1" : 0;
                    object.armSn = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.mac != null && message.hasOwnProperty("mac"))
                    object.mac = message.mac;
                if (message.boxModel != null && message.hasOwnProperty("boxModel"))
                    object.boxModel = options.enums === String ? $root.lebai.system.BoxModel[message.boxModel] === undefined ? message.boxModel : $root.lebai.system.BoxModel[message.boxModel] : message.boxModel;
                if (message.boxSn != null && message.hasOwnProperty("boxSn"))
                    object.boxSn = message.boxSn;
                if (message.armModel != null && message.hasOwnProperty("armModel"))
                    object.armModel = options.enums === String ? $root.lebai.system.ArmModel[message.armModel] === undefined ? message.armModel : $root.lebai.system.ArmModel[message.armModel] : message.armModel;
                if (message.armSn != null && message.hasOwnProperty("armSn"))
                    object.armSn = message.armSn;
                return object;
            };

            /**
             * Converts this RobotInfo to JSON.
             * @function toJSON
             * @memberof lebai.system.RobotInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RobotInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for RobotInfo
             * @function getTypeUrl
             * @memberof lebai.system.RobotInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            RobotInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.system.RobotInfo";
            };

            return RobotInfo;
        })();

        system.DeviceInfo = (function() {

            /**
             * Properties of a DeviceInfo.
             * @memberof lebai.system
             * @interface IDeviceInfo
             * @property {boolean|null} [invalid] DeviceInfo invalid
             * @property {string|null} [sn] DeviceInfo sn
             * @property {string|null} [version] DeviceInfo version
             * @property {lebai.hardware.FirmwarePartition|null} [partition] DeviceInfo partition
             * @property {number|null} [diNum] DeviceInfo diNum
             * @property {number|null} [doNum] DeviceInfo doNum
             * @property {number|null} [dioNum] DeviceInfo dioNum
             * @property {number|null} [aiNum] DeviceInfo aiNum
             * @property {number|null} [aoNum] DeviceInfo aoNum
             */

            /**
             * Constructs a new DeviceInfo.
             * @memberof lebai.system
             * @classdesc Represents a DeviceInfo.
             * @implements IDeviceInfo
             * @constructor
             * @param {lebai.system.IDeviceInfo=} [properties] Properties to set
             */
            function DeviceInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DeviceInfo invalid.
             * @member {boolean} invalid
             * @memberof lebai.system.DeviceInfo
             * @instance
             */
            DeviceInfo.prototype.invalid = false;

            /**
             * DeviceInfo sn.
             * @member {string} sn
             * @memberof lebai.system.DeviceInfo
             * @instance
             */
            DeviceInfo.prototype.sn = "";

            /**
             * DeviceInfo version.
             * @member {string} version
             * @memberof lebai.system.DeviceInfo
             * @instance
             */
            DeviceInfo.prototype.version = "";

            /**
             * DeviceInfo partition.
             * @member {lebai.hardware.FirmwarePartition} partition
             * @memberof lebai.system.DeviceInfo
             * @instance
             */
            DeviceInfo.prototype.partition = 0;

            /**
             * DeviceInfo diNum.
             * @member {number} diNum
             * @memberof lebai.system.DeviceInfo
             * @instance
             */
            DeviceInfo.prototype.diNum = 0;

            /**
             * DeviceInfo doNum.
             * @member {number} doNum
             * @memberof lebai.system.DeviceInfo
             * @instance
             */
            DeviceInfo.prototype.doNum = 0;

            /**
             * DeviceInfo dioNum.
             * @member {number} dioNum
             * @memberof lebai.system.DeviceInfo
             * @instance
             */
            DeviceInfo.prototype.dioNum = 0;

            /**
             * DeviceInfo aiNum.
             * @member {number} aiNum
             * @memberof lebai.system.DeviceInfo
             * @instance
             */
            DeviceInfo.prototype.aiNum = 0;

            /**
             * DeviceInfo aoNum.
             * @member {number} aoNum
             * @memberof lebai.system.DeviceInfo
             * @instance
             */
            DeviceInfo.prototype.aoNum = 0;

            /**
             * Creates a new DeviceInfo instance using the specified properties.
             * @function create
             * @memberof lebai.system.DeviceInfo
             * @static
             * @param {lebai.system.IDeviceInfo=} [properties] Properties to set
             * @returns {lebai.system.DeviceInfo} DeviceInfo instance
             */
            DeviceInfo.create = function create(properties) {
                return new DeviceInfo(properties);
            };

            /**
             * Encodes the specified DeviceInfo message. Does not implicitly {@link lebai.system.DeviceInfo.verify|verify} messages.
             * @function encode
             * @memberof lebai.system.DeviceInfo
             * @static
             * @param {lebai.system.IDeviceInfo} message DeviceInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeviceInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.invalid != null && Object.hasOwnProperty.call(message, "invalid"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.invalid);
                if (message.sn != null && Object.hasOwnProperty.call(message, "sn"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.sn);
                if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                    writer.uint32(/* id 12, wireType 2 =*/98).string(message.version);
                if (message.partition != null && Object.hasOwnProperty.call(message, "partition"))
                    writer.uint32(/* id 13, wireType 0 =*/104).int32(message.partition);
                if (message.diNum != null && Object.hasOwnProperty.call(message, "diNum"))
                    writer.uint32(/* id 21, wireType 0 =*/168).uint32(message.diNum);
                if (message.doNum != null && Object.hasOwnProperty.call(message, "doNum"))
                    writer.uint32(/* id 22, wireType 0 =*/176).uint32(message.doNum);
                if (message.dioNum != null && Object.hasOwnProperty.call(message, "dioNum"))
                    writer.uint32(/* id 23, wireType 0 =*/184).uint32(message.dioNum);
                if (message.aiNum != null && Object.hasOwnProperty.call(message, "aiNum"))
                    writer.uint32(/* id 26, wireType 0 =*/208).uint32(message.aiNum);
                if (message.aoNum != null && Object.hasOwnProperty.call(message, "aoNum"))
                    writer.uint32(/* id 27, wireType 0 =*/216).uint32(message.aoNum);
                return writer;
            };

            /**
             * Encodes the specified DeviceInfo message, length delimited. Does not implicitly {@link lebai.system.DeviceInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.system.DeviceInfo
             * @static
             * @param {lebai.system.IDeviceInfo} message DeviceInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeviceInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeviceInfo message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.system.DeviceInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.system.DeviceInfo} DeviceInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeviceInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.system.DeviceInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.invalid = reader.bool();
                            break;
                        }
                    case 11: {
                            message.sn = reader.string();
                            break;
                        }
                    case 12: {
                            message.version = reader.string();
                            break;
                        }
                    case 13: {
                            message.partition = reader.int32();
                            break;
                        }
                    case 21: {
                            message.diNum = reader.uint32();
                            break;
                        }
                    case 22: {
                            message.doNum = reader.uint32();
                            break;
                        }
                    case 23: {
                            message.dioNum = reader.uint32();
                            break;
                        }
                    case 26: {
                            message.aiNum = reader.uint32();
                            break;
                        }
                    case 27: {
                            message.aoNum = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeviceInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.system.DeviceInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.system.DeviceInfo} DeviceInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeviceInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeviceInfo message.
             * @function verify
             * @memberof lebai.system.DeviceInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeviceInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.invalid != null && message.hasOwnProperty("invalid"))
                    if (typeof message.invalid !== "boolean")
                        return "invalid: boolean expected";
                if (message.sn != null && message.hasOwnProperty("sn"))
                    if (!$util.isString(message.sn))
                        return "sn: string expected";
                if (message.version != null && message.hasOwnProperty("version"))
                    if (!$util.isString(message.version))
                        return "version: string expected";
                if (message.partition != null && message.hasOwnProperty("partition"))
                    switch (message.partition) {
                    default:
                        return "partition: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.diNum != null && message.hasOwnProperty("diNum"))
                    if (!$util.isInteger(message.diNum))
                        return "diNum: integer expected";
                if (message.doNum != null && message.hasOwnProperty("doNum"))
                    if (!$util.isInteger(message.doNum))
                        return "doNum: integer expected";
                if (message.dioNum != null && message.hasOwnProperty("dioNum"))
                    if (!$util.isInteger(message.dioNum))
                        return "dioNum: integer expected";
                if (message.aiNum != null && message.hasOwnProperty("aiNum"))
                    if (!$util.isInteger(message.aiNum))
                        return "aiNum: integer expected";
                if (message.aoNum != null && message.hasOwnProperty("aoNum"))
                    if (!$util.isInteger(message.aoNum))
                        return "aoNum: integer expected";
                return null;
            };

            /**
             * Creates a DeviceInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.system.DeviceInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.system.DeviceInfo} DeviceInfo
             */
            DeviceInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.system.DeviceInfo)
                    return object;
                var message = new $root.lebai.system.DeviceInfo();
                if (object.invalid != null)
                    message.invalid = Boolean(object.invalid);
                if (object.sn != null)
                    message.sn = String(object.sn);
                if (object.version != null)
                    message.version = String(object.version);
                switch (object.partition) {
                default:
                    if (typeof object.partition === "number") {
                        message.partition = object.partition;
                        break;
                    }
                    break;
                case "A":
                case 0:
                    message.partition = 0;
                    break;
                case "B":
                case 1:
                    message.partition = 1;
                    break;
                case "C":
                case 2:
                    message.partition = 2;
                    break;
                case "UNKNOWN":
                case 3:
                    message.partition = 3;
                    break;
                }
                if (object.diNum != null)
                    message.diNum = object.diNum >>> 0;
                if (object.doNum != null)
                    message.doNum = object.doNum >>> 0;
                if (object.dioNum != null)
                    message.dioNum = object.dioNum >>> 0;
                if (object.aiNum != null)
                    message.aiNum = object.aiNum >>> 0;
                if (object.aoNum != null)
                    message.aoNum = object.aoNum >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a DeviceInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.system.DeviceInfo
             * @static
             * @param {lebai.system.DeviceInfo} message DeviceInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeviceInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.invalid = false;
                    object.sn = "";
                    object.version = "";
                    object.partition = options.enums === String ? "A" : 0;
                    object.diNum = 0;
                    object.doNum = 0;
                    object.dioNum = 0;
                    object.aiNum = 0;
                    object.aoNum = 0;
                }
                if (message.invalid != null && message.hasOwnProperty("invalid"))
                    object.invalid = message.invalid;
                if (message.sn != null && message.hasOwnProperty("sn"))
                    object.sn = message.sn;
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = message.version;
                if (message.partition != null && message.hasOwnProperty("partition"))
                    object.partition = options.enums === String ? $root.lebai.hardware.FirmwarePartition[message.partition] === undefined ? message.partition : $root.lebai.hardware.FirmwarePartition[message.partition] : message.partition;
                if (message.diNum != null && message.hasOwnProperty("diNum"))
                    object.diNum = message.diNum;
                if (message.doNum != null && message.hasOwnProperty("doNum"))
                    object.doNum = message.doNum;
                if (message.dioNum != null && message.hasOwnProperty("dioNum"))
                    object.dioNum = message.dioNum;
                if (message.aiNum != null && message.hasOwnProperty("aiNum"))
                    object.aiNum = message.aiNum;
                if (message.aoNum != null && message.hasOwnProperty("aoNum"))
                    object.aoNum = message.aoNum;
                return object;
            };

            /**
             * Converts this DeviceInfo to JSON.
             * @function toJSON
             * @memberof lebai.system.DeviceInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeviceInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DeviceInfo
             * @function getTypeUrl
             * @memberof lebai.system.DeviceInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DeviceInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.system.DeviceInfo";
            };

            return DeviceInfo;
        })();

        system.HardwareInfo = (function() {

            /**
             * Properties of a HardwareInfo.
             * @memberof lebai.system
             * @interface IHardwareInfo
             * @property {lebai.system.IDeviceInfo|null} [comboard] HardwareInfo comboard
             * @property {Array.<lebai.system.IDeviceInfo>|null} [joints] HardwareInfo joints
             * @property {lebai.system.IDeviceInfo|null} [flange] HardwareInfo flange
             * @property {lebai.system.IDeviceInfo|null} [led] HardwareInfo led
             * @property {lebai.system.IDeviceInfo|null} [extraIo] HardwareInfo extraIo
             */

            /**
             * Constructs a new HardwareInfo.
             * @memberof lebai.system
             * @classdesc Represents a HardwareInfo.
             * @implements IHardwareInfo
             * @constructor
             * @param {lebai.system.IHardwareInfo=} [properties] Properties to set
             */
            function HardwareInfo(properties) {
                this.joints = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * HardwareInfo comboard.
             * @member {lebai.system.IDeviceInfo|null|undefined} comboard
             * @memberof lebai.system.HardwareInfo
             * @instance
             */
            HardwareInfo.prototype.comboard = null;

            /**
             * HardwareInfo joints.
             * @member {Array.<lebai.system.IDeviceInfo>} joints
             * @memberof lebai.system.HardwareInfo
             * @instance
             */
            HardwareInfo.prototype.joints = $util.emptyArray;

            /**
             * HardwareInfo flange.
             * @member {lebai.system.IDeviceInfo|null|undefined} flange
             * @memberof lebai.system.HardwareInfo
             * @instance
             */
            HardwareInfo.prototype.flange = null;

            /**
             * HardwareInfo led.
             * @member {lebai.system.IDeviceInfo|null|undefined} led
             * @memberof lebai.system.HardwareInfo
             * @instance
             */
            HardwareInfo.prototype.led = null;

            /**
             * HardwareInfo extraIo.
             * @member {lebai.system.IDeviceInfo|null|undefined} extraIo
             * @memberof lebai.system.HardwareInfo
             * @instance
             */
            HardwareInfo.prototype.extraIo = null;

            /**
             * Creates a new HardwareInfo instance using the specified properties.
             * @function create
             * @memberof lebai.system.HardwareInfo
             * @static
             * @param {lebai.system.IHardwareInfo=} [properties] Properties to set
             * @returns {lebai.system.HardwareInfo} HardwareInfo instance
             */
            HardwareInfo.create = function create(properties) {
                return new HardwareInfo(properties);
            };

            /**
             * Encodes the specified HardwareInfo message. Does not implicitly {@link lebai.system.HardwareInfo.verify|verify} messages.
             * @function encode
             * @memberof lebai.system.HardwareInfo
             * @static
             * @param {lebai.system.IHardwareInfo} message HardwareInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HardwareInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.comboard != null && Object.hasOwnProperty.call(message, "comboard"))
                    $root.lebai.system.DeviceInfo.encode(message.comboard, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.joints != null && message.joints.length)
                    for (var i = 0; i < message.joints.length; ++i)
                        $root.lebai.system.DeviceInfo.encode(message.joints[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.flange != null && Object.hasOwnProperty.call(message, "flange"))
                    $root.lebai.system.DeviceInfo.encode(message.flange, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.led != null && Object.hasOwnProperty.call(message, "led"))
                    $root.lebai.system.DeviceInfo.encode(message.led, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.extraIo != null && Object.hasOwnProperty.call(message, "extraIo"))
                    $root.lebai.system.DeviceInfo.encode(message.extraIo, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified HardwareInfo message, length delimited. Does not implicitly {@link lebai.system.HardwareInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.system.HardwareInfo
             * @static
             * @param {lebai.system.IHardwareInfo} message HardwareInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HardwareInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a HardwareInfo message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.system.HardwareInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.system.HardwareInfo} HardwareInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HardwareInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.system.HardwareInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.comboard = $root.lebai.system.DeviceInfo.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            if (!(message.joints && message.joints.length))
                                message.joints = [];
                            message.joints.push($root.lebai.system.DeviceInfo.decode(reader, reader.uint32()));
                            break;
                        }
                    case 3: {
                            message.flange = $root.lebai.system.DeviceInfo.decode(reader, reader.uint32());
                            break;
                        }
                    case 4: {
                            message.led = $root.lebai.system.DeviceInfo.decode(reader, reader.uint32());
                            break;
                        }
                    case 11: {
                            message.extraIo = $root.lebai.system.DeviceInfo.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a HardwareInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.system.HardwareInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.system.HardwareInfo} HardwareInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HardwareInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a HardwareInfo message.
             * @function verify
             * @memberof lebai.system.HardwareInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            HardwareInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.comboard != null && message.hasOwnProperty("comboard")) {
                    var error = $root.lebai.system.DeviceInfo.verify(message.comboard);
                    if (error)
                        return "comboard." + error;
                }
                if (message.joints != null && message.hasOwnProperty("joints")) {
                    if (!Array.isArray(message.joints))
                        return "joints: array expected";
                    for (var i = 0; i < message.joints.length; ++i) {
                        var error = $root.lebai.system.DeviceInfo.verify(message.joints[i]);
                        if (error)
                            return "joints." + error;
                    }
                }
                if (message.flange != null && message.hasOwnProperty("flange")) {
                    var error = $root.lebai.system.DeviceInfo.verify(message.flange);
                    if (error)
                        return "flange." + error;
                }
                if (message.led != null && message.hasOwnProperty("led")) {
                    var error = $root.lebai.system.DeviceInfo.verify(message.led);
                    if (error)
                        return "led." + error;
                }
                if (message.extraIo != null && message.hasOwnProperty("extraIo")) {
                    var error = $root.lebai.system.DeviceInfo.verify(message.extraIo);
                    if (error)
                        return "extraIo." + error;
                }
                return null;
            };

            /**
             * Creates a HardwareInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.system.HardwareInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.system.HardwareInfo} HardwareInfo
             */
            HardwareInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.system.HardwareInfo)
                    return object;
                var message = new $root.lebai.system.HardwareInfo();
                if (object.comboard != null) {
                    if (typeof object.comboard !== "object")
                        throw TypeError(".lebai.system.HardwareInfo.comboard: object expected");
                    message.comboard = $root.lebai.system.DeviceInfo.fromObject(object.comboard);
                }
                if (object.joints) {
                    if (!Array.isArray(object.joints))
                        throw TypeError(".lebai.system.HardwareInfo.joints: array expected");
                    message.joints = [];
                    for (var i = 0; i < object.joints.length; ++i) {
                        if (typeof object.joints[i] !== "object")
                            throw TypeError(".lebai.system.HardwareInfo.joints: object expected");
                        message.joints[i] = $root.lebai.system.DeviceInfo.fromObject(object.joints[i]);
                    }
                }
                if (object.flange != null) {
                    if (typeof object.flange !== "object")
                        throw TypeError(".lebai.system.HardwareInfo.flange: object expected");
                    message.flange = $root.lebai.system.DeviceInfo.fromObject(object.flange);
                }
                if (object.led != null) {
                    if (typeof object.led !== "object")
                        throw TypeError(".lebai.system.HardwareInfo.led: object expected");
                    message.led = $root.lebai.system.DeviceInfo.fromObject(object.led);
                }
                if (object.extraIo != null) {
                    if (typeof object.extraIo !== "object")
                        throw TypeError(".lebai.system.HardwareInfo.extraIo: object expected");
                    message.extraIo = $root.lebai.system.DeviceInfo.fromObject(object.extraIo);
                }
                return message;
            };

            /**
             * Creates a plain object from a HardwareInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.system.HardwareInfo
             * @static
             * @param {lebai.system.HardwareInfo} message HardwareInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            HardwareInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.joints = [];
                if (options.defaults) {
                    object.comboard = null;
                    object.flange = null;
                    object.led = null;
                    object.extraIo = null;
                }
                if (message.comboard != null && message.hasOwnProperty("comboard"))
                    object.comboard = $root.lebai.system.DeviceInfo.toObject(message.comboard, options);
                if (message.joints && message.joints.length) {
                    object.joints = [];
                    for (var j = 0; j < message.joints.length; ++j)
                        object.joints[j] = $root.lebai.system.DeviceInfo.toObject(message.joints[j], options);
                }
                if (message.flange != null && message.hasOwnProperty("flange"))
                    object.flange = $root.lebai.system.DeviceInfo.toObject(message.flange, options);
                if (message.led != null && message.hasOwnProperty("led"))
                    object.led = $root.lebai.system.DeviceInfo.toObject(message.led, options);
                if (message.extraIo != null && message.hasOwnProperty("extraIo"))
                    object.extraIo = $root.lebai.system.DeviceInfo.toObject(message.extraIo, options);
                return object;
            };

            /**
             * Converts this HardwareInfo to JSON.
             * @function toJSON
             * @memberof lebai.system.HardwareInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            HardwareInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for HardwareInfo
             * @function getTypeUrl
             * @memberof lebai.system.HardwareInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            HardwareInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.system.HardwareInfo";
            };

            return HardwareInfo;
        })();

        system.SoftwareItemInfo = (function() {

            /**
             * Properties of a SoftwareItemInfo.
             * @memberof lebai.system
             * @interface ISoftwareItemInfo
             * @property {string|null} [version] SoftwareItemInfo version
             * @property {string|null} [branch] SoftwareItemInfo branch
             */

            /**
             * Constructs a new SoftwareItemInfo.
             * @memberof lebai.system
             * @classdesc Represents a SoftwareItemInfo.
             * @implements ISoftwareItemInfo
             * @constructor
             * @param {lebai.system.ISoftwareItemInfo=} [properties] Properties to set
             */
            function SoftwareItemInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SoftwareItemInfo version.
             * @member {string} version
             * @memberof lebai.system.SoftwareItemInfo
             * @instance
             */
            SoftwareItemInfo.prototype.version = "";

            /**
             * SoftwareItemInfo branch.
             * @member {string} branch
             * @memberof lebai.system.SoftwareItemInfo
             * @instance
             */
            SoftwareItemInfo.prototype.branch = "";

            /**
             * Creates a new SoftwareItemInfo instance using the specified properties.
             * @function create
             * @memberof lebai.system.SoftwareItemInfo
             * @static
             * @param {lebai.system.ISoftwareItemInfo=} [properties] Properties to set
             * @returns {lebai.system.SoftwareItemInfo} SoftwareItemInfo instance
             */
            SoftwareItemInfo.create = function create(properties) {
                return new SoftwareItemInfo(properties);
            };

            /**
             * Encodes the specified SoftwareItemInfo message. Does not implicitly {@link lebai.system.SoftwareItemInfo.verify|verify} messages.
             * @function encode
             * @memberof lebai.system.SoftwareItemInfo
             * @static
             * @param {lebai.system.ISoftwareItemInfo} message SoftwareItemInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SoftwareItemInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.version);
                if (message.branch != null && Object.hasOwnProperty.call(message, "branch"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.branch);
                return writer;
            };

            /**
             * Encodes the specified SoftwareItemInfo message, length delimited. Does not implicitly {@link lebai.system.SoftwareItemInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.system.SoftwareItemInfo
             * @static
             * @param {lebai.system.ISoftwareItemInfo} message SoftwareItemInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SoftwareItemInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SoftwareItemInfo message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.system.SoftwareItemInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.system.SoftwareItemInfo} SoftwareItemInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SoftwareItemInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.system.SoftwareItemInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.version = reader.string();
                            break;
                        }
                    case 2: {
                            message.branch = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SoftwareItemInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.system.SoftwareItemInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.system.SoftwareItemInfo} SoftwareItemInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SoftwareItemInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SoftwareItemInfo message.
             * @function verify
             * @memberof lebai.system.SoftwareItemInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SoftwareItemInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.version != null && message.hasOwnProperty("version"))
                    if (!$util.isString(message.version))
                        return "version: string expected";
                if (message.branch != null && message.hasOwnProperty("branch"))
                    if (!$util.isString(message.branch))
                        return "branch: string expected";
                return null;
            };

            /**
             * Creates a SoftwareItemInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.system.SoftwareItemInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.system.SoftwareItemInfo} SoftwareItemInfo
             */
            SoftwareItemInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.system.SoftwareItemInfo)
                    return object;
                var message = new $root.lebai.system.SoftwareItemInfo();
                if (object.version != null)
                    message.version = String(object.version);
                if (object.branch != null)
                    message.branch = String(object.branch);
                return message;
            };

            /**
             * Creates a plain object from a SoftwareItemInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.system.SoftwareItemInfo
             * @static
             * @param {lebai.system.SoftwareItemInfo} message SoftwareItemInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SoftwareItemInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.version = "";
                    object.branch = "";
                }
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = message.version;
                if (message.branch != null && message.hasOwnProperty("branch"))
                    object.branch = message.branch;
                return object;
            };

            /**
             * Converts this SoftwareItemInfo to JSON.
             * @function toJSON
             * @memberof lebai.system.SoftwareItemInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SoftwareItemInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SoftwareItemInfo
             * @function getTypeUrl
             * @memberof lebai.system.SoftwareItemInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SoftwareItemInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.system.SoftwareItemInfo";
            };

            return SoftwareItemInfo;
        })();

        system.SoftwareInfo = (function() {

            /**
             * Properties of a SoftwareInfo.
             * @memberof lebai.system
             * @interface ISoftwareInfo
             * @property {Object.<string,lebai.system.ISoftwareItemInfo>|null} [software] SoftwareInfo software
             */

            /**
             * Constructs a new SoftwareInfo.
             * @memberof lebai.system
             * @classdesc Represents a SoftwareInfo.
             * @implements ISoftwareInfo
             * @constructor
             * @param {lebai.system.ISoftwareInfo=} [properties] Properties to set
             */
            function SoftwareInfo(properties) {
                this.software = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SoftwareInfo software.
             * @member {Object.<string,lebai.system.ISoftwareItemInfo>} software
             * @memberof lebai.system.SoftwareInfo
             * @instance
             */
            SoftwareInfo.prototype.software = $util.emptyObject;

            /**
             * Creates a new SoftwareInfo instance using the specified properties.
             * @function create
             * @memberof lebai.system.SoftwareInfo
             * @static
             * @param {lebai.system.ISoftwareInfo=} [properties] Properties to set
             * @returns {lebai.system.SoftwareInfo} SoftwareInfo instance
             */
            SoftwareInfo.create = function create(properties) {
                return new SoftwareInfo(properties);
            };

            /**
             * Encodes the specified SoftwareInfo message. Does not implicitly {@link lebai.system.SoftwareInfo.verify|verify} messages.
             * @function encode
             * @memberof lebai.system.SoftwareInfo
             * @static
             * @param {lebai.system.ISoftwareInfo} message SoftwareInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SoftwareInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.software != null && Object.hasOwnProperty.call(message, "software"))
                    for (var keys = Object.keys(message.software), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                        $root.lebai.system.SoftwareItemInfo.encode(message.software[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                return writer;
            };

            /**
             * Encodes the specified SoftwareInfo message, length delimited. Does not implicitly {@link lebai.system.SoftwareInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.system.SoftwareInfo
             * @static
             * @param {lebai.system.ISoftwareInfo} message SoftwareInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SoftwareInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SoftwareInfo message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.system.SoftwareInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.system.SoftwareInfo} SoftwareInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SoftwareInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.system.SoftwareInfo(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (message.software === $util.emptyObject)
                                message.software = {};
                            var end2 = reader.uint32() + reader.pos;
                            key = "";
                            value = null;
                            while (reader.pos < end2) {
                                var tag2 = reader.uint32();
                                switch (tag2 >>> 3) {
                                case 1:
                                    key = reader.string();
                                    break;
                                case 2:
                                    value = $root.lebai.system.SoftwareItemInfo.decode(reader, reader.uint32());
                                    break;
                                default:
                                    reader.skipType(tag2 & 7);
                                    break;
                                }
                            }
                            message.software[key] = value;
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SoftwareInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.system.SoftwareInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.system.SoftwareInfo} SoftwareInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SoftwareInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SoftwareInfo message.
             * @function verify
             * @memberof lebai.system.SoftwareInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SoftwareInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.software != null && message.hasOwnProperty("software")) {
                    if (!$util.isObject(message.software))
                        return "software: object expected";
                    var key = Object.keys(message.software);
                    for (var i = 0; i < key.length; ++i) {
                        var error = $root.lebai.system.SoftwareItemInfo.verify(message.software[key[i]]);
                        if (error)
                            return "software." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a SoftwareInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.system.SoftwareInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.system.SoftwareInfo} SoftwareInfo
             */
            SoftwareInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.system.SoftwareInfo)
                    return object;
                var message = new $root.lebai.system.SoftwareInfo();
                if (object.software) {
                    if (typeof object.software !== "object")
                        throw TypeError(".lebai.system.SoftwareInfo.software: object expected");
                    message.software = {};
                    for (var keys = Object.keys(object.software), i = 0; i < keys.length; ++i) {
                        if (typeof object.software[keys[i]] !== "object")
                            throw TypeError(".lebai.system.SoftwareInfo.software: object expected");
                        message.software[keys[i]] = $root.lebai.system.SoftwareItemInfo.fromObject(object.software[keys[i]]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a SoftwareInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.system.SoftwareInfo
             * @static
             * @param {lebai.system.SoftwareInfo} message SoftwareInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SoftwareInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.software = {};
                var keys2;
                if (message.software && (keys2 = Object.keys(message.software)).length) {
                    object.software = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.software[keys2[j]] = $root.lebai.system.SoftwareItemInfo.toObject(message.software[keys2[j]], options);
                }
                return object;
            };

            /**
             * Converts this SoftwareInfo to JSON.
             * @function toJSON
             * @memberof lebai.system.SoftwareInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SoftwareInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SoftwareInfo
             * @function getTypeUrl
             * @memberof lebai.system.SoftwareInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SoftwareInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.system.SoftwareInfo";
            };

            return SoftwareInfo;
        })();

        /**
         * RobotState enum.
         * @name lebai.system.RobotState
         * @enum {number}
         * @property {number} DISCONNECTED=0 DISCONNECTED value
         * @property {number} ESTOP=1 ESTOP value
         * @property {number} BOOTING=2 BOOTING value
         * @property {number} ROBOT_OFF=3 ROBOT_OFF value
         * @property {number} ROBOT_ON=4 ROBOT_ON value
         * @property {number} IDLE=5 IDLE value
         * @property {number} PAUSED=6 PAUSED value
         * @property {number} MOVING=7 MOVING value
         * @property {number} UPDATING=8 UPDATING value
         * @property {number} STARTING=9 STARTING value
         * @property {number} STOPPING=10 STOPPING value
         * @property {number} TEACHING=11 TEACHING value
         * @property {number} STOP=12 STOP value
         */
        system.RobotState = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "DISCONNECTED"] = 0;
            values[valuesById[1] = "ESTOP"] = 1;
            values[valuesById[2] = "BOOTING"] = 2;
            values[valuesById[3] = "ROBOT_OFF"] = 3;
            values[valuesById[4] = "ROBOT_ON"] = 4;
            values[valuesById[5] = "IDLE"] = 5;
            values[valuesById[6] = "PAUSED"] = 6;
            values[valuesById[7] = "MOVING"] = 7;
            values[valuesById[8] = "UPDATING"] = 8;
            values[valuesById[9] = "STARTING"] = 9;
            values[valuesById[10] = "STOPPING"] = 10;
            values[valuesById[11] = "TEACHING"] = 11;
            values[valuesById[12] = "STOP"] = 12;
            return values;
        })();

        system.GetRobotStateResponse = (function() {

            /**
             * Properties of a GetRobotStateResponse.
             * @memberof lebai.system
             * @interface IGetRobotStateResponse
             * @property {lebai.system.RobotState|null} [state] GetRobotStateResponse state
             */

            /**
             * Constructs a new GetRobotStateResponse.
             * @memberof lebai.system
             * @classdesc Represents a GetRobotStateResponse.
             * @implements IGetRobotStateResponse
             * @constructor
             * @param {lebai.system.IGetRobotStateResponse=} [properties] Properties to set
             */
            function GetRobotStateResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetRobotStateResponse state.
             * @member {lebai.system.RobotState} state
             * @memberof lebai.system.GetRobotStateResponse
             * @instance
             */
            GetRobotStateResponse.prototype.state = 0;

            /**
             * Creates a new GetRobotStateResponse instance using the specified properties.
             * @function create
             * @memberof lebai.system.GetRobotStateResponse
             * @static
             * @param {lebai.system.IGetRobotStateResponse=} [properties] Properties to set
             * @returns {lebai.system.GetRobotStateResponse} GetRobotStateResponse instance
             */
            GetRobotStateResponse.create = function create(properties) {
                return new GetRobotStateResponse(properties);
            };

            /**
             * Encodes the specified GetRobotStateResponse message. Does not implicitly {@link lebai.system.GetRobotStateResponse.verify|verify} messages.
             * @function encode
             * @memberof lebai.system.GetRobotStateResponse
             * @static
             * @param {lebai.system.IGetRobotStateResponse} message GetRobotStateResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetRobotStateResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.state != null && Object.hasOwnProperty.call(message, "state"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.state);
                return writer;
            };

            /**
             * Encodes the specified GetRobotStateResponse message, length delimited. Does not implicitly {@link lebai.system.GetRobotStateResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.system.GetRobotStateResponse
             * @static
             * @param {lebai.system.IGetRobotStateResponse} message GetRobotStateResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetRobotStateResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetRobotStateResponse message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.system.GetRobotStateResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.system.GetRobotStateResponse} GetRobotStateResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetRobotStateResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.system.GetRobotStateResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.state = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetRobotStateResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.system.GetRobotStateResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.system.GetRobotStateResponse} GetRobotStateResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetRobotStateResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetRobotStateResponse message.
             * @function verify
             * @memberof lebai.system.GetRobotStateResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetRobotStateResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.state != null && message.hasOwnProperty("state"))
                    switch (message.state) {
                    default:
                        return "state: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                        break;
                    }
                return null;
            };

            /**
             * Creates a GetRobotStateResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.system.GetRobotStateResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.system.GetRobotStateResponse} GetRobotStateResponse
             */
            GetRobotStateResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.system.GetRobotStateResponse)
                    return object;
                var message = new $root.lebai.system.GetRobotStateResponse();
                switch (object.state) {
                default:
                    if (typeof object.state === "number") {
                        message.state = object.state;
                        break;
                    }
                    break;
                case "DISCONNECTED":
                case 0:
                    message.state = 0;
                    break;
                case "ESTOP":
                case 1:
                    message.state = 1;
                    break;
                case "BOOTING":
                case 2:
                    message.state = 2;
                    break;
                case "ROBOT_OFF":
                case 3:
                    message.state = 3;
                    break;
                case "ROBOT_ON":
                case 4:
                    message.state = 4;
                    break;
                case "IDLE":
                case 5:
                    message.state = 5;
                    break;
                case "PAUSED":
                case 6:
                    message.state = 6;
                    break;
                case "MOVING":
                case 7:
                    message.state = 7;
                    break;
                case "UPDATING":
                case 8:
                    message.state = 8;
                    break;
                case "STARTING":
                case 9:
                    message.state = 9;
                    break;
                case "STOPPING":
                case 10:
                    message.state = 10;
                    break;
                case "TEACHING":
                case 11:
                    message.state = 11;
                    break;
                case "STOP":
                case 12:
                    message.state = 12;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a GetRobotStateResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.system.GetRobotStateResponse
             * @static
             * @param {lebai.system.GetRobotStateResponse} message GetRobotStateResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetRobotStateResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.state = options.enums === String ? "DISCONNECTED" : 0;
                if (message.state != null && message.hasOwnProperty("state"))
                    object.state = options.enums === String ? $root.lebai.system.RobotState[message.state] === undefined ? message.state : $root.lebai.system.RobotState[message.state] : message.state;
                return object;
            };

            /**
             * Converts this GetRobotStateResponse to JSON.
             * @function toJSON
             * @memberof lebai.system.GetRobotStateResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetRobotStateResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetRobotStateResponse
             * @function getTypeUrl
             * @memberof lebai.system.GetRobotStateResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetRobotStateResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.system.GetRobotStateResponse";
            };

            return GetRobotStateResponse;
        })();

        system.PhyData = (function() {

            /**
             * Properties of a PhyData.
             * @memberof lebai.system
             * @interface IPhyData
             * @property {Array.<number>|null} [jointTemp] PhyData jointTemp
             * @property {Array.<number>|null} [jointVoltage] PhyData jointVoltage
             * @property {number|null} [flangeVoltage] PhyData flangeVoltage
             */

            /**
             * Constructs a new PhyData.
             * @memberof lebai.system
             * @classdesc Represents a PhyData.
             * @implements IPhyData
             * @constructor
             * @param {lebai.system.IPhyData=} [properties] Properties to set
             */
            function PhyData(properties) {
                this.jointTemp = [];
                this.jointVoltage = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PhyData jointTemp.
             * @member {Array.<number>} jointTemp
             * @memberof lebai.system.PhyData
             * @instance
             */
            PhyData.prototype.jointTemp = $util.emptyArray;

            /**
             * PhyData jointVoltage.
             * @member {Array.<number>} jointVoltage
             * @memberof lebai.system.PhyData
             * @instance
             */
            PhyData.prototype.jointVoltage = $util.emptyArray;

            /**
             * PhyData flangeVoltage.
             * @member {number} flangeVoltage
             * @memberof lebai.system.PhyData
             * @instance
             */
            PhyData.prototype.flangeVoltage = 0;

            /**
             * Creates a new PhyData instance using the specified properties.
             * @function create
             * @memberof lebai.system.PhyData
             * @static
             * @param {lebai.system.IPhyData=} [properties] Properties to set
             * @returns {lebai.system.PhyData} PhyData instance
             */
            PhyData.create = function create(properties) {
                return new PhyData(properties);
            };

            /**
             * Encodes the specified PhyData message. Does not implicitly {@link lebai.system.PhyData.verify|verify} messages.
             * @function encode
             * @memberof lebai.system.PhyData
             * @static
             * @param {lebai.system.IPhyData} message PhyData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PhyData.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.jointTemp != null && message.jointTemp.length) {
                    writer.uint32(/* id 2, wireType 2 =*/18).fork();
                    for (var i = 0; i < message.jointTemp.length; ++i)
                        writer.double(message.jointTemp[i]);
                    writer.ldelim();
                }
                if (message.jointVoltage != null && message.jointVoltage.length) {
                    writer.uint32(/* id 11, wireType 2 =*/90).fork();
                    for (var i = 0; i < message.jointVoltage.length; ++i)
                        writer.double(message.jointVoltage[i]);
                    writer.ldelim();
                }
                if (message.flangeVoltage != null && Object.hasOwnProperty.call(message, "flangeVoltage"))
                    writer.uint32(/* id 12, wireType 1 =*/97).double(message.flangeVoltage);
                return writer;
            };

            /**
             * Encodes the specified PhyData message, length delimited. Does not implicitly {@link lebai.system.PhyData.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.system.PhyData
             * @static
             * @param {lebai.system.IPhyData} message PhyData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PhyData.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PhyData message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.system.PhyData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.system.PhyData} PhyData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PhyData.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.system.PhyData();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2: {
                            if (!(message.jointTemp && message.jointTemp.length))
                                message.jointTemp = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.jointTemp.push(reader.double());
                            } else
                                message.jointTemp.push(reader.double());
                            break;
                        }
                    case 11: {
                            if (!(message.jointVoltage && message.jointVoltage.length))
                                message.jointVoltage = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.jointVoltage.push(reader.double());
                            } else
                                message.jointVoltage.push(reader.double());
                            break;
                        }
                    case 12: {
                            message.flangeVoltage = reader.double();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PhyData message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.system.PhyData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.system.PhyData} PhyData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PhyData.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PhyData message.
             * @function verify
             * @memberof lebai.system.PhyData
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PhyData.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.jointTemp != null && message.hasOwnProperty("jointTemp")) {
                    if (!Array.isArray(message.jointTemp))
                        return "jointTemp: array expected";
                    for (var i = 0; i < message.jointTemp.length; ++i)
                        if (typeof message.jointTemp[i] !== "number")
                            return "jointTemp: number[] expected";
                }
                if (message.jointVoltage != null && message.hasOwnProperty("jointVoltage")) {
                    if (!Array.isArray(message.jointVoltage))
                        return "jointVoltage: array expected";
                    for (var i = 0; i < message.jointVoltage.length; ++i)
                        if (typeof message.jointVoltage[i] !== "number")
                            return "jointVoltage: number[] expected";
                }
                if (message.flangeVoltage != null && message.hasOwnProperty("flangeVoltage"))
                    if (typeof message.flangeVoltage !== "number")
                        return "flangeVoltage: number expected";
                return null;
            };

            /**
             * Creates a PhyData message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.system.PhyData
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.system.PhyData} PhyData
             */
            PhyData.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.system.PhyData)
                    return object;
                var message = new $root.lebai.system.PhyData();
                if (object.jointTemp) {
                    if (!Array.isArray(object.jointTemp))
                        throw TypeError(".lebai.system.PhyData.jointTemp: array expected");
                    message.jointTemp = [];
                    for (var i = 0; i < object.jointTemp.length; ++i)
                        message.jointTemp[i] = Number(object.jointTemp[i]);
                }
                if (object.jointVoltage) {
                    if (!Array.isArray(object.jointVoltage))
                        throw TypeError(".lebai.system.PhyData.jointVoltage: array expected");
                    message.jointVoltage = [];
                    for (var i = 0; i < object.jointVoltage.length; ++i)
                        message.jointVoltage[i] = Number(object.jointVoltage[i]);
                }
                if (object.flangeVoltage != null)
                    message.flangeVoltage = Number(object.flangeVoltage);
                return message;
            };

            /**
             * Creates a plain object from a PhyData message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.system.PhyData
             * @static
             * @param {lebai.system.PhyData} message PhyData
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PhyData.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.jointTemp = [];
                    object.jointVoltage = [];
                }
                if (options.defaults)
                    object.flangeVoltage = 0;
                if (message.jointTemp && message.jointTemp.length) {
                    object.jointTemp = [];
                    for (var j = 0; j < message.jointTemp.length; ++j)
                        object.jointTemp[j] = options.json && !isFinite(message.jointTemp[j]) ? String(message.jointTemp[j]) : message.jointTemp[j];
                }
                if (message.jointVoltage && message.jointVoltage.length) {
                    object.jointVoltage = [];
                    for (var j = 0; j < message.jointVoltage.length; ++j)
                        object.jointVoltage[j] = options.json && !isFinite(message.jointVoltage[j]) ? String(message.jointVoltage[j]) : message.jointVoltage[j];
                }
                if (message.flangeVoltage != null && message.hasOwnProperty("flangeVoltage"))
                    object.flangeVoltage = options.json && !isFinite(message.flangeVoltage) ? String(message.flangeVoltage) : message.flangeVoltage;
                return object;
            };

            /**
             * Converts this PhyData to JSON.
             * @function toJSON
             * @memberof lebai.system.PhyData
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PhyData.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for PhyData
             * @function getTypeUrl
             * @memberof lebai.system.PhyData
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            PhyData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.system.PhyData";
            };

            return PhyData;
        })();

        /**
         * EstopReason enum.
         * @name lebai.system.EstopReason
         * @enum {number}
         * @property {number} NONE=0 NONE value
         * @property {number} SYSTEM=2 SYSTEM value
         * @property {number} MANUAL=3 MANUAL value
         * @property {number} HARD_ESTOP=4 HARD_ESTOP value
         * @property {number} COLLISION=5 COLLISION value
         * @property {number} JOINT_LIMIT=6 JOINT_LIMIT value
         * @property {number} EXCEED=7 EXCEED value
         * @property {number} TRAJECTORY_ERROR=8 TRAJECTORY_ERROR value
         * @property {number} COMM_ERROR=11 COMM_ERROR value
         * @property {number} CAN_ERROR=12 CAN_ERROR value
         * @property {number} JOINT_ERROR=13 JOINT_ERROR value
         */
        system.EstopReason = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "NONE"] = 0;
            values[valuesById[2] = "SYSTEM"] = 2;
            values[valuesById[3] = "MANUAL"] = 3;
            values[valuesById[4] = "HARD_ESTOP"] = 4;
            values[valuesById[5] = "COLLISION"] = 5;
            values[valuesById[6] = "JOINT_LIMIT"] = 6;
            values[valuesById[7] = "EXCEED"] = 7;
            values[valuesById[8] = "TRAJECTORY_ERROR"] = 8;
            values[valuesById[11] = "COMM_ERROR"] = 11;
            values[valuesById[12] = "CAN_ERROR"] = 12;
            values[valuesById[13] = "JOINT_ERROR"] = 13;
            return values;
        })();

        system.GetEstopReasonResponse = (function() {

            /**
             * Properties of a GetEstopReasonResponse.
             * @memberof lebai.system
             * @interface IGetEstopReasonResponse
             * @property {lebai.system.EstopReason|null} [reason] GetEstopReasonResponse reason
             */

            /**
             * Constructs a new GetEstopReasonResponse.
             * @memberof lebai.system
             * @classdesc Represents a GetEstopReasonResponse.
             * @implements IGetEstopReasonResponse
             * @constructor
             * @param {lebai.system.IGetEstopReasonResponse=} [properties] Properties to set
             */
            function GetEstopReasonResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetEstopReasonResponse reason.
             * @member {lebai.system.EstopReason} reason
             * @memberof lebai.system.GetEstopReasonResponse
             * @instance
             */
            GetEstopReasonResponse.prototype.reason = 0;

            /**
             * Creates a new GetEstopReasonResponse instance using the specified properties.
             * @function create
             * @memberof lebai.system.GetEstopReasonResponse
             * @static
             * @param {lebai.system.IGetEstopReasonResponse=} [properties] Properties to set
             * @returns {lebai.system.GetEstopReasonResponse} GetEstopReasonResponse instance
             */
            GetEstopReasonResponse.create = function create(properties) {
                return new GetEstopReasonResponse(properties);
            };

            /**
             * Encodes the specified GetEstopReasonResponse message. Does not implicitly {@link lebai.system.GetEstopReasonResponse.verify|verify} messages.
             * @function encode
             * @memberof lebai.system.GetEstopReasonResponse
             * @static
             * @param {lebai.system.IGetEstopReasonResponse} message GetEstopReasonResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetEstopReasonResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.reason);
                return writer;
            };

            /**
             * Encodes the specified GetEstopReasonResponse message, length delimited. Does not implicitly {@link lebai.system.GetEstopReasonResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.system.GetEstopReasonResponse
             * @static
             * @param {lebai.system.IGetEstopReasonResponse} message GetEstopReasonResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetEstopReasonResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetEstopReasonResponse message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.system.GetEstopReasonResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.system.GetEstopReasonResponse} GetEstopReasonResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetEstopReasonResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.system.GetEstopReasonResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.reason = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetEstopReasonResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.system.GetEstopReasonResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.system.GetEstopReasonResponse} GetEstopReasonResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetEstopReasonResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetEstopReasonResponse message.
             * @function verify
             * @memberof lebai.system.GetEstopReasonResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetEstopReasonResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.reason != null && message.hasOwnProperty("reason"))
                    switch (message.reason) {
                    default:
                        return "reason: enum value expected";
                    case 0:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 11:
                    case 12:
                    case 13:
                        break;
                    }
                return null;
            };

            /**
             * Creates a GetEstopReasonResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.system.GetEstopReasonResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.system.GetEstopReasonResponse} GetEstopReasonResponse
             */
            GetEstopReasonResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.system.GetEstopReasonResponse)
                    return object;
                var message = new $root.lebai.system.GetEstopReasonResponse();
                switch (object.reason) {
                default:
                    if (typeof object.reason === "number") {
                        message.reason = object.reason;
                        break;
                    }
                    break;
                case "NONE":
                case 0:
                    message.reason = 0;
                    break;
                case "SYSTEM":
                case 2:
                    message.reason = 2;
                    break;
                case "MANUAL":
                case 3:
                    message.reason = 3;
                    break;
                case "HARD_ESTOP":
                case 4:
                    message.reason = 4;
                    break;
                case "COLLISION":
                case 5:
                    message.reason = 5;
                    break;
                case "JOINT_LIMIT":
                case 6:
                    message.reason = 6;
                    break;
                case "EXCEED":
                case 7:
                    message.reason = 7;
                    break;
                case "TRAJECTORY_ERROR":
                case 8:
                    message.reason = 8;
                    break;
                case "COMM_ERROR":
                case 11:
                    message.reason = 11;
                    break;
                case "CAN_ERROR":
                case 12:
                    message.reason = 12;
                    break;
                case "JOINT_ERROR":
                case 13:
                    message.reason = 13;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a GetEstopReasonResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.system.GetEstopReasonResponse
             * @static
             * @param {lebai.system.GetEstopReasonResponse} message GetEstopReasonResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetEstopReasonResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.reason = options.enums === String ? "NONE" : 0;
                if (message.reason != null && message.hasOwnProperty("reason"))
                    object.reason = options.enums === String ? $root.lebai.system.EstopReason[message.reason] === undefined ? message.reason : $root.lebai.system.EstopReason[message.reason] : message.reason;
                return object;
            };

            /**
             * Converts this GetEstopReasonResponse to JSON.
             * @function toJSON
             * @memberof lebai.system.GetEstopReasonResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetEstopReasonResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetEstopReasonResponse
             * @function getTypeUrl
             * @memberof lebai.system.GetEstopReasonResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetEstopReasonResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.system.GetEstopReasonResponse";
            };

            return GetEstopReasonResponse;
        })();

        system.SystemService = (function() {

            /**
             * Constructs a new SystemService service.
             * @memberof lebai.system
             * @classdesc Represents a SystemService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function SystemService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (SystemService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = SystemService;

            /**
             * Creates new SystemService service using the specified rpc implementation.
             * @function create
             * @memberof lebai.system.SystemService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {SystemService} RPC service. Useful where requests and/or responses are streamed.
             */
            SystemService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link lebai.system.SystemService#hello}.
             * @memberof lebai.system.SystemService
             * @typedef HelloCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.system.HelloData} [response] HelloData
             */

            /**
             * Calls Hello.
             * @function hello
             * @memberof lebai.system.SystemService
             * @instance
             * @param {lebai.system.IHelloData} request HelloData message or plain object
             * @param {lebai.system.SystemService.HelloCallback} callback Node-style callback called with the error, if any, and HelloData
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(SystemService.prototype.hello = function hello(request, callback) {
                return this.rpcCall(hello, $root.lebai.system.HelloData, $root.lebai.system.HelloData, request, callback);
            }, "name", { value: "Hello" });

            /**
             * Calls Hello.
             * @function hello
             * @memberof lebai.system.SystemService
             * @instance
             * @param {lebai.system.IHelloData} request HelloData message or plain object
             * @returns {Promise<lebai.system.HelloData>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.system.SystemService#getSystemInfo}.
             * @memberof lebai.system.SystemService
             * @typedef GetSystemInfoCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.system.SystemInfo} [response] SystemInfo
             */

            /**
             * Calls GetSystemInfo.
             * @function getSystemInfo
             * @memberof lebai.system.SystemService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {lebai.system.SystemService.GetSystemInfoCallback} callback Node-style callback called with the error, if any, and SystemInfo
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(SystemService.prototype.getSystemInfo = function getSystemInfo(request, callback) {
                return this.rpcCall(getSystemInfo, $root.google.protobuf.Empty, $root.lebai.system.SystemInfo, request, callback);
            }, "name", { value: "GetSystemInfo" });

            /**
             * Calls GetSystemInfo.
             * @function getSystemInfo
             * @memberof lebai.system.SystemService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<lebai.system.SystemInfo>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.system.SystemService#getRobotInfo}.
             * @memberof lebai.system.SystemService
             * @typedef GetRobotInfoCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.system.RobotInfo} [response] RobotInfo
             */

            /**
             * Calls GetRobotInfo.
             * @function getRobotInfo
             * @memberof lebai.system.SystemService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {lebai.system.SystemService.GetRobotInfoCallback} callback Node-style callback called with the error, if any, and RobotInfo
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(SystemService.prototype.getRobotInfo = function getRobotInfo(request, callback) {
                return this.rpcCall(getRobotInfo, $root.google.protobuf.Empty, $root.lebai.system.RobotInfo, request, callback);
            }, "name", { value: "GetRobotInfo" });

            /**
             * Calls GetRobotInfo.
             * @function getRobotInfo
             * @memberof lebai.system.SystemService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<lebai.system.RobotInfo>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.system.SystemService#getHardwareInfo}.
             * @memberof lebai.system.SystemService
             * @typedef GetHardwareInfoCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.system.HardwareInfo} [response] HardwareInfo
             */

            /**
             * Calls GetHardwareInfo.
             * @function getHardwareInfo
             * @memberof lebai.system.SystemService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {lebai.system.SystemService.GetHardwareInfoCallback} callback Node-style callback called with the error, if any, and HardwareInfo
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(SystemService.prototype.getHardwareInfo = function getHardwareInfo(request, callback) {
                return this.rpcCall(getHardwareInfo, $root.google.protobuf.Empty, $root.lebai.system.HardwareInfo, request, callback);
            }, "name", { value: "GetHardwareInfo" });

            /**
             * Calls GetHardwareInfo.
             * @function getHardwareInfo
             * @memberof lebai.system.SystemService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<lebai.system.HardwareInfo>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.system.SystemService#getSoftwareInfo}.
             * @memberof lebai.system.SystemService
             * @typedef GetSoftwareInfoCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.system.SoftwareInfo} [response] SoftwareInfo
             */

            /**
             * Calls GetSoftwareInfo.
             * @function getSoftwareInfo
             * @memberof lebai.system.SystemService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {lebai.system.SystemService.GetSoftwareInfoCallback} callback Node-style callback called with the error, if any, and SoftwareInfo
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(SystemService.prototype.getSoftwareInfo = function getSoftwareInfo(request, callback) {
                return this.rpcCall(getSoftwareInfo, $root.google.protobuf.Empty, $root.lebai.system.SoftwareInfo, request, callback);
            }, "name", { value: "GetSoftwareInfo" });

            /**
             * Calls GetSoftwareInfo.
             * @function getSoftwareInfo
             * @memberof lebai.system.SystemService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<lebai.system.SoftwareInfo>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.system.SystemService#setVirtualIp}.
             * @memberof lebai.system.SystemService
             * @typedef SetVirtualIpCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls SetVirtualIp.
             * @function setVirtualIp
             * @memberof lebai.system.SystemService
             * @instance
             * @param {lebai.system.ISetVirtualIpRequest} request SetVirtualIpRequest message or plain object
             * @param {lebai.system.SystemService.SetVirtualIpCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(SystemService.prototype.setVirtualIp = function setVirtualIp(request, callback) {
                return this.rpcCall(setVirtualIp, $root.lebai.system.SetVirtualIpRequest, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "SetVirtualIp" });

            /**
             * Calls SetVirtualIp.
             * @function setVirtualIp
             * @memberof lebai.system.SystemService
             * @instance
             * @param {lebai.system.ISetVirtualIpRequest} request SetVirtualIpRequest message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.system.SystemService#getRobotState}.
             * @memberof lebai.system.SystemService
             * @typedef GetRobotStateCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.system.GetRobotStateResponse} [response] GetRobotStateResponse
             */

            /**
             * Calls GetRobotState.
             * @function getRobotState
             * @memberof lebai.system.SystemService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {lebai.system.SystemService.GetRobotStateCallback} callback Node-style callback called with the error, if any, and GetRobotStateResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(SystemService.prototype.getRobotState = function getRobotState(request, callback) {
                return this.rpcCall(getRobotState, $root.google.protobuf.Empty, $root.lebai.system.GetRobotStateResponse, request, callback);
            }, "name", { value: "GetRobotState" });

            /**
             * Calls GetRobotState.
             * @function getRobotState
             * @memberof lebai.system.SystemService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<lebai.system.GetRobotStateResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.system.SystemService#subRobotState}.
             * @memberof lebai.system.SystemService
             * @typedef SubRobotStateCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.system.GetRobotStateResponse} [response] GetRobotStateResponse
             */

            /**
             * Calls SubRobotState.
             * @function subRobotState
             * @memberof lebai.system.SystemService
             * @instance
             * @param {lebai.ISubscribeRequest} request SubscribeRequest message or plain object
             * @param {lebai.system.SystemService.SubRobotStateCallback} callback Node-style callback called with the error, if any, and GetRobotStateResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(SystemService.prototype.subRobotState = function subRobotState(request, callback) {
                return this.rpcCall(subRobotState, $root.lebai.SubscribeRequest, $root.lebai.system.GetRobotStateResponse, request, callback);
            }, "name", { value: "SubRobotState" });

            /**
             * Calls SubRobotState.
             * @function subRobotState
             * @memberof lebai.system.SystemService
             * @instance
             * @param {lebai.ISubscribeRequest} request SubscribeRequest message or plain object
             * @returns {Promise<lebai.system.GetRobotStateResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.system.SystemService#getPhyData}.
             * @memberof lebai.system.SystemService
             * @typedef GetPhyDataCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.system.PhyData} [response] PhyData
             */

            /**
             * Calls GetPhyData.
             * @function getPhyData
             * @memberof lebai.system.SystemService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {lebai.system.SystemService.GetPhyDataCallback} callback Node-style callback called with the error, if any, and PhyData
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(SystemService.prototype.getPhyData = function getPhyData(request, callback) {
                return this.rpcCall(getPhyData, $root.google.protobuf.Empty, $root.lebai.system.PhyData, request, callback);
            }, "name", { value: "GetPhyData" });

            /**
             * Calls GetPhyData.
             * @function getPhyData
             * @memberof lebai.system.SystemService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<lebai.system.PhyData>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.system.SystemService#subPhyData}.
             * @memberof lebai.system.SystemService
             * @typedef SubPhyDataCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.system.PhyData} [response] PhyData
             */

            /**
             * Calls SubPhyData.
             * @function subPhyData
             * @memberof lebai.system.SystemService
             * @instance
             * @param {lebai.ISubscribeRequest} request SubscribeRequest message or plain object
             * @param {lebai.system.SystemService.SubPhyDataCallback} callback Node-style callback called with the error, if any, and PhyData
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(SystemService.prototype.subPhyData = function subPhyData(request, callback) {
                return this.rpcCall(subPhyData, $root.lebai.SubscribeRequest, $root.lebai.system.PhyData, request, callback);
            }, "name", { value: "SubPhyData" });

            /**
             * Calls SubPhyData.
             * @function subPhyData
             * @memberof lebai.system.SystemService
             * @instance
             * @param {lebai.ISubscribeRequest} request SubscribeRequest message or plain object
             * @returns {Promise<lebai.system.PhyData>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.system.SystemService#powerdown}.
             * @memberof lebai.system.SystemService
             * @typedef PowerdownCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls Powerdown.
             * @function powerdown
             * @memberof lebai.system.SystemService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {lebai.system.SystemService.PowerdownCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(SystemService.prototype.powerdown = function powerdown(request, callback) {
                return this.rpcCall(powerdown, $root.google.protobuf.Empty, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "Powerdown" });

            /**
             * Calls Powerdown.
             * @function powerdown
             * @memberof lebai.system.SystemService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.system.SystemService#reboot}.
             * @memberof lebai.system.SystemService
             * @typedef RebootCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls Reboot.
             * @function reboot
             * @memberof lebai.system.SystemService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {lebai.system.SystemService.RebootCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(SystemService.prototype.reboot = function reboot(request, callback) {
                return this.rpcCall(reboot, $root.google.protobuf.Empty, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "Reboot" });

            /**
             * Calls Reboot.
             * @function reboot
             * @memberof lebai.system.SystemService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.system.SystemService#startSys}.
             * @memberof lebai.system.SystemService
             * @typedef StartSysCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls StartSys.
             * @function startSys
             * @memberof lebai.system.SystemService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {lebai.system.SystemService.StartSysCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(SystemService.prototype.startSys = function startSys(request, callback) {
                return this.rpcCall(startSys, $root.google.protobuf.Empty, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "StartSys" });

            /**
             * Calls StartSys.
             * @function startSys
             * @memberof lebai.system.SystemService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.system.SystemService#stopSys}.
             * @memberof lebai.system.SystemService
             * @typedef StopSysCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls StopSys.
             * @function stopSys
             * @memberof lebai.system.SystemService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {lebai.system.SystemService.StopSysCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(SystemService.prototype.stopSys = function stopSys(request, callback) {
                return this.rpcCall(stopSys, $root.google.protobuf.Empty, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "StopSys" });

            /**
             * Calls StopSys.
             * @function stopSys
             * @memberof lebai.system.SystemService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.system.SystemService#stop}.
             * @memberof lebai.system.SystemService
             * @typedef StopCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls Stop.
             * @function stop
             * @memberof lebai.system.SystemService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {lebai.system.SystemService.StopCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(SystemService.prototype.stop = function stop(request, callback) {
                return this.rpcCall(stop, $root.google.protobuf.Empty, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "Stop" });

            /**
             * Calls Stop.
             * @function stop
             * @memberof lebai.system.SystemService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.system.SystemService#estop}.
             * @memberof lebai.system.SystemService
             * @typedef EstopCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls Estop.
             * @function estop
             * @memberof lebai.system.SystemService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {lebai.system.SystemService.EstopCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(SystemService.prototype.estop = function estop(request, callback) {
                return this.rpcCall(estop, $root.google.protobuf.Empty, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "Estop" });

            /**
             * Calls Estop.
             * @function estop
             * @memberof lebai.system.SystemService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.system.SystemService#getEstopReason}.
             * @memberof lebai.system.SystemService
             * @typedef GetEstopReasonCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.system.GetEstopReasonResponse} [response] GetEstopReasonResponse
             */

            /**
             * Calls GetEstopReason.
             * @function getEstopReason
             * @memberof lebai.system.SystemService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {lebai.system.SystemService.GetEstopReasonCallback} callback Node-style callback called with the error, if any, and GetEstopReasonResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(SystemService.prototype.getEstopReason = function getEstopReason(request, callback) {
                return this.rpcCall(getEstopReason, $root.google.protobuf.Empty, $root.lebai.system.GetEstopReasonResponse, request, callback);
            }, "name", { value: "GetEstopReason" });

            /**
             * Calls GetEstopReason.
             * @function getEstopReason
             * @memberof lebai.system.SystemService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<lebai.system.GetEstopReasonResponse>} Promise
             * @variation 2
             */

            return SystemService;
        })();

        return system;
    })();

    lebai.SubscribeRequest = (function() {

        /**
         * Properties of a SubscribeRequest.
         * @memberof lebai
         * @interface ISubscribeRequest
         * @property {number|Long|null} [intervalMin] SubscribeRequest intervalMin
         * @property {number|Long|null} [intervalMax] SubscribeRequest intervalMax
         */

        /**
         * Constructs a new SubscribeRequest.
         * @memberof lebai
         * @classdesc Represents a SubscribeRequest.
         * @implements ISubscribeRequest
         * @constructor
         * @param {lebai.ISubscribeRequest=} [properties] Properties to set
         */
        function SubscribeRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SubscribeRequest intervalMin.
         * @member {number|Long} intervalMin
         * @memberof lebai.SubscribeRequest
         * @instance
         */
        SubscribeRequest.prototype.intervalMin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * SubscribeRequest intervalMax.
         * @member {number|Long} intervalMax
         * @memberof lebai.SubscribeRequest
         * @instance
         */
        SubscribeRequest.prototype.intervalMax = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new SubscribeRequest instance using the specified properties.
         * @function create
         * @memberof lebai.SubscribeRequest
         * @static
         * @param {lebai.ISubscribeRequest=} [properties] Properties to set
         * @returns {lebai.SubscribeRequest} SubscribeRequest instance
         */
        SubscribeRequest.create = function create(properties) {
            return new SubscribeRequest(properties);
        };

        /**
         * Encodes the specified SubscribeRequest message. Does not implicitly {@link lebai.SubscribeRequest.verify|verify} messages.
         * @function encode
         * @memberof lebai.SubscribeRequest
         * @static
         * @param {lebai.ISubscribeRequest} message SubscribeRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribeRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.intervalMin != null && Object.hasOwnProperty.call(message, "intervalMin"))
                writer.uint32(/* id 11, wireType 0 =*/88).uint64(message.intervalMin);
            if (message.intervalMax != null && Object.hasOwnProperty.call(message, "intervalMax"))
                writer.uint32(/* id 12, wireType 0 =*/96).uint64(message.intervalMax);
            return writer;
        };

        /**
         * Encodes the specified SubscribeRequest message, length delimited. Does not implicitly {@link lebai.SubscribeRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lebai.SubscribeRequest
         * @static
         * @param {lebai.ISubscribeRequest} message SubscribeRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribeRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SubscribeRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lebai.SubscribeRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lebai.SubscribeRequest} SubscribeRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribeRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.SubscribeRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 11: {
                        message.intervalMin = reader.uint64();
                        break;
                    }
                case 12: {
                        message.intervalMax = reader.uint64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SubscribeRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lebai.SubscribeRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lebai.SubscribeRequest} SubscribeRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribeRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SubscribeRequest message.
         * @function verify
         * @memberof lebai.SubscribeRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SubscribeRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.intervalMin != null && message.hasOwnProperty("intervalMin"))
                if (!$util.isInteger(message.intervalMin) && !(message.intervalMin && $util.isInteger(message.intervalMin.low) && $util.isInteger(message.intervalMin.high)))
                    return "intervalMin: integer|Long expected";
            if (message.intervalMax != null && message.hasOwnProperty("intervalMax"))
                if (!$util.isInteger(message.intervalMax) && !(message.intervalMax && $util.isInteger(message.intervalMax.low) && $util.isInteger(message.intervalMax.high)))
                    return "intervalMax: integer|Long expected";
            return null;
        };

        /**
         * Creates a SubscribeRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lebai.SubscribeRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lebai.SubscribeRequest} SubscribeRequest
         */
        SubscribeRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lebai.SubscribeRequest)
                return object;
            var message = new $root.lebai.SubscribeRequest();
            if (object.intervalMin != null)
                if ($util.Long)
                    (message.intervalMin = $util.Long.fromValue(object.intervalMin)).unsigned = true;
                else if (typeof object.intervalMin === "string")
                    message.intervalMin = parseInt(object.intervalMin, 10);
                else if (typeof object.intervalMin === "number")
                    message.intervalMin = object.intervalMin;
                else if (typeof object.intervalMin === "object")
                    message.intervalMin = new $util.LongBits(object.intervalMin.low >>> 0, object.intervalMin.high >>> 0).toNumber(true);
            if (object.intervalMax != null)
                if ($util.Long)
                    (message.intervalMax = $util.Long.fromValue(object.intervalMax)).unsigned = true;
                else if (typeof object.intervalMax === "string")
                    message.intervalMax = parseInt(object.intervalMax, 10);
                else if (typeof object.intervalMax === "number")
                    message.intervalMax = object.intervalMax;
                else if (typeof object.intervalMax === "object")
                    message.intervalMax = new $util.LongBits(object.intervalMax.low >>> 0, object.intervalMax.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a SubscribeRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lebai.SubscribeRequest
         * @static
         * @param {lebai.SubscribeRequest} message SubscribeRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SubscribeRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.intervalMin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.intervalMin = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.intervalMax = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.intervalMax = options.longs === String ? "0" : 0;
            }
            if (message.intervalMin != null && message.hasOwnProperty("intervalMin"))
                if (typeof message.intervalMin === "number")
                    object.intervalMin = options.longs === String ? String(message.intervalMin) : message.intervalMin;
                else
                    object.intervalMin = options.longs === String ? $util.Long.prototype.toString.call(message.intervalMin) : options.longs === Number ? new $util.LongBits(message.intervalMin.low >>> 0, message.intervalMin.high >>> 0).toNumber(true) : message.intervalMin;
            if (message.intervalMax != null && message.hasOwnProperty("intervalMax"))
                if (typeof message.intervalMax === "number")
                    object.intervalMax = options.longs === String ? String(message.intervalMax) : message.intervalMax;
                else
                    object.intervalMax = options.longs === String ? $util.Long.prototype.toString.call(message.intervalMax) : options.longs === Number ? new $util.LongBits(message.intervalMax.low >>> 0, message.intervalMax.high >>> 0).toNumber(true) : message.intervalMax;
            return object;
        };

        /**
         * Converts this SubscribeRequest to JSON.
         * @function toJSON
         * @memberof lebai.SubscribeRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SubscribeRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SubscribeRequest
         * @function getTypeUrl
         * @memberof lebai.SubscribeRequest
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SubscribeRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/lebai.SubscribeRequest";
        };

        return SubscribeRequest;
    })();

    lebai.CommandStdout = (function() {

        /**
         * Properties of a CommandStdout.
         * @memberof lebai
         * @interface ICommandStdout
         * @property {boolean|null} [done] CommandStdout done
         * @property {string|null} [stdout] CommandStdout stdout
         * @property {string|null} [stderr] CommandStdout stderr
         * @property {number|null} [code] CommandStdout code
         */

        /**
         * Constructs a new CommandStdout.
         * @memberof lebai
         * @classdesc Represents a CommandStdout.
         * @implements ICommandStdout
         * @constructor
         * @param {lebai.ICommandStdout=} [properties] Properties to set
         */
        function CommandStdout(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CommandStdout done.
         * @member {boolean} done
         * @memberof lebai.CommandStdout
         * @instance
         */
        CommandStdout.prototype.done = false;

        /**
         * CommandStdout stdout.
         * @member {string} stdout
         * @memberof lebai.CommandStdout
         * @instance
         */
        CommandStdout.prototype.stdout = "";

        /**
         * CommandStdout stderr.
         * @member {string} stderr
         * @memberof lebai.CommandStdout
         * @instance
         */
        CommandStdout.prototype.stderr = "";

        /**
         * CommandStdout code.
         * @member {number} code
         * @memberof lebai.CommandStdout
         * @instance
         */
        CommandStdout.prototype.code = 0;

        /**
         * Creates a new CommandStdout instance using the specified properties.
         * @function create
         * @memberof lebai.CommandStdout
         * @static
         * @param {lebai.ICommandStdout=} [properties] Properties to set
         * @returns {lebai.CommandStdout} CommandStdout instance
         */
        CommandStdout.create = function create(properties) {
            return new CommandStdout(properties);
        };

        /**
         * Encodes the specified CommandStdout message. Does not implicitly {@link lebai.CommandStdout.verify|verify} messages.
         * @function encode
         * @memberof lebai.CommandStdout
         * @static
         * @param {lebai.ICommandStdout} message CommandStdout message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CommandStdout.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.done != null && Object.hasOwnProperty.call(message, "done"))
                writer.uint32(/* id 11, wireType 0 =*/88).bool(message.done);
            if (message.stdout != null && Object.hasOwnProperty.call(message, "stdout"))
                writer.uint32(/* id 12, wireType 2 =*/98).string(message.stdout);
            if (message.stderr != null && Object.hasOwnProperty.call(message, "stderr"))
                writer.uint32(/* id 13, wireType 2 =*/106).string(message.stderr);
            if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                writer.uint32(/* id 14, wireType 0 =*/112).int32(message.code);
            return writer;
        };

        /**
         * Encodes the specified CommandStdout message, length delimited. Does not implicitly {@link lebai.CommandStdout.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lebai.CommandStdout
         * @static
         * @param {lebai.ICommandStdout} message CommandStdout message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CommandStdout.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CommandStdout message from the specified reader or buffer.
         * @function decode
         * @memberof lebai.CommandStdout
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lebai.CommandStdout} CommandStdout
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommandStdout.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.CommandStdout();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 11: {
                        message.done = reader.bool();
                        break;
                    }
                case 12: {
                        message.stdout = reader.string();
                        break;
                    }
                case 13: {
                        message.stderr = reader.string();
                        break;
                    }
                case 14: {
                        message.code = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CommandStdout message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lebai.CommandStdout
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lebai.CommandStdout} CommandStdout
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommandStdout.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CommandStdout message.
         * @function verify
         * @memberof lebai.CommandStdout
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CommandStdout.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.done != null && message.hasOwnProperty("done"))
                if (typeof message.done !== "boolean")
                    return "done: boolean expected";
            if (message.stdout != null && message.hasOwnProperty("stdout"))
                if (!$util.isString(message.stdout))
                    return "stdout: string expected";
            if (message.stderr != null && message.hasOwnProperty("stderr"))
                if (!$util.isString(message.stderr))
                    return "stderr: string expected";
            if (message.code != null && message.hasOwnProperty("code"))
                if (!$util.isInteger(message.code))
                    return "code: integer expected";
            return null;
        };

        /**
         * Creates a CommandStdout message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lebai.CommandStdout
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lebai.CommandStdout} CommandStdout
         */
        CommandStdout.fromObject = function fromObject(object) {
            if (object instanceof $root.lebai.CommandStdout)
                return object;
            var message = new $root.lebai.CommandStdout();
            if (object.done != null)
                message.done = Boolean(object.done);
            if (object.stdout != null)
                message.stdout = String(object.stdout);
            if (object.stderr != null)
                message.stderr = String(object.stderr);
            if (object.code != null)
                message.code = object.code | 0;
            return message;
        };

        /**
         * Creates a plain object from a CommandStdout message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lebai.CommandStdout
         * @static
         * @param {lebai.CommandStdout} message CommandStdout
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CommandStdout.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.done = false;
                object.stdout = "";
                object.stderr = "";
                object.code = 0;
            }
            if (message.done != null && message.hasOwnProperty("done"))
                object.done = message.done;
            if (message.stdout != null && message.hasOwnProperty("stdout"))
                object.stdout = message.stdout;
            if (message.stderr != null && message.hasOwnProperty("stderr"))
                object.stderr = message.stderr;
            if (message.code != null && message.hasOwnProperty("code"))
                object.code = message.code;
            return object;
        };

        /**
         * Converts this CommandStdout to JSON.
         * @function toJSON
         * @memberof lebai.CommandStdout
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CommandStdout.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for CommandStdout
         * @function getTypeUrl
         * @memberof lebai.CommandStdout
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CommandStdout.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/lebai.CommandStdout";
        };

        return CommandStdout;
    })();

    lebai.hardware = (function() {

        /**
         * Namespace hardware.
         * @memberof lebai
         * @namespace
         */
        var hardware = {};

        /**
         * Address enum.
         * @name lebai.hardware.Address
         * @enum {number}
         * @property {number} EMPTY=0 发送时代表广播，接收时代表无设备
         * @property {number} JOINT1=1 关节1（离基座最近）
         * @property {number} JOINT2=2 关节2
         * @property {number} JOINT3=3 关节3
         * @property {number} JOINT4=4 关节4
         * @property {number} JOINT5=5 关节5
         * @property {number} JOINT6=6 关节6
         * @property {number} JOINT7=7 关节7
         * @property {number} FLANGE=8 法兰
         * @property {number} CLAW=9 夹爪
         * @property {number} LED=10 灯板
         * @property {number} DIAL=13 百分表
         * @property {number} COMM_BOARD=14 通信板
         * @property {number} TEST_BOARD=15 测试板
         */
        hardware.Address = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "EMPTY"] = 0;
            values[valuesById[1] = "JOINT1"] = 1;
            values[valuesById[2] = "JOINT2"] = 2;
            values[valuesById[3] = "JOINT3"] = 3;
            values[valuesById[4] = "JOINT4"] = 4;
            values[valuesById[5] = "JOINT5"] = 5;
            values[valuesById[6] = "JOINT6"] = 6;
            values[valuesById[7] = "JOINT7"] = 7;
            values[valuesById[8] = "FLANGE"] = 8;
            values[valuesById[9] = "CLAW"] = 9;
            values[valuesById[10] = "LED"] = 10;
            values[valuesById[13] = "DIAL"] = 13;
            values[valuesById[14] = "COMM_BOARD"] = 14;
            values[valuesById[15] = "TEST_BOARD"] = 15;
            return values;
        })();

        /**
         * FirmwarePartition enum.
         * @name lebai.hardware.FirmwarePartition
         * @enum {number}
         * @property {number} A=0 A value
         * @property {number} B=1 B value
         * @property {number} C=2 C value
         * @property {number} UNKNOWN=3 UNKNOWN value
         */
        hardware.FirmwarePartition = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "A"] = 0;
            values[valuesById[1] = "B"] = 1;
            values[valuesById[2] = "C"] = 2;
            values[valuesById[3] = "UNKNOWN"] = 3;
            return values;
        })();

        hardware.FirmwareInfo = (function() {

            /**
             * Properties of a FirmwareInfo.
             * @memberof lebai.hardware
             * @interface IFirmwareInfo
             * @property {string|null} [sn] FirmwareInfo sn
             * @property {string|null} [version] FirmwareInfo version
             * @property {lebai.hardware.FirmwarePartition|null} [partition] FirmwareInfo partition
             */

            /**
             * Constructs a new FirmwareInfo.
             * @memberof lebai.hardware
             * @classdesc Represents a FirmwareInfo.
             * @implements IFirmwareInfo
             * @constructor
             * @param {lebai.hardware.IFirmwareInfo=} [properties] Properties to set
             */
            function FirmwareInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FirmwareInfo sn.
             * @member {string} sn
             * @memberof lebai.hardware.FirmwareInfo
             * @instance
             */
            FirmwareInfo.prototype.sn = "";

            /**
             * FirmwareInfo version.
             * @member {string} version
             * @memberof lebai.hardware.FirmwareInfo
             * @instance
             */
            FirmwareInfo.prototype.version = "";

            /**
             * FirmwareInfo partition.
             * @member {lebai.hardware.FirmwarePartition} partition
             * @memberof lebai.hardware.FirmwareInfo
             * @instance
             */
            FirmwareInfo.prototype.partition = 0;

            /**
             * Creates a new FirmwareInfo instance using the specified properties.
             * @function create
             * @memberof lebai.hardware.FirmwareInfo
             * @static
             * @param {lebai.hardware.IFirmwareInfo=} [properties] Properties to set
             * @returns {lebai.hardware.FirmwareInfo} FirmwareInfo instance
             */
            FirmwareInfo.create = function create(properties) {
                return new FirmwareInfo(properties);
            };

            /**
             * Encodes the specified FirmwareInfo message. Does not implicitly {@link lebai.hardware.FirmwareInfo.verify|verify} messages.
             * @function encode
             * @memberof lebai.hardware.FirmwareInfo
             * @static
             * @param {lebai.hardware.IFirmwareInfo} message FirmwareInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FirmwareInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sn != null && Object.hasOwnProperty.call(message, "sn"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.sn);
                if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.version);
                if (message.partition != null && Object.hasOwnProperty.call(message, "partition"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.partition);
                return writer;
            };

            /**
             * Encodes the specified FirmwareInfo message, length delimited. Does not implicitly {@link lebai.hardware.FirmwareInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.hardware.FirmwareInfo
             * @static
             * @param {lebai.hardware.IFirmwareInfo} message FirmwareInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FirmwareInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FirmwareInfo message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.hardware.FirmwareInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.hardware.FirmwareInfo} FirmwareInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FirmwareInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.hardware.FirmwareInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.sn = reader.string();
                            break;
                        }
                    case 2: {
                            message.version = reader.string();
                            break;
                        }
                    case 3: {
                            message.partition = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FirmwareInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.hardware.FirmwareInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.hardware.FirmwareInfo} FirmwareInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FirmwareInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FirmwareInfo message.
             * @function verify
             * @memberof lebai.hardware.FirmwareInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FirmwareInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sn != null && message.hasOwnProperty("sn"))
                    if (!$util.isString(message.sn))
                        return "sn: string expected";
                if (message.version != null && message.hasOwnProperty("version"))
                    if (!$util.isString(message.version))
                        return "version: string expected";
                if (message.partition != null && message.hasOwnProperty("partition"))
                    switch (message.partition) {
                    default:
                        return "partition: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                return null;
            };

            /**
             * Creates a FirmwareInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.hardware.FirmwareInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.hardware.FirmwareInfo} FirmwareInfo
             */
            FirmwareInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.hardware.FirmwareInfo)
                    return object;
                var message = new $root.lebai.hardware.FirmwareInfo();
                if (object.sn != null)
                    message.sn = String(object.sn);
                if (object.version != null)
                    message.version = String(object.version);
                switch (object.partition) {
                default:
                    if (typeof object.partition === "number") {
                        message.partition = object.partition;
                        break;
                    }
                    break;
                case "A":
                case 0:
                    message.partition = 0;
                    break;
                case "B":
                case 1:
                    message.partition = 1;
                    break;
                case "C":
                case 2:
                    message.partition = 2;
                    break;
                case "UNKNOWN":
                case 3:
                    message.partition = 3;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a FirmwareInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.hardware.FirmwareInfo
             * @static
             * @param {lebai.hardware.FirmwareInfo} message FirmwareInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FirmwareInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.sn = "";
                    object.version = "";
                    object.partition = options.enums === String ? "A" : 0;
                }
                if (message.sn != null && message.hasOwnProperty("sn"))
                    object.sn = message.sn;
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = message.version;
                if (message.partition != null && message.hasOwnProperty("partition"))
                    object.partition = options.enums === String ? $root.lebai.hardware.FirmwarePartition[message.partition] === undefined ? message.partition : $root.lebai.hardware.FirmwarePartition[message.partition] : message.partition;
                return object;
            };

            /**
             * Converts this FirmwareInfo to JSON.
             * @function toJSON
             * @memberof lebai.hardware.FirmwareInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FirmwareInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for FirmwareInfo
             * @function getTypeUrl
             * @memberof lebai.hardware.FirmwareInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            FirmwareInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.hardware.FirmwareInfo";
            };

            return FirmwareInfo;
        })();

        hardware.StartOtaRequest = (function() {

            /**
             * Properties of a StartOtaRequest.
             * @memberof lebai.hardware
             * @interface IStartOtaRequest
             * @property {lebai.hardware.Address|null} [address] StartOtaRequest address
             * @property {lebai.hardware.FirmwarePartition|null} [partition] StartOtaRequest partition
             * @property {string|null} [file] StartOtaRequest file
             */

            /**
             * Constructs a new StartOtaRequest.
             * @memberof lebai.hardware
             * @classdesc Represents a StartOtaRequest.
             * @implements IStartOtaRequest
             * @constructor
             * @param {lebai.hardware.IStartOtaRequest=} [properties] Properties to set
             */
            function StartOtaRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StartOtaRequest address.
             * @member {lebai.hardware.Address} address
             * @memberof lebai.hardware.StartOtaRequest
             * @instance
             */
            StartOtaRequest.prototype.address = 0;

            /**
             * StartOtaRequest partition.
             * @member {lebai.hardware.FirmwarePartition} partition
             * @memberof lebai.hardware.StartOtaRequest
             * @instance
             */
            StartOtaRequest.prototype.partition = 0;

            /**
             * StartOtaRequest file.
             * @member {string} file
             * @memberof lebai.hardware.StartOtaRequest
             * @instance
             */
            StartOtaRequest.prototype.file = "";

            /**
             * Creates a new StartOtaRequest instance using the specified properties.
             * @function create
             * @memberof lebai.hardware.StartOtaRequest
             * @static
             * @param {lebai.hardware.IStartOtaRequest=} [properties] Properties to set
             * @returns {lebai.hardware.StartOtaRequest} StartOtaRequest instance
             */
            StartOtaRequest.create = function create(properties) {
                return new StartOtaRequest(properties);
            };

            /**
             * Encodes the specified StartOtaRequest message. Does not implicitly {@link lebai.hardware.StartOtaRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.hardware.StartOtaRequest
             * @static
             * @param {lebai.hardware.IStartOtaRequest} message StartOtaRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StartOtaRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.address);
                if (message.partition != null && Object.hasOwnProperty.call(message, "partition"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.partition);
                if (message.file != null && Object.hasOwnProperty.call(message, "file"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.file);
                return writer;
            };

            /**
             * Encodes the specified StartOtaRequest message, length delimited. Does not implicitly {@link lebai.hardware.StartOtaRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.hardware.StartOtaRequest
             * @static
             * @param {lebai.hardware.IStartOtaRequest} message StartOtaRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StartOtaRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StartOtaRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.hardware.StartOtaRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.hardware.StartOtaRequest} StartOtaRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StartOtaRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.hardware.StartOtaRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.address = reader.int32();
                            break;
                        }
                    case 2: {
                            message.partition = reader.int32();
                            break;
                        }
                    case 11: {
                            message.file = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StartOtaRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.hardware.StartOtaRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.hardware.StartOtaRequest} StartOtaRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StartOtaRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StartOtaRequest message.
             * @function verify
             * @memberof lebai.hardware.StartOtaRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StartOtaRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.address != null && message.hasOwnProperty("address"))
                    switch (message.address) {
                    default:
                        return "address: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 13:
                    case 14:
                    case 15:
                        break;
                    }
                if (message.partition != null && message.hasOwnProperty("partition"))
                    switch (message.partition) {
                    default:
                        return "partition: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.file != null && message.hasOwnProperty("file"))
                    if (!$util.isString(message.file))
                        return "file: string expected";
                return null;
            };

            /**
             * Creates a StartOtaRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.hardware.StartOtaRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.hardware.StartOtaRequest} StartOtaRequest
             */
            StartOtaRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.hardware.StartOtaRequest)
                    return object;
                var message = new $root.lebai.hardware.StartOtaRequest();
                switch (object.address) {
                default:
                    if (typeof object.address === "number") {
                        message.address = object.address;
                        break;
                    }
                    break;
                case "EMPTY":
                case 0:
                    message.address = 0;
                    break;
                case "JOINT1":
                case 1:
                    message.address = 1;
                    break;
                case "JOINT2":
                case 2:
                    message.address = 2;
                    break;
                case "JOINT3":
                case 3:
                    message.address = 3;
                    break;
                case "JOINT4":
                case 4:
                    message.address = 4;
                    break;
                case "JOINT5":
                case 5:
                    message.address = 5;
                    break;
                case "JOINT6":
                case 6:
                    message.address = 6;
                    break;
                case "JOINT7":
                case 7:
                    message.address = 7;
                    break;
                case "FLANGE":
                case 8:
                    message.address = 8;
                    break;
                case "CLAW":
                case 9:
                    message.address = 9;
                    break;
                case "LED":
                case 10:
                    message.address = 10;
                    break;
                case "DIAL":
                case 13:
                    message.address = 13;
                    break;
                case "COMM_BOARD":
                case 14:
                    message.address = 14;
                    break;
                case "TEST_BOARD":
                case 15:
                    message.address = 15;
                    break;
                }
                switch (object.partition) {
                default:
                    if (typeof object.partition === "number") {
                        message.partition = object.partition;
                        break;
                    }
                    break;
                case "A":
                case 0:
                    message.partition = 0;
                    break;
                case "B":
                case 1:
                    message.partition = 1;
                    break;
                case "C":
                case 2:
                    message.partition = 2;
                    break;
                case "UNKNOWN":
                case 3:
                    message.partition = 3;
                    break;
                }
                if (object.file != null)
                    message.file = String(object.file);
                return message;
            };

            /**
             * Creates a plain object from a StartOtaRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.hardware.StartOtaRequest
             * @static
             * @param {lebai.hardware.StartOtaRequest} message StartOtaRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StartOtaRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.address = options.enums === String ? "EMPTY" : 0;
                    object.partition = options.enums === String ? "A" : 0;
                    object.file = "";
                }
                if (message.address != null && message.hasOwnProperty("address"))
                    object.address = options.enums === String ? $root.lebai.hardware.Address[message.address] === undefined ? message.address : $root.lebai.hardware.Address[message.address] : message.address;
                if (message.partition != null && message.hasOwnProperty("partition"))
                    object.partition = options.enums === String ? $root.lebai.hardware.FirmwarePartition[message.partition] === undefined ? message.partition : $root.lebai.hardware.FirmwarePartition[message.partition] : message.partition;
                if (message.file != null && message.hasOwnProperty("file"))
                    object.file = message.file;
                return object;
            };

            /**
             * Converts this StartOtaRequest to JSON.
             * @function toJSON
             * @memberof lebai.hardware.StartOtaRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StartOtaRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for StartOtaRequest
             * @function getTypeUrl
             * @memberof lebai.hardware.StartOtaRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            StartOtaRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.hardware.StartOtaRequest";
            };

            return StartOtaRequest;
        })();

        hardware.SwitchPartitionRequest = (function() {

            /**
             * Properties of a SwitchPartitionRequest.
             * @memberof lebai.hardware
             * @interface ISwitchPartitionRequest
             * @property {lebai.hardware.Address|null} [address] SwitchPartitionRequest address
             * @property {lebai.hardware.FirmwarePartition|null} [partition] SwitchPartitionRequest partition
             */

            /**
             * Constructs a new SwitchPartitionRequest.
             * @memberof lebai.hardware
             * @classdesc Represents a SwitchPartitionRequest.
             * @implements ISwitchPartitionRequest
             * @constructor
             * @param {lebai.hardware.ISwitchPartitionRequest=} [properties] Properties to set
             */
            function SwitchPartitionRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SwitchPartitionRequest address.
             * @member {lebai.hardware.Address} address
             * @memberof lebai.hardware.SwitchPartitionRequest
             * @instance
             */
            SwitchPartitionRequest.prototype.address = 0;

            /**
             * SwitchPartitionRequest partition.
             * @member {lebai.hardware.FirmwarePartition} partition
             * @memberof lebai.hardware.SwitchPartitionRequest
             * @instance
             */
            SwitchPartitionRequest.prototype.partition = 0;

            /**
             * Creates a new SwitchPartitionRequest instance using the specified properties.
             * @function create
             * @memberof lebai.hardware.SwitchPartitionRequest
             * @static
             * @param {lebai.hardware.ISwitchPartitionRequest=} [properties] Properties to set
             * @returns {lebai.hardware.SwitchPartitionRequest} SwitchPartitionRequest instance
             */
            SwitchPartitionRequest.create = function create(properties) {
                return new SwitchPartitionRequest(properties);
            };

            /**
             * Encodes the specified SwitchPartitionRequest message. Does not implicitly {@link lebai.hardware.SwitchPartitionRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.hardware.SwitchPartitionRequest
             * @static
             * @param {lebai.hardware.ISwitchPartitionRequest} message SwitchPartitionRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SwitchPartitionRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.address);
                if (message.partition != null && Object.hasOwnProperty.call(message, "partition"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.partition);
                return writer;
            };

            /**
             * Encodes the specified SwitchPartitionRequest message, length delimited. Does not implicitly {@link lebai.hardware.SwitchPartitionRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.hardware.SwitchPartitionRequest
             * @static
             * @param {lebai.hardware.ISwitchPartitionRequest} message SwitchPartitionRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SwitchPartitionRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SwitchPartitionRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.hardware.SwitchPartitionRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.hardware.SwitchPartitionRequest} SwitchPartitionRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SwitchPartitionRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.hardware.SwitchPartitionRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.address = reader.int32();
                            break;
                        }
                    case 2: {
                            message.partition = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SwitchPartitionRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.hardware.SwitchPartitionRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.hardware.SwitchPartitionRequest} SwitchPartitionRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SwitchPartitionRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SwitchPartitionRequest message.
             * @function verify
             * @memberof lebai.hardware.SwitchPartitionRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SwitchPartitionRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.address != null && message.hasOwnProperty("address"))
                    switch (message.address) {
                    default:
                        return "address: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 13:
                    case 14:
                    case 15:
                        break;
                    }
                if (message.partition != null && message.hasOwnProperty("partition"))
                    switch (message.partition) {
                    default:
                        return "partition: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                return null;
            };

            /**
             * Creates a SwitchPartitionRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.hardware.SwitchPartitionRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.hardware.SwitchPartitionRequest} SwitchPartitionRequest
             */
            SwitchPartitionRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.hardware.SwitchPartitionRequest)
                    return object;
                var message = new $root.lebai.hardware.SwitchPartitionRequest();
                switch (object.address) {
                default:
                    if (typeof object.address === "number") {
                        message.address = object.address;
                        break;
                    }
                    break;
                case "EMPTY":
                case 0:
                    message.address = 0;
                    break;
                case "JOINT1":
                case 1:
                    message.address = 1;
                    break;
                case "JOINT2":
                case 2:
                    message.address = 2;
                    break;
                case "JOINT3":
                case 3:
                    message.address = 3;
                    break;
                case "JOINT4":
                case 4:
                    message.address = 4;
                    break;
                case "JOINT5":
                case 5:
                    message.address = 5;
                    break;
                case "JOINT6":
                case 6:
                    message.address = 6;
                    break;
                case "JOINT7":
                case 7:
                    message.address = 7;
                    break;
                case "FLANGE":
                case 8:
                    message.address = 8;
                    break;
                case "CLAW":
                case 9:
                    message.address = 9;
                    break;
                case "LED":
                case 10:
                    message.address = 10;
                    break;
                case "DIAL":
                case 13:
                    message.address = 13;
                    break;
                case "COMM_BOARD":
                case 14:
                    message.address = 14;
                    break;
                case "TEST_BOARD":
                case 15:
                    message.address = 15;
                    break;
                }
                switch (object.partition) {
                default:
                    if (typeof object.partition === "number") {
                        message.partition = object.partition;
                        break;
                    }
                    break;
                case "A":
                case 0:
                    message.partition = 0;
                    break;
                case "B":
                case 1:
                    message.partition = 1;
                    break;
                case "C":
                case 2:
                    message.partition = 2;
                    break;
                case "UNKNOWN":
                case 3:
                    message.partition = 3;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a SwitchPartitionRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.hardware.SwitchPartitionRequest
             * @static
             * @param {lebai.hardware.SwitchPartitionRequest} message SwitchPartitionRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SwitchPartitionRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.address = options.enums === String ? "EMPTY" : 0;
                    object.partition = options.enums === String ? "A" : 0;
                }
                if (message.address != null && message.hasOwnProperty("address"))
                    object.address = options.enums === String ? $root.lebai.hardware.Address[message.address] === undefined ? message.address : $root.lebai.hardware.Address[message.address] : message.address;
                if (message.partition != null && message.hasOwnProperty("partition"))
                    object.partition = options.enums === String ? $root.lebai.hardware.FirmwarePartition[message.partition] === undefined ? message.partition : $root.lebai.hardware.FirmwarePartition[message.partition] : message.partition;
                return object;
            };

            /**
             * Converts this SwitchPartitionRequest to JSON.
             * @function toJSON
             * @memberof lebai.hardware.SwitchPartitionRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SwitchPartitionRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SwitchPartitionRequest
             * @function getTypeUrl
             * @memberof lebai.hardware.SwitchPartitionRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SwitchPartitionRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.hardware.SwitchPartitionRequest";
            };

            return SwitchPartitionRequest;
        })();

        /**
         * Step enum.
         * @name lebai.hardware.Step
         * @enum {number}
         * @property {number} NONE=0 NONE value
         * @property {number} WAIT=1 WAIT value
         * @property {number} DOWNLOADING=2 DOWNLOADING value
         * @property {number} FLASHING=3 FLASHING value
         * @property {number} DONE=4 DONE value
         * @property {number} FAIL=5 FAIL value
         * @property {number} RESTART=11 RESTART value
         */
        hardware.Step = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "NONE"] = 0;
            values[valuesById[1] = "WAIT"] = 1;
            values[valuesById[2] = "DOWNLOADING"] = 2;
            values[valuesById[3] = "FLASHING"] = 3;
            values[valuesById[4] = "DONE"] = 4;
            values[valuesById[5] = "FAIL"] = 5;
            values[valuesById[11] = "RESTART"] = 11;
            return values;
        })();

        hardware.OtaState = (function() {

            /**
             * Properties of an OtaState.
             * @memberof lebai.hardware
             * @interface IOtaState
             * @property {lebai.hardware.Step|null} [step] OtaState step
             * @property {number|null} [progress] OtaState progress
             */

            /**
             * Constructs a new OtaState.
             * @memberof lebai.hardware
             * @classdesc Represents an OtaState.
             * @implements IOtaState
             * @constructor
             * @param {lebai.hardware.IOtaState=} [properties] Properties to set
             */
            function OtaState(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * OtaState step.
             * @member {lebai.hardware.Step} step
             * @memberof lebai.hardware.OtaState
             * @instance
             */
            OtaState.prototype.step = 0;

            /**
             * OtaState progress.
             * @member {number} progress
             * @memberof lebai.hardware.OtaState
             * @instance
             */
            OtaState.prototype.progress = 0;

            /**
             * Creates a new OtaState instance using the specified properties.
             * @function create
             * @memberof lebai.hardware.OtaState
             * @static
             * @param {lebai.hardware.IOtaState=} [properties] Properties to set
             * @returns {lebai.hardware.OtaState} OtaState instance
             */
            OtaState.create = function create(properties) {
                return new OtaState(properties);
            };

            /**
             * Encodes the specified OtaState message. Does not implicitly {@link lebai.hardware.OtaState.verify|verify} messages.
             * @function encode
             * @memberof lebai.hardware.OtaState
             * @static
             * @param {lebai.hardware.IOtaState} message OtaState message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OtaState.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.step != null && Object.hasOwnProperty.call(message, "step"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.step);
                if (message.progress != null && Object.hasOwnProperty.call(message, "progress"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.progress);
                return writer;
            };

            /**
             * Encodes the specified OtaState message, length delimited. Does not implicitly {@link lebai.hardware.OtaState.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.hardware.OtaState
             * @static
             * @param {lebai.hardware.IOtaState} message OtaState message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OtaState.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an OtaState message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.hardware.OtaState
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.hardware.OtaState} OtaState
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OtaState.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.hardware.OtaState();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.step = reader.int32();
                            break;
                        }
                    case 2: {
                            message.progress = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an OtaState message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.hardware.OtaState
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.hardware.OtaState} OtaState
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OtaState.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an OtaState message.
             * @function verify
             * @memberof lebai.hardware.OtaState
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OtaState.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.step != null && message.hasOwnProperty("step"))
                    switch (message.step) {
                    default:
                        return "step: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 11:
                        break;
                    }
                if (message.progress != null && message.hasOwnProperty("progress"))
                    if (!$util.isInteger(message.progress))
                        return "progress: integer expected";
                return null;
            };

            /**
             * Creates an OtaState message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.hardware.OtaState
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.hardware.OtaState} OtaState
             */
            OtaState.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.hardware.OtaState)
                    return object;
                var message = new $root.lebai.hardware.OtaState();
                switch (object.step) {
                default:
                    if (typeof object.step === "number") {
                        message.step = object.step;
                        break;
                    }
                    break;
                case "NONE":
                case 0:
                    message.step = 0;
                    break;
                case "WAIT":
                case 1:
                    message.step = 1;
                    break;
                case "DOWNLOADING":
                case 2:
                    message.step = 2;
                    break;
                case "FLASHING":
                case 3:
                    message.step = 3;
                    break;
                case "DONE":
                case 4:
                    message.step = 4;
                    break;
                case "FAIL":
                case 5:
                    message.step = 5;
                    break;
                case "RESTART":
                case 11:
                    message.step = 11;
                    break;
                }
                if (object.progress != null)
                    message.progress = object.progress >>> 0;
                return message;
            };

            /**
             * Creates a plain object from an OtaState message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.hardware.OtaState
             * @static
             * @param {lebai.hardware.OtaState} message OtaState
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OtaState.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.step = options.enums === String ? "NONE" : 0;
                    object.progress = 0;
                }
                if (message.step != null && message.hasOwnProperty("step"))
                    object.step = options.enums === String ? $root.lebai.hardware.Step[message.step] === undefined ? message.step : $root.lebai.hardware.Step[message.step] : message.step;
                if (message.progress != null && message.hasOwnProperty("progress"))
                    object.progress = message.progress;
                return object;
            };

            /**
             * Converts this OtaState to JSON.
             * @function toJSON
             * @memberof lebai.hardware.OtaState
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OtaState.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for OtaState
             * @function getTypeUrl
             * @memberof lebai.hardware.OtaState
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            OtaState.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.hardware.OtaState";
            };

            return OtaState;
        })();

        hardware.HardwareService = (function() {

            /**
             * Constructs a new HardwareService service.
             * @memberof lebai.hardware
             * @classdesc Represents a HardwareService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function HardwareService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (HardwareService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = HardwareService;

            /**
             * Creates new HardwareService service using the specified rpc implementation.
             * @function create
             * @memberof lebai.hardware.HardwareService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {HardwareService} RPC service. Useful where requests and/or responses are streamed.
             */
            HardwareService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link lebai.hardware.HardwareService#startOta}.
             * @memberof lebai.hardware.HardwareService
             * @typedef StartOtaCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls StartOta.
             * @function startOta
             * @memberof lebai.hardware.HardwareService
             * @instance
             * @param {lebai.hardware.IStartOtaRequest} request StartOtaRequest message or plain object
             * @param {lebai.hardware.HardwareService.StartOtaCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(HardwareService.prototype.startOta = function startOta(request, callback) {
                return this.rpcCall(startOta, $root.lebai.hardware.StartOtaRequest, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "StartOta" });

            /**
             * Calls StartOta.
             * @function startOta
             * @memberof lebai.hardware.HardwareService
             * @instance
             * @param {lebai.hardware.IStartOtaRequest} request StartOtaRequest message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.hardware.HardwareService#switchPartition}.
             * @memberof lebai.hardware.HardwareService
             * @typedef SwitchPartitionCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls SwitchPartition.
             * @function switchPartition
             * @memberof lebai.hardware.HardwareService
             * @instance
             * @param {lebai.hardware.ISwitchPartitionRequest} request SwitchPartitionRequest message or plain object
             * @param {lebai.hardware.HardwareService.SwitchPartitionCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(HardwareService.prototype.switchPartition = function switchPartition(request, callback) {
                return this.rpcCall(switchPartition, $root.lebai.hardware.SwitchPartitionRequest, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "SwitchPartition" });

            /**
             * Calls SwitchPartition.
             * @function switchPartition
             * @memberof lebai.hardware.HardwareService
             * @instance
             * @param {lebai.hardware.ISwitchPartitionRequest} request SwitchPartitionRequest message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.hardware.HardwareService#getOtaState}.
             * @memberof lebai.hardware.HardwareService
             * @typedef GetOtaStateCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.hardware.OtaState} [response] OtaState
             */

            /**
             * Calls GetOtaState.
             * @function getOtaState
             * @memberof lebai.hardware.HardwareService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {lebai.hardware.HardwareService.GetOtaStateCallback} callback Node-style callback called with the error, if any, and OtaState
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(HardwareService.prototype.getOtaState = function getOtaState(request, callback) {
                return this.rpcCall(getOtaState, $root.google.protobuf.Empty, $root.lebai.hardware.OtaState, request, callback);
            }, "name", { value: "GetOtaState" });

            /**
             * Calls GetOtaState.
             * @function getOtaState
             * @memberof lebai.hardware.HardwareService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<lebai.hardware.OtaState>} Promise
             * @variation 2
             */

            return HardwareService;
        })();

        return hardware;
    })();

    lebai.claw = (function() {

        /**
         * Namespace claw.
         * @memberof lebai
         * @namespace
         */
        var claw = {};

        /**
         * Address enum.
         * @name lebai.claw.Address
         * @enum {number}
         * @property {number} AMPLITUDE=0 AMPLITUDE value
         * @property {number} FORCE=1 FORCE value
         * @property {number} VOLTAGE=2 VOLTAGE value
         * @property {number} DISTANCE=3 DISTANCE value
         * @property {number} DO=4 DO value
         * @property {number} ACTUAL_AMPLITUDE=5 ACTUAL_AMPLITUDE value
         * @property {number} ACTUAL_FORCE=6 ACTUAL_FORCE value
         * @property {number} WEIGHT=7 WEIGHT value
         * @property {number} INIT=8 INIT value
         * @property {number} FLAG=9 FLAG value
         * @property {number} ERROR=10 ERROR value
         * @property {number} DISABLE_INIT=90 DISABLE_INIT value
         */
        claw.Address = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "AMPLITUDE"] = 0;
            values[valuesById[1] = "FORCE"] = 1;
            values[valuesById[2] = "VOLTAGE"] = 2;
            values[valuesById[3] = "DISTANCE"] = 3;
            values[valuesById[4] = "DO"] = 4;
            values[valuesById[5] = "ACTUAL_AMPLITUDE"] = 5;
            values[valuesById[6] = "ACTUAL_FORCE"] = 6;
            values[valuesById[7] = "WEIGHT"] = 7;
            values[valuesById[8] = "INIT"] = 8;
            values[valuesById[9] = "FLAG"] = 9;
            values[valuesById[10] = "ERROR"] = 10;
            values[valuesById[90] = "DISABLE_INIT"] = 90;
            return values;
        })();

        claw.Claw = (function() {

            /**
             * Properties of a Claw.
             * @memberof lebai.claw
             * @interface IClaw
             * @property {number|null} [force] Claw force
             * @property {number|null} [amplitude] Claw amplitude
             * @property {number|null} [weight] Claw weight
             * @property {boolean|null} [holdOn] Claw holdOn
             */

            /**
             * Constructs a new Claw.
             * @memberof lebai.claw
             * @classdesc Represents a Claw.
             * @implements IClaw
             * @constructor
             * @param {lebai.claw.IClaw=} [properties] Properties to set
             */
            function Claw(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Claw force.
             * @member {number} force
             * @memberof lebai.claw.Claw
             * @instance
             */
            Claw.prototype.force = 0;

            /**
             * Claw amplitude.
             * @member {number} amplitude
             * @memberof lebai.claw.Claw
             * @instance
             */
            Claw.prototype.amplitude = 0;

            /**
             * Claw weight.
             * @member {number} weight
             * @memberof lebai.claw.Claw
             * @instance
             */
            Claw.prototype.weight = 0;

            /**
             * Claw holdOn.
             * @member {boolean} holdOn
             * @memberof lebai.claw.Claw
             * @instance
             */
            Claw.prototype.holdOn = false;

            /**
             * Creates a new Claw instance using the specified properties.
             * @function create
             * @memberof lebai.claw.Claw
             * @static
             * @param {lebai.claw.IClaw=} [properties] Properties to set
             * @returns {lebai.claw.Claw} Claw instance
             */
            Claw.create = function create(properties) {
                return new Claw(properties);
            };

            /**
             * Encodes the specified Claw message. Does not implicitly {@link lebai.claw.Claw.verify|verify} messages.
             * @function encode
             * @memberof lebai.claw.Claw
             * @static
             * @param {lebai.claw.IClaw} message Claw message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Claw.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.force != null && Object.hasOwnProperty.call(message, "force"))
                    writer.uint32(/* id 1, wireType 1 =*/9).double(message.force);
                if (message.amplitude != null && Object.hasOwnProperty.call(message, "amplitude"))
                    writer.uint32(/* id 2, wireType 1 =*/17).double(message.amplitude);
                if (message.weight != null && Object.hasOwnProperty.call(message, "weight"))
                    writer.uint32(/* id 3, wireType 1 =*/25).double(message.weight);
                if (message.holdOn != null && Object.hasOwnProperty.call(message, "holdOn"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.holdOn);
                return writer;
            };

            /**
             * Encodes the specified Claw message, length delimited. Does not implicitly {@link lebai.claw.Claw.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.claw.Claw
             * @static
             * @param {lebai.claw.IClaw} message Claw message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Claw.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Claw message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.claw.Claw
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.claw.Claw} Claw
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Claw.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.claw.Claw();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.force = reader.double();
                            break;
                        }
                    case 2: {
                            message.amplitude = reader.double();
                            break;
                        }
                    case 3: {
                            message.weight = reader.double();
                            break;
                        }
                    case 4: {
                            message.holdOn = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Claw message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.claw.Claw
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.claw.Claw} Claw
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Claw.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Claw message.
             * @function verify
             * @memberof lebai.claw.Claw
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Claw.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.force != null && message.hasOwnProperty("force"))
                    if (typeof message.force !== "number")
                        return "force: number expected";
                if (message.amplitude != null && message.hasOwnProperty("amplitude"))
                    if (typeof message.amplitude !== "number")
                        return "amplitude: number expected";
                if (message.weight != null && message.hasOwnProperty("weight"))
                    if (typeof message.weight !== "number")
                        return "weight: number expected";
                if (message.holdOn != null && message.hasOwnProperty("holdOn"))
                    if (typeof message.holdOn !== "boolean")
                        return "holdOn: boolean expected";
                return null;
            };

            /**
             * Creates a Claw message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.claw.Claw
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.claw.Claw} Claw
             */
            Claw.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.claw.Claw)
                    return object;
                var message = new $root.lebai.claw.Claw();
                if (object.force != null)
                    message.force = Number(object.force);
                if (object.amplitude != null)
                    message.amplitude = Number(object.amplitude);
                if (object.weight != null)
                    message.weight = Number(object.weight);
                if (object.holdOn != null)
                    message.holdOn = Boolean(object.holdOn);
                return message;
            };

            /**
             * Creates a plain object from a Claw message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.claw.Claw
             * @static
             * @param {lebai.claw.Claw} message Claw
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Claw.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.force = 0;
                    object.amplitude = 0;
                    object.weight = 0;
                    object.holdOn = false;
                }
                if (message.force != null && message.hasOwnProperty("force"))
                    object.force = options.json && !isFinite(message.force) ? String(message.force) : message.force;
                if (message.amplitude != null && message.hasOwnProperty("amplitude"))
                    object.amplitude = options.json && !isFinite(message.amplitude) ? String(message.amplitude) : message.amplitude;
                if (message.weight != null && message.hasOwnProperty("weight"))
                    object.weight = options.json && !isFinite(message.weight) ? String(message.weight) : message.weight;
                if (message.holdOn != null && message.hasOwnProperty("holdOn"))
                    object.holdOn = message.holdOn;
                return object;
            };

            /**
             * Converts this Claw to JSON.
             * @function toJSON
             * @memberof lebai.claw.Claw
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Claw.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Claw
             * @function getTypeUrl
             * @memberof lebai.claw.Claw
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Claw.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.claw.Claw";
            };

            return Claw;
        })();

        claw.InitClawRequest = (function() {

            /**
             * Properties of an InitClawRequest.
             * @memberof lebai.claw
             * @interface IInitClawRequest
             * @property {boolean|null} [force] InitClawRequest force
             */

            /**
             * Constructs a new InitClawRequest.
             * @memberof lebai.claw
             * @classdesc Represents an InitClawRequest.
             * @implements IInitClawRequest
             * @constructor
             * @param {lebai.claw.IInitClawRequest=} [properties] Properties to set
             */
            function InitClawRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * InitClawRequest force.
             * @member {boolean} force
             * @memberof lebai.claw.InitClawRequest
             * @instance
             */
            InitClawRequest.prototype.force = false;

            /**
             * Creates a new InitClawRequest instance using the specified properties.
             * @function create
             * @memberof lebai.claw.InitClawRequest
             * @static
             * @param {lebai.claw.IInitClawRequest=} [properties] Properties to set
             * @returns {lebai.claw.InitClawRequest} InitClawRequest instance
             */
            InitClawRequest.create = function create(properties) {
                return new InitClawRequest(properties);
            };

            /**
             * Encodes the specified InitClawRequest message. Does not implicitly {@link lebai.claw.InitClawRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.claw.InitClawRequest
             * @static
             * @param {lebai.claw.IInitClawRequest} message InitClawRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            InitClawRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.force != null && Object.hasOwnProperty.call(message, "force"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.force);
                return writer;
            };

            /**
             * Encodes the specified InitClawRequest message, length delimited. Does not implicitly {@link lebai.claw.InitClawRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.claw.InitClawRequest
             * @static
             * @param {lebai.claw.IInitClawRequest} message InitClawRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            InitClawRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an InitClawRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.claw.InitClawRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.claw.InitClawRequest} InitClawRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            InitClawRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.claw.InitClawRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.force = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an InitClawRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.claw.InitClawRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.claw.InitClawRequest} InitClawRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            InitClawRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an InitClawRequest message.
             * @function verify
             * @memberof lebai.claw.InitClawRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            InitClawRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.force != null && message.hasOwnProperty("force"))
                    if (typeof message.force !== "boolean")
                        return "force: boolean expected";
                return null;
            };

            /**
             * Creates an InitClawRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.claw.InitClawRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.claw.InitClawRequest} InitClawRequest
             */
            InitClawRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.claw.InitClawRequest)
                    return object;
                var message = new $root.lebai.claw.InitClawRequest();
                if (object.force != null)
                    message.force = Boolean(object.force);
                return message;
            };

            /**
             * Creates a plain object from an InitClawRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.claw.InitClawRequest
             * @static
             * @param {lebai.claw.InitClawRequest} message InitClawRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            InitClawRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.force = false;
                if (message.force != null && message.hasOwnProperty("force"))
                    object.force = message.force;
                return object;
            };

            /**
             * Converts this InitClawRequest to JSON.
             * @function toJSON
             * @memberof lebai.claw.InitClawRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            InitClawRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for InitClawRequest
             * @function getTypeUrl
             * @memberof lebai.claw.InitClawRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            InitClawRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.claw.InitClawRequest";
            };

            return InitClawRequest;
        })();

        claw.SetClawRequest = (function() {

            /**
             * Properties of a SetClawRequest.
             * @memberof lebai.claw
             * @interface ISetClawRequest
             * @property {number|null} [force] SetClawRequest force
             * @property {number|null} [amplitude] SetClawRequest amplitude
             */

            /**
             * Constructs a new SetClawRequest.
             * @memberof lebai.claw
             * @classdesc Represents a SetClawRequest.
             * @implements ISetClawRequest
             * @constructor
             * @param {lebai.claw.ISetClawRequest=} [properties] Properties to set
             */
            function SetClawRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SetClawRequest force.
             * @member {number|null|undefined} force
             * @memberof lebai.claw.SetClawRequest
             * @instance
             */
            SetClawRequest.prototype.force = null;

            /**
             * SetClawRequest amplitude.
             * @member {number|null|undefined} amplitude
             * @memberof lebai.claw.SetClawRequest
             * @instance
             */
            SetClawRequest.prototype.amplitude = null;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * SetClawRequest _force.
             * @member {"force"|undefined} _force
             * @memberof lebai.claw.SetClawRequest
             * @instance
             */
            Object.defineProperty(SetClawRequest.prototype, "_force", {
                get: $util.oneOfGetter($oneOfFields = ["force"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * SetClawRequest _amplitude.
             * @member {"amplitude"|undefined} _amplitude
             * @memberof lebai.claw.SetClawRequest
             * @instance
             */
            Object.defineProperty(SetClawRequest.prototype, "_amplitude", {
                get: $util.oneOfGetter($oneOfFields = ["amplitude"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new SetClawRequest instance using the specified properties.
             * @function create
             * @memberof lebai.claw.SetClawRequest
             * @static
             * @param {lebai.claw.ISetClawRequest=} [properties] Properties to set
             * @returns {lebai.claw.SetClawRequest} SetClawRequest instance
             */
            SetClawRequest.create = function create(properties) {
                return new SetClawRequest(properties);
            };

            /**
             * Encodes the specified SetClawRequest message. Does not implicitly {@link lebai.claw.SetClawRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.claw.SetClawRequest
             * @static
             * @param {lebai.claw.ISetClawRequest} message SetClawRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetClawRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.force != null && Object.hasOwnProperty.call(message, "force"))
                    writer.uint32(/* id 1, wireType 1 =*/9).double(message.force);
                if (message.amplitude != null && Object.hasOwnProperty.call(message, "amplitude"))
                    writer.uint32(/* id 2, wireType 1 =*/17).double(message.amplitude);
                return writer;
            };

            /**
             * Encodes the specified SetClawRequest message, length delimited. Does not implicitly {@link lebai.claw.SetClawRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.claw.SetClawRequest
             * @static
             * @param {lebai.claw.ISetClawRequest} message SetClawRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetClawRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetClawRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.claw.SetClawRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.claw.SetClawRequest} SetClawRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetClawRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.claw.SetClawRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.force = reader.double();
                            break;
                        }
                    case 2: {
                            message.amplitude = reader.double();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetClawRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.claw.SetClawRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.claw.SetClawRequest} SetClawRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetClawRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetClawRequest message.
             * @function verify
             * @memberof lebai.claw.SetClawRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetClawRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.force != null && message.hasOwnProperty("force")) {
                    properties._force = 1;
                    if (typeof message.force !== "number")
                        return "force: number expected";
                }
                if (message.amplitude != null && message.hasOwnProperty("amplitude")) {
                    properties._amplitude = 1;
                    if (typeof message.amplitude !== "number")
                        return "amplitude: number expected";
                }
                return null;
            };

            /**
             * Creates a SetClawRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.claw.SetClawRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.claw.SetClawRequest} SetClawRequest
             */
            SetClawRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.claw.SetClawRequest)
                    return object;
                var message = new $root.lebai.claw.SetClawRequest();
                if (object.force != null)
                    message.force = Number(object.force);
                if (object.amplitude != null)
                    message.amplitude = Number(object.amplitude);
                return message;
            };

            /**
             * Creates a plain object from a SetClawRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.claw.SetClawRequest
             * @static
             * @param {lebai.claw.SetClawRequest} message SetClawRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetClawRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.force != null && message.hasOwnProperty("force")) {
                    object.force = options.json && !isFinite(message.force) ? String(message.force) : message.force;
                    if (options.oneofs)
                        object._force = "force";
                }
                if (message.amplitude != null && message.hasOwnProperty("amplitude")) {
                    object.amplitude = options.json && !isFinite(message.amplitude) ? String(message.amplitude) : message.amplitude;
                    if (options.oneofs)
                        object._amplitude = "amplitude";
                }
                return object;
            };

            /**
             * Converts this SetClawRequest to JSON.
             * @function toJSON
             * @memberof lebai.claw.SetClawRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetClawRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetClawRequest
             * @function getTypeUrl
             * @memberof lebai.claw.SetClawRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetClawRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.claw.SetClawRequest";
            };

            return SetClawRequest;
        })();

        claw.SetClawAoRequest = (function() {

            /**
             * Properties of a SetClawAoRequest.
             * @memberof lebai.claw
             * @interface ISetClawAoRequest
             * @property {lebai.claw.Address|null} [address] SetClawAoRequest address
             * @property {number|null} [value] SetClawAoRequest value
             */

            /**
             * Constructs a new SetClawAoRequest.
             * @memberof lebai.claw
             * @classdesc Represents a SetClawAoRequest.
             * @implements ISetClawAoRequest
             * @constructor
             * @param {lebai.claw.ISetClawAoRequest=} [properties] Properties to set
             */
            function SetClawAoRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SetClawAoRequest address.
             * @member {lebai.claw.Address} address
             * @memberof lebai.claw.SetClawAoRequest
             * @instance
             */
            SetClawAoRequest.prototype.address = 0;

            /**
             * SetClawAoRequest value.
             * @member {number} value
             * @memberof lebai.claw.SetClawAoRequest
             * @instance
             */
            SetClawAoRequest.prototype.value = 0;

            /**
             * Creates a new SetClawAoRequest instance using the specified properties.
             * @function create
             * @memberof lebai.claw.SetClawAoRequest
             * @static
             * @param {lebai.claw.ISetClawAoRequest=} [properties] Properties to set
             * @returns {lebai.claw.SetClawAoRequest} SetClawAoRequest instance
             */
            SetClawAoRequest.create = function create(properties) {
                return new SetClawAoRequest(properties);
            };

            /**
             * Encodes the specified SetClawAoRequest message. Does not implicitly {@link lebai.claw.SetClawAoRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.claw.SetClawAoRequest
             * @static
             * @param {lebai.claw.ISetClawAoRequest} message SetClawAoRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetClawAoRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.address);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 2, wireType 1 =*/17).double(message.value);
                return writer;
            };

            /**
             * Encodes the specified SetClawAoRequest message, length delimited. Does not implicitly {@link lebai.claw.SetClawAoRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.claw.SetClawAoRequest
             * @static
             * @param {lebai.claw.ISetClawAoRequest} message SetClawAoRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetClawAoRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetClawAoRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.claw.SetClawAoRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.claw.SetClawAoRequest} SetClawAoRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetClawAoRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.claw.SetClawAoRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.address = reader.int32();
                            break;
                        }
                    case 2: {
                            message.value = reader.double();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetClawAoRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.claw.SetClawAoRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.claw.SetClawAoRequest} SetClawAoRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetClawAoRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetClawAoRequest message.
             * @function verify
             * @memberof lebai.claw.SetClawAoRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetClawAoRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.address != null && message.hasOwnProperty("address"))
                    switch (message.address) {
                    default:
                        return "address: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 90:
                        break;
                    }
                if (message.value != null && message.hasOwnProperty("value"))
                    if (typeof message.value !== "number")
                        return "value: number expected";
                return null;
            };

            /**
             * Creates a SetClawAoRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.claw.SetClawAoRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.claw.SetClawAoRequest} SetClawAoRequest
             */
            SetClawAoRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.claw.SetClawAoRequest)
                    return object;
                var message = new $root.lebai.claw.SetClawAoRequest();
                switch (object.address) {
                default:
                    if (typeof object.address === "number") {
                        message.address = object.address;
                        break;
                    }
                    break;
                case "AMPLITUDE":
                case 0:
                    message.address = 0;
                    break;
                case "FORCE":
                case 1:
                    message.address = 1;
                    break;
                case "VOLTAGE":
                case 2:
                    message.address = 2;
                    break;
                case "DISTANCE":
                case 3:
                    message.address = 3;
                    break;
                case "DO":
                case 4:
                    message.address = 4;
                    break;
                case "ACTUAL_AMPLITUDE":
                case 5:
                    message.address = 5;
                    break;
                case "ACTUAL_FORCE":
                case 6:
                    message.address = 6;
                    break;
                case "WEIGHT":
                case 7:
                    message.address = 7;
                    break;
                case "INIT":
                case 8:
                    message.address = 8;
                    break;
                case "FLAG":
                case 9:
                    message.address = 9;
                    break;
                case "ERROR":
                case 10:
                    message.address = 10;
                    break;
                case "DISABLE_INIT":
                case 90:
                    message.address = 90;
                    break;
                }
                if (object.value != null)
                    message.value = Number(object.value);
                return message;
            };

            /**
             * Creates a plain object from a SetClawAoRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.claw.SetClawAoRequest
             * @static
             * @param {lebai.claw.SetClawAoRequest} message SetClawAoRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetClawAoRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.address = options.enums === String ? "AMPLITUDE" : 0;
                    object.value = 0;
                }
                if (message.address != null && message.hasOwnProperty("address"))
                    object.address = options.enums === String ? $root.lebai.claw.Address[message.address] === undefined ? message.address : $root.lebai.claw.Address[message.address] : message.address;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
                return object;
            };

            /**
             * Converts this SetClawAoRequest to JSON.
             * @function toJSON
             * @memberof lebai.claw.SetClawAoRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetClawAoRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetClawAoRequest
             * @function getTypeUrl
             * @memberof lebai.claw.SetClawAoRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetClawAoRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.claw.SetClawAoRequest";
            };

            return SetClawAoRequest;
        })();

        claw.GetClawAiRequest = (function() {

            /**
             * Properties of a GetClawAiRequest.
             * @memberof lebai.claw
             * @interface IGetClawAiRequest
             * @property {lebai.claw.Address|null} [address] GetClawAiRequest address
             */

            /**
             * Constructs a new GetClawAiRequest.
             * @memberof lebai.claw
             * @classdesc Represents a GetClawAiRequest.
             * @implements IGetClawAiRequest
             * @constructor
             * @param {lebai.claw.IGetClawAiRequest=} [properties] Properties to set
             */
            function GetClawAiRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetClawAiRequest address.
             * @member {lebai.claw.Address} address
             * @memberof lebai.claw.GetClawAiRequest
             * @instance
             */
            GetClawAiRequest.prototype.address = 0;

            /**
             * Creates a new GetClawAiRequest instance using the specified properties.
             * @function create
             * @memberof lebai.claw.GetClawAiRequest
             * @static
             * @param {lebai.claw.IGetClawAiRequest=} [properties] Properties to set
             * @returns {lebai.claw.GetClawAiRequest} GetClawAiRequest instance
             */
            GetClawAiRequest.create = function create(properties) {
                return new GetClawAiRequest(properties);
            };

            /**
             * Encodes the specified GetClawAiRequest message. Does not implicitly {@link lebai.claw.GetClawAiRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.claw.GetClawAiRequest
             * @static
             * @param {lebai.claw.IGetClawAiRequest} message GetClawAiRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetClawAiRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.address);
                return writer;
            };

            /**
             * Encodes the specified GetClawAiRequest message, length delimited. Does not implicitly {@link lebai.claw.GetClawAiRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.claw.GetClawAiRequest
             * @static
             * @param {lebai.claw.IGetClawAiRequest} message GetClawAiRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetClawAiRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetClawAiRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.claw.GetClawAiRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.claw.GetClawAiRequest} GetClawAiRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetClawAiRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.claw.GetClawAiRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.address = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetClawAiRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.claw.GetClawAiRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.claw.GetClawAiRequest} GetClawAiRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetClawAiRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetClawAiRequest message.
             * @function verify
             * @memberof lebai.claw.GetClawAiRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetClawAiRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.address != null && message.hasOwnProperty("address"))
                    switch (message.address) {
                    default:
                        return "address: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 90:
                        break;
                    }
                return null;
            };

            /**
             * Creates a GetClawAiRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.claw.GetClawAiRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.claw.GetClawAiRequest} GetClawAiRequest
             */
            GetClawAiRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.claw.GetClawAiRequest)
                    return object;
                var message = new $root.lebai.claw.GetClawAiRequest();
                switch (object.address) {
                default:
                    if (typeof object.address === "number") {
                        message.address = object.address;
                        break;
                    }
                    break;
                case "AMPLITUDE":
                case 0:
                    message.address = 0;
                    break;
                case "FORCE":
                case 1:
                    message.address = 1;
                    break;
                case "VOLTAGE":
                case 2:
                    message.address = 2;
                    break;
                case "DISTANCE":
                case 3:
                    message.address = 3;
                    break;
                case "DO":
                case 4:
                    message.address = 4;
                    break;
                case "ACTUAL_AMPLITUDE":
                case 5:
                    message.address = 5;
                    break;
                case "ACTUAL_FORCE":
                case 6:
                    message.address = 6;
                    break;
                case "WEIGHT":
                case 7:
                    message.address = 7;
                    break;
                case "INIT":
                case 8:
                    message.address = 8;
                    break;
                case "FLAG":
                case 9:
                    message.address = 9;
                    break;
                case "ERROR":
                case 10:
                    message.address = 10;
                    break;
                case "DISABLE_INIT":
                case 90:
                    message.address = 90;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a GetClawAiRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.claw.GetClawAiRequest
             * @static
             * @param {lebai.claw.GetClawAiRequest} message GetClawAiRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetClawAiRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.address = options.enums === String ? "AMPLITUDE" : 0;
                if (message.address != null && message.hasOwnProperty("address"))
                    object.address = options.enums === String ? $root.lebai.claw.Address[message.address] === undefined ? message.address : $root.lebai.claw.Address[message.address] : message.address;
                return object;
            };

            /**
             * Converts this GetClawAiRequest to JSON.
             * @function toJSON
             * @memberof lebai.claw.GetClawAiRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetClawAiRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetClawAiRequest
             * @function getTypeUrl
             * @memberof lebai.claw.GetClawAiRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetClawAiRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.claw.GetClawAiRequest";
            };

            return GetClawAiRequest;
        })();

        claw.GetClawAiResponse = (function() {

            /**
             * Properties of a GetClawAiResponse.
             * @memberof lebai.claw
             * @interface IGetClawAiResponse
             * @property {number|null} [value] GetClawAiResponse value
             */

            /**
             * Constructs a new GetClawAiResponse.
             * @memberof lebai.claw
             * @classdesc Represents a GetClawAiResponse.
             * @implements IGetClawAiResponse
             * @constructor
             * @param {lebai.claw.IGetClawAiResponse=} [properties] Properties to set
             */
            function GetClawAiResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetClawAiResponse value.
             * @member {number} value
             * @memberof lebai.claw.GetClawAiResponse
             * @instance
             */
            GetClawAiResponse.prototype.value = 0;

            /**
             * Creates a new GetClawAiResponse instance using the specified properties.
             * @function create
             * @memberof lebai.claw.GetClawAiResponse
             * @static
             * @param {lebai.claw.IGetClawAiResponse=} [properties] Properties to set
             * @returns {lebai.claw.GetClawAiResponse} GetClawAiResponse instance
             */
            GetClawAiResponse.create = function create(properties) {
                return new GetClawAiResponse(properties);
            };

            /**
             * Encodes the specified GetClawAiResponse message. Does not implicitly {@link lebai.claw.GetClawAiResponse.verify|verify} messages.
             * @function encode
             * @memberof lebai.claw.GetClawAiResponse
             * @static
             * @param {lebai.claw.IGetClawAiResponse} message GetClawAiResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetClawAiResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 2, wireType 1 =*/17).double(message.value);
                return writer;
            };

            /**
             * Encodes the specified GetClawAiResponse message, length delimited. Does not implicitly {@link lebai.claw.GetClawAiResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.claw.GetClawAiResponse
             * @static
             * @param {lebai.claw.IGetClawAiResponse} message GetClawAiResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetClawAiResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetClawAiResponse message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.claw.GetClawAiResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.claw.GetClawAiResponse} GetClawAiResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetClawAiResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.claw.GetClawAiResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2: {
                            message.value = reader.double();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetClawAiResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.claw.GetClawAiResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.claw.GetClawAiResponse} GetClawAiResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetClawAiResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetClawAiResponse message.
             * @function verify
             * @memberof lebai.claw.GetClawAiResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetClawAiResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (typeof message.value !== "number")
                        return "value: number expected";
                return null;
            };

            /**
             * Creates a GetClawAiResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.claw.GetClawAiResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.claw.GetClawAiResponse} GetClawAiResponse
             */
            GetClawAiResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.claw.GetClawAiResponse)
                    return object;
                var message = new $root.lebai.claw.GetClawAiResponse();
                if (object.value != null)
                    message.value = Number(object.value);
                return message;
            };

            /**
             * Creates a plain object from a GetClawAiResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.claw.GetClawAiResponse
             * @static
             * @param {lebai.claw.GetClawAiResponse} message GetClawAiResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetClawAiResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.value = 0;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
                return object;
            };

            /**
             * Converts this GetClawAiResponse to JSON.
             * @function toJSON
             * @memberof lebai.claw.GetClawAiResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetClawAiResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetClawAiResponse
             * @function getTypeUrl
             * @memberof lebai.claw.GetClawAiResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetClawAiResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.claw.GetClawAiResponse";
            };

            return GetClawAiResponse;
        })();

        claw.WaitClawAiRequest = (function() {

            /**
             * Properties of a WaitClawAiRequest.
             * @memberof lebai.claw
             * @interface IWaitClawAiRequest
             * @property {lebai.claw.Address|null} [address] WaitClawAiRequest address
             * @property {number|null} [value] WaitClawAiRequest value
             * @property {lebai.cmp.Relation|null} [relation] WaitClawAiRequest relation
             */

            /**
             * Constructs a new WaitClawAiRequest.
             * @memberof lebai.claw
             * @classdesc Represents a WaitClawAiRequest.
             * @implements IWaitClawAiRequest
             * @constructor
             * @param {lebai.claw.IWaitClawAiRequest=} [properties] Properties to set
             */
            function WaitClawAiRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WaitClawAiRequest address.
             * @member {lebai.claw.Address} address
             * @memberof lebai.claw.WaitClawAiRequest
             * @instance
             */
            WaitClawAiRequest.prototype.address = 0;

            /**
             * WaitClawAiRequest value.
             * @member {number} value
             * @memberof lebai.claw.WaitClawAiRequest
             * @instance
             */
            WaitClawAiRequest.prototype.value = 0;

            /**
             * WaitClawAiRequest relation.
             * @member {lebai.cmp.Relation} relation
             * @memberof lebai.claw.WaitClawAiRequest
             * @instance
             */
            WaitClawAiRequest.prototype.relation = 0;

            /**
             * Creates a new WaitClawAiRequest instance using the specified properties.
             * @function create
             * @memberof lebai.claw.WaitClawAiRequest
             * @static
             * @param {lebai.claw.IWaitClawAiRequest=} [properties] Properties to set
             * @returns {lebai.claw.WaitClawAiRequest} WaitClawAiRequest instance
             */
            WaitClawAiRequest.create = function create(properties) {
                return new WaitClawAiRequest(properties);
            };

            /**
             * Encodes the specified WaitClawAiRequest message. Does not implicitly {@link lebai.claw.WaitClawAiRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.claw.WaitClawAiRequest
             * @static
             * @param {lebai.claw.IWaitClawAiRequest} message WaitClawAiRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WaitClawAiRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.address);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 2, wireType 1 =*/17).double(message.value);
                if (message.relation != null && Object.hasOwnProperty.call(message, "relation"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.relation);
                return writer;
            };

            /**
             * Encodes the specified WaitClawAiRequest message, length delimited. Does not implicitly {@link lebai.claw.WaitClawAiRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.claw.WaitClawAiRequest
             * @static
             * @param {lebai.claw.IWaitClawAiRequest} message WaitClawAiRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WaitClawAiRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WaitClawAiRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.claw.WaitClawAiRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.claw.WaitClawAiRequest} WaitClawAiRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WaitClawAiRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.claw.WaitClawAiRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.address = reader.int32();
                            break;
                        }
                    case 2: {
                            message.value = reader.double();
                            break;
                        }
                    case 3: {
                            message.relation = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WaitClawAiRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.claw.WaitClawAiRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.claw.WaitClawAiRequest} WaitClawAiRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WaitClawAiRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WaitClawAiRequest message.
             * @function verify
             * @memberof lebai.claw.WaitClawAiRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WaitClawAiRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.address != null && message.hasOwnProperty("address"))
                    switch (message.address) {
                    default:
                        return "address: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 90:
                        break;
                    }
                if (message.value != null && message.hasOwnProperty("value"))
                    if (typeof message.value !== "number")
                        return "value: number expected";
                if (message.relation != null && message.hasOwnProperty("relation"))
                    switch (message.relation) {
                    default:
                        return "relation: enum value expected";
                    case 0:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                        break;
                    }
                return null;
            };

            /**
             * Creates a WaitClawAiRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.claw.WaitClawAiRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.claw.WaitClawAiRequest} WaitClawAiRequest
             */
            WaitClawAiRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.claw.WaitClawAiRequest)
                    return object;
                var message = new $root.lebai.claw.WaitClawAiRequest();
                switch (object.address) {
                default:
                    if (typeof object.address === "number") {
                        message.address = object.address;
                        break;
                    }
                    break;
                case "AMPLITUDE":
                case 0:
                    message.address = 0;
                    break;
                case "FORCE":
                case 1:
                    message.address = 1;
                    break;
                case "VOLTAGE":
                case 2:
                    message.address = 2;
                    break;
                case "DISTANCE":
                case 3:
                    message.address = 3;
                    break;
                case "DO":
                case 4:
                    message.address = 4;
                    break;
                case "ACTUAL_AMPLITUDE":
                case 5:
                    message.address = 5;
                    break;
                case "ACTUAL_FORCE":
                case 6:
                    message.address = 6;
                    break;
                case "WEIGHT":
                case 7:
                    message.address = 7;
                    break;
                case "INIT":
                case 8:
                    message.address = 8;
                    break;
                case "FLAG":
                case 9:
                    message.address = 9;
                    break;
                case "ERROR":
                case 10:
                    message.address = 10;
                    break;
                case "DISABLE_INIT":
                case 90:
                    message.address = 90;
                    break;
                }
                if (object.value != null)
                    message.value = Number(object.value);
                switch (object.relation) {
                default:
                    if (typeof object.relation === "number") {
                        message.relation = object.relation;
                        break;
                    }
                    break;
                case "EQ":
                case 0:
                    message.relation = 0;
                    break;
                case "NEQ":
                case 2:
                    message.relation = 2;
                    break;
                case "LT":
                case 3:
                    message.relation = 3;
                    break;
                case "LTE":
                case 4:
                    message.relation = 4;
                    break;
                case "GT":
                case 5:
                    message.relation = 5;
                    break;
                case "GTE":
                case 6:
                    message.relation = 6;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a WaitClawAiRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.claw.WaitClawAiRequest
             * @static
             * @param {lebai.claw.WaitClawAiRequest} message WaitClawAiRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WaitClawAiRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.address = options.enums === String ? "AMPLITUDE" : 0;
                    object.value = 0;
                    object.relation = options.enums === String ? "EQ" : 0;
                }
                if (message.address != null && message.hasOwnProperty("address"))
                    object.address = options.enums === String ? $root.lebai.claw.Address[message.address] === undefined ? message.address : $root.lebai.claw.Address[message.address] : message.address;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
                if (message.relation != null && message.hasOwnProperty("relation"))
                    object.relation = options.enums === String ? $root.lebai.cmp.Relation[message.relation] === undefined ? message.relation : $root.lebai.cmp.Relation[message.relation] : message.relation;
                return object;
            };

            /**
             * Converts this WaitClawAiRequest to JSON.
             * @function toJSON
             * @memberof lebai.claw.WaitClawAiRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WaitClawAiRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for WaitClawAiRequest
             * @function getTypeUrl
             * @memberof lebai.claw.WaitClawAiRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            WaitClawAiRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.claw.WaitClawAiRequest";
            };

            return WaitClawAiRequest;
        })();

        claw.ClawService = (function() {

            /**
             * Constructs a new ClawService service.
             * @memberof lebai.claw
             * @classdesc Represents a ClawService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function ClawService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (ClawService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = ClawService;

            /**
             * Creates new ClawService service using the specified rpc implementation.
             * @function create
             * @memberof lebai.claw.ClawService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {ClawService} RPC service. Useful where requests and/or responses are streamed.
             */
            ClawService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link lebai.claw.ClawService#initClaw}.
             * @memberof lebai.claw.ClawService
             * @typedef InitClawCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls InitClaw.
             * @function initClaw
             * @memberof lebai.claw.ClawService
             * @instance
             * @param {lebai.claw.IInitClawRequest} request InitClawRequest message or plain object
             * @param {lebai.claw.ClawService.InitClawCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ClawService.prototype.initClaw = function initClaw(request, callback) {
                return this.rpcCall(initClaw, $root.lebai.claw.InitClawRequest, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "InitClaw" });

            /**
             * Calls InitClaw.
             * @function initClaw
             * @memberof lebai.claw.ClawService
             * @instance
             * @param {lebai.claw.IInitClawRequest} request InitClawRequest message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.claw.ClawService#setClaw}.
             * @memberof lebai.claw.ClawService
             * @typedef SetClawCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls SetClaw.
             * @function setClaw
             * @memberof lebai.claw.ClawService
             * @instance
             * @param {lebai.claw.ISetClawRequest} request SetClawRequest message or plain object
             * @param {lebai.claw.ClawService.SetClawCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ClawService.prototype.setClaw = function setClaw(request, callback) {
                return this.rpcCall(setClaw, $root.lebai.claw.SetClawRequest, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "SetClaw" });

            /**
             * Calls SetClaw.
             * @function setClaw
             * @memberof lebai.claw.ClawService
             * @instance
             * @param {lebai.claw.ISetClawRequest} request SetClawRequest message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.claw.ClawService#getClaw}.
             * @memberof lebai.claw.ClawService
             * @typedef GetClawCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.claw.Claw} [response] Claw
             */

            /**
             * Calls GetClaw.
             * @function getClaw
             * @memberof lebai.claw.ClawService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {lebai.claw.ClawService.GetClawCallback} callback Node-style callback called with the error, if any, and Claw
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ClawService.prototype.getClaw = function getClaw(request, callback) {
                return this.rpcCall(getClaw, $root.google.protobuf.Empty, $root.lebai.claw.Claw, request, callback);
            }, "name", { value: "GetClaw" });

            /**
             * Calls GetClaw.
             * @function getClaw
             * @memberof lebai.claw.ClawService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<lebai.claw.Claw>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.claw.ClawService#setClawAo}.
             * @memberof lebai.claw.ClawService
             * @typedef SetClawAoCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls SetClawAo.
             * @function setClawAo
             * @memberof lebai.claw.ClawService
             * @instance
             * @param {lebai.claw.ISetClawAoRequest} request SetClawAoRequest message or plain object
             * @param {lebai.claw.ClawService.SetClawAoCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ClawService.prototype.setClawAo = function setClawAo(request, callback) {
                return this.rpcCall(setClawAo, $root.lebai.claw.SetClawAoRequest, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "SetClawAo" });

            /**
             * Calls SetClawAo.
             * @function setClawAo
             * @memberof lebai.claw.ClawService
             * @instance
             * @param {lebai.claw.ISetClawAoRequest} request SetClawAoRequest message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.claw.ClawService#getClawAi}.
             * @memberof lebai.claw.ClawService
             * @typedef GetClawAiCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.claw.GetClawAiResponse} [response] GetClawAiResponse
             */

            /**
             * Calls GetClawAi.
             * @function getClawAi
             * @memberof lebai.claw.ClawService
             * @instance
             * @param {lebai.claw.IGetClawAiRequest} request GetClawAiRequest message or plain object
             * @param {lebai.claw.ClawService.GetClawAiCallback} callback Node-style callback called with the error, if any, and GetClawAiResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ClawService.prototype.getClawAi = function getClawAi(request, callback) {
                return this.rpcCall(getClawAi, $root.lebai.claw.GetClawAiRequest, $root.lebai.claw.GetClawAiResponse, request, callback);
            }, "name", { value: "GetClawAi" });

            /**
             * Calls GetClawAi.
             * @function getClawAi
             * @memberof lebai.claw.ClawService
             * @instance
             * @param {lebai.claw.IGetClawAiRequest} request GetClawAiRequest message or plain object
             * @returns {Promise<lebai.claw.GetClawAiResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.claw.ClawService#waitClawAi}.
             * @memberof lebai.claw.ClawService
             * @typedef WaitClawAiCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls WaitClawAi.
             * @function waitClawAi
             * @memberof lebai.claw.ClawService
             * @instance
             * @param {lebai.claw.IWaitClawAiRequest} request WaitClawAiRequest message or plain object
             * @param {lebai.claw.ClawService.WaitClawAiCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ClawService.prototype.waitClawAi = function waitClawAi(request, callback) {
                return this.rpcCall(waitClawAi, $root.lebai.claw.WaitClawAiRequest, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "WaitClawAi" });

            /**
             * Calls WaitClawAi.
             * @function waitClawAi
             * @memberof lebai.claw.ClawService
             * @instance
             * @param {lebai.claw.IWaitClawAiRequest} request WaitClawAiRequest message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            return ClawService;
        })();

        return claw;
    })();

    lebai.cmp = (function() {

        /**
         * Namespace cmp.
         * @memberof lebai
         * @namespace
         */
        var cmp = {};

        /**
         * Logic enum.
         * @name lebai.cmp.Logic
         * @enum {number}
         * @property {number} AND=0 AND value
         * @property {number} OR=2 OR value
         * @property {number} NOT=3 NOT value
         */
        cmp.Logic = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "AND"] = 0;
            values[valuesById[2] = "OR"] = 2;
            values[valuesById[3] = "NOT"] = 3;
            return values;
        })();

        /**
         * Relation enum.
         * @name lebai.cmp.Relation
         * @enum {number}
         * @property {number} EQ=0 EQ value
         * @property {number} NEQ=2 NEQ value
         * @property {number} LT=3 LT value
         * @property {number} LTE=4 LTE value
         * @property {number} GT=5 GT value
         * @property {number} GTE=6 GTE value
         */
        cmp.Relation = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "EQ"] = 0;
            values[valuesById[2] = "NEQ"] = 2;
            values[valuesById[3] = "LT"] = 3;
            values[valuesById[4] = "LTE"] = 4;
            values[valuesById[5] = "GT"] = 5;
            values[valuesById[6] = "GTE"] = 6;
            return values;
        })();

        return cmp;
    })();

    lebai.db = (function() {

        /**
         * Namespace db.
         * @memberof lebai
         * @namespace
         */
        var db = {};

        db.SaveRequest = (function() {

            /**
             * Properties of a SaveRequest.
             * @memberof lebai.db
             * @interface ISaveRequest
             * @property {string|null} [name] SaveRequest name
             * @property {string|null} [data] SaveRequest data
             * @property {string|null} [dir] SaveRequest dir
             */

            /**
             * Constructs a new SaveRequest.
             * @memberof lebai.db
             * @classdesc Represents a SaveRequest.
             * @implements ISaveRequest
             * @constructor
             * @param {lebai.db.ISaveRequest=} [properties] Properties to set
             */
            function SaveRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SaveRequest name.
             * @member {string} name
             * @memberof lebai.db.SaveRequest
             * @instance
             */
            SaveRequest.prototype.name = "";

            /**
             * SaveRequest data.
             * @member {string} data
             * @memberof lebai.db.SaveRequest
             * @instance
             */
            SaveRequest.prototype.data = "";

            /**
             * SaveRequest dir.
             * @member {string} dir
             * @memberof lebai.db.SaveRequest
             * @instance
             */
            SaveRequest.prototype.dir = "";

            /**
             * Creates a new SaveRequest instance using the specified properties.
             * @function create
             * @memberof lebai.db.SaveRequest
             * @static
             * @param {lebai.db.ISaveRequest=} [properties] Properties to set
             * @returns {lebai.db.SaveRequest} SaveRequest instance
             */
            SaveRequest.create = function create(properties) {
                return new SaveRequest(properties);
            };

            /**
             * Encodes the specified SaveRequest message. Does not implicitly {@link lebai.db.SaveRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.db.SaveRequest
             * @static
             * @param {lebai.db.ISaveRequest} message SaveRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SaveRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.data);
                if (message.dir != null && Object.hasOwnProperty.call(message, "dir"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.dir);
                return writer;
            };

            /**
             * Encodes the specified SaveRequest message, length delimited. Does not implicitly {@link lebai.db.SaveRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.db.SaveRequest
             * @static
             * @param {lebai.db.ISaveRequest} message SaveRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SaveRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SaveRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.db.SaveRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.db.SaveRequest} SaveRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SaveRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.db.SaveRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.name = reader.string();
                            break;
                        }
                    case 2: {
                            message.data = reader.string();
                            break;
                        }
                    case 11: {
                            message.dir = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SaveRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.db.SaveRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.db.SaveRequest} SaveRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SaveRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SaveRequest message.
             * @function verify
             * @memberof lebai.db.SaveRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SaveRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.data != null && message.hasOwnProperty("data"))
                    if (!$util.isString(message.data))
                        return "data: string expected";
                if (message.dir != null && message.hasOwnProperty("dir"))
                    if (!$util.isString(message.dir))
                        return "dir: string expected";
                return null;
            };

            /**
             * Creates a SaveRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.db.SaveRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.db.SaveRequest} SaveRequest
             */
            SaveRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.db.SaveRequest)
                    return object;
                var message = new $root.lebai.db.SaveRequest();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.data != null)
                    message.data = String(object.data);
                if (object.dir != null)
                    message.dir = String(object.dir);
                return message;
            };

            /**
             * Creates a plain object from a SaveRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.db.SaveRequest
             * @static
             * @param {lebai.db.SaveRequest} message SaveRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SaveRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.data = "";
                    object.dir = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.data != null && message.hasOwnProperty("data"))
                    object.data = message.data;
                if (message.dir != null && message.hasOwnProperty("dir"))
                    object.dir = message.dir;
                return object;
            };

            /**
             * Converts this SaveRequest to JSON.
             * @function toJSON
             * @memberof lebai.db.SaveRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SaveRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SaveRequest
             * @function getTypeUrl
             * @memberof lebai.db.SaveRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SaveRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.db.SaveRequest";
            };

            return SaveRequest;
        })();

        db.LoadRequest = (function() {

            /**
             * Properties of a LoadRequest.
             * @memberof lebai.db
             * @interface ILoadRequest
             * @property {string|null} [name] LoadRequest name
             * @property {string|null} [dir] LoadRequest dir
             */

            /**
             * Constructs a new LoadRequest.
             * @memberof lebai.db
             * @classdesc Represents a LoadRequest.
             * @implements ILoadRequest
             * @constructor
             * @param {lebai.db.ILoadRequest=} [properties] Properties to set
             */
            function LoadRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LoadRequest name.
             * @member {string} name
             * @memberof lebai.db.LoadRequest
             * @instance
             */
            LoadRequest.prototype.name = "";

            /**
             * LoadRequest dir.
             * @member {string} dir
             * @memberof lebai.db.LoadRequest
             * @instance
             */
            LoadRequest.prototype.dir = "";

            /**
             * Creates a new LoadRequest instance using the specified properties.
             * @function create
             * @memberof lebai.db.LoadRequest
             * @static
             * @param {lebai.db.ILoadRequest=} [properties] Properties to set
             * @returns {lebai.db.LoadRequest} LoadRequest instance
             */
            LoadRequest.create = function create(properties) {
                return new LoadRequest(properties);
            };

            /**
             * Encodes the specified LoadRequest message. Does not implicitly {@link lebai.db.LoadRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.db.LoadRequest
             * @static
             * @param {lebai.db.ILoadRequest} message LoadRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LoadRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.dir != null && Object.hasOwnProperty.call(message, "dir"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.dir);
                return writer;
            };

            /**
             * Encodes the specified LoadRequest message, length delimited. Does not implicitly {@link lebai.db.LoadRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.db.LoadRequest
             * @static
             * @param {lebai.db.ILoadRequest} message LoadRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LoadRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LoadRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.db.LoadRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.db.LoadRequest} LoadRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LoadRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.db.LoadRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.name = reader.string();
                            break;
                        }
                    case 11: {
                            message.dir = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LoadRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.db.LoadRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.db.LoadRequest} LoadRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LoadRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LoadRequest message.
             * @function verify
             * @memberof lebai.db.LoadRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LoadRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.dir != null && message.hasOwnProperty("dir"))
                    if (!$util.isString(message.dir))
                        return "dir: string expected";
                return null;
            };

            /**
             * Creates a LoadRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.db.LoadRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.db.LoadRequest} LoadRequest
             */
            LoadRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.db.LoadRequest)
                    return object;
                var message = new $root.lebai.db.LoadRequest();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.dir != null)
                    message.dir = String(object.dir);
                return message;
            };

            /**
             * Creates a plain object from a LoadRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.db.LoadRequest
             * @static
             * @param {lebai.db.LoadRequest} message LoadRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LoadRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.dir = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.dir != null && message.hasOwnProperty("dir"))
                    object.dir = message.dir;
                return object;
            };

            /**
             * Converts this LoadRequest to JSON.
             * @function toJSON
             * @memberof lebai.db.LoadRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LoadRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for LoadRequest
             * @function getTypeUrl
             * @memberof lebai.db.LoadRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            LoadRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.db.LoadRequest";
            };

            return LoadRequest;
        })();

        db.LoadResponse = (function() {

            /**
             * Properties of a LoadResponse.
             * @memberof lebai.db
             * @interface ILoadResponse
             * @property {string|null} [data] LoadResponse data
             */

            /**
             * Constructs a new LoadResponse.
             * @memberof lebai.db
             * @classdesc Represents a LoadResponse.
             * @implements ILoadResponse
             * @constructor
             * @param {lebai.db.ILoadResponse=} [properties] Properties to set
             */
            function LoadResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LoadResponse data.
             * @member {string} data
             * @memberof lebai.db.LoadResponse
             * @instance
             */
            LoadResponse.prototype.data = "";

            /**
             * Creates a new LoadResponse instance using the specified properties.
             * @function create
             * @memberof lebai.db.LoadResponse
             * @static
             * @param {lebai.db.ILoadResponse=} [properties] Properties to set
             * @returns {lebai.db.LoadResponse} LoadResponse instance
             */
            LoadResponse.create = function create(properties) {
                return new LoadResponse(properties);
            };

            /**
             * Encodes the specified LoadResponse message. Does not implicitly {@link lebai.db.LoadResponse.verify|verify} messages.
             * @function encode
             * @memberof lebai.db.LoadResponse
             * @static
             * @param {lebai.db.ILoadResponse} message LoadResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LoadResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.data);
                return writer;
            };

            /**
             * Encodes the specified LoadResponse message, length delimited. Does not implicitly {@link lebai.db.LoadResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.db.LoadResponse
             * @static
             * @param {lebai.db.ILoadResponse} message LoadResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LoadResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LoadResponse message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.db.LoadResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.db.LoadResponse} LoadResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LoadResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.db.LoadResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2: {
                            message.data = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LoadResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.db.LoadResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.db.LoadResponse} LoadResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LoadResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LoadResponse message.
             * @function verify
             * @memberof lebai.db.LoadResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LoadResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.data != null && message.hasOwnProperty("data"))
                    if (!$util.isString(message.data))
                        return "data: string expected";
                return null;
            };

            /**
             * Creates a LoadResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.db.LoadResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.db.LoadResponse} LoadResponse
             */
            LoadResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.db.LoadResponse)
                    return object;
                var message = new $root.lebai.db.LoadResponse();
                if (object.data != null)
                    message.data = String(object.data);
                return message;
            };

            /**
             * Creates a plain object from a LoadResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.db.LoadResponse
             * @static
             * @param {lebai.db.LoadResponse} message LoadResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LoadResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.data = "";
                if (message.data != null && message.hasOwnProperty("data"))
                    object.data = message.data;
                return object;
            };

            /**
             * Converts this LoadResponse to JSON.
             * @function toJSON
             * @memberof lebai.db.LoadResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LoadResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for LoadResponse
             * @function getTypeUrl
             * @memberof lebai.db.LoadResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            LoadResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.db.LoadResponse";
            };

            return LoadResponse;
        })();

        db.LoadListRequest = (function() {

            /**
             * Properties of a LoadListRequest.
             * @memberof lebai.db
             * @interface ILoadListRequest
             * @property {string|null} [dir] LoadListRequest dir
             */

            /**
             * Constructs a new LoadListRequest.
             * @memberof lebai.db
             * @classdesc Represents a LoadListRequest.
             * @implements ILoadListRequest
             * @constructor
             * @param {lebai.db.ILoadListRequest=} [properties] Properties to set
             */
            function LoadListRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LoadListRequest dir.
             * @member {string} dir
             * @memberof lebai.db.LoadListRequest
             * @instance
             */
            LoadListRequest.prototype.dir = "";

            /**
             * Creates a new LoadListRequest instance using the specified properties.
             * @function create
             * @memberof lebai.db.LoadListRequest
             * @static
             * @param {lebai.db.ILoadListRequest=} [properties] Properties to set
             * @returns {lebai.db.LoadListRequest} LoadListRequest instance
             */
            LoadListRequest.create = function create(properties) {
                return new LoadListRequest(properties);
            };

            /**
             * Encodes the specified LoadListRequest message. Does not implicitly {@link lebai.db.LoadListRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.db.LoadListRequest
             * @static
             * @param {lebai.db.ILoadListRequest} message LoadListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LoadListRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.dir != null && Object.hasOwnProperty.call(message, "dir"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.dir);
                return writer;
            };

            /**
             * Encodes the specified LoadListRequest message, length delimited. Does not implicitly {@link lebai.db.LoadListRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.db.LoadListRequest
             * @static
             * @param {lebai.db.ILoadListRequest} message LoadListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LoadListRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LoadListRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.db.LoadListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.db.LoadListRequest} LoadListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LoadListRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.db.LoadListRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 11: {
                            message.dir = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LoadListRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.db.LoadListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.db.LoadListRequest} LoadListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LoadListRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LoadListRequest message.
             * @function verify
             * @memberof lebai.db.LoadListRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LoadListRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.dir != null && message.hasOwnProperty("dir"))
                    if (!$util.isString(message.dir))
                        return "dir: string expected";
                return null;
            };

            /**
             * Creates a LoadListRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.db.LoadListRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.db.LoadListRequest} LoadListRequest
             */
            LoadListRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.db.LoadListRequest)
                    return object;
                var message = new $root.lebai.db.LoadListRequest();
                if (object.dir != null)
                    message.dir = String(object.dir);
                return message;
            };

            /**
             * Creates a plain object from a LoadListRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.db.LoadListRequest
             * @static
             * @param {lebai.db.LoadListRequest} message LoadListRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LoadListRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.dir = "";
                if (message.dir != null && message.hasOwnProperty("dir"))
                    object.dir = message.dir;
                return object;
            };

            /**
             * Converts this LoadListRequest to JSON.
             * @function toJSON
             * @memberof lebai.db.LoadListRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LoadListRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for LoadListRequest
             * @function getTypeUrl
             * @memberof lebai.db.LoadListRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            LoadListRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.db.LoadListRequest";
            };

            return LoadListRequest;
        })();

        db.LoadListResponse = (function() {

            /**
             * Properties of a LoadListResponse.
             * @memberof lebai.db
             * @interface ILoadListResponse
             * @property {Array.<string>|null} [names] LoadListResponse names
             */

            /**
             * Constructs a new LoadListResponse.
             * @memberof lebai.db
             * @classdesc Represents a LoadListResponse.
             * @implements ILoadListResponse
             * @constructor
             * @param {lebai.db.ILoadListResponse=} [properties] Properties to set
             */
            function LoadListResponse(properties) {
                this.names = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LoadListResponse names.
             * @member {Array.<string>} names
             * @memberof lebai.db.LoadListResponse
             * @instance
             */
            LoadListResponse.prototype.names = $util.emptyArray;

            /**
             * Creates a new LoadListResponse instance using the specified properties.
             * @function create
             * @memberof lebai.db.LoadListResponse
             * @static
             * @param {lebai.db.ILoadListResponse=} [properties] Properties to set
             * @returns {lebai.db.LoadListResponse} LoadListResponse instance
             */
            LoadListResponse.create = function create(properties) {
                return new LoadListResponse(properties);
            };

            /**
             * Encodes the specified LoadListResponse message. Does not implicitly {@link lebai.db.LoadListResponse.verify|verify} messages.
             * @function encode
             * @memberof lebai.db.LoadListResponse
             * @static
             * @param {lebai.db.ILoadListResponse} message LoadListResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LoadListResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.names != null && message.names.length)
                    for (var i = 0; i < message.names.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.names[i]);
                return writer;
            };

            /**
             * Encodes the specified LoadListResponse message, length delimited. Does not implicitly {@link lebai.db.LoadListResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.db.LoadListResponse
             * @static
             * @param {lebai.db.ILoadListResponse} message LoadListResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LoadListResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LoadListResponse message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.db.LoadListResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.db.LoadListResponse} LoadListResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LoadListResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.db.LoadListResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2: {
                            if (!(message.names && message.names.length))
                                message.names = [];
                            message.names.push(reader.string());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LoadListResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.db.LoadListResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.db.LoadListResponse} LoadListResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LoadListResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LoadListResponse message.
             * @function verify
             * @memberof lebai.db.LoadListResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LoadListResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.names != null && message.hasOwnProperty("names")) {
                    if (!Array.isArray(message.names))
                        return "names: array expected";
                    for (var i = 0; i < message.names.length; ++i)
                        if (!$util.isString(message.names[i]))
                            return "names: string[] expected";
                }
                return null;
            };

            /**
             * Creates a LoadListResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.db.LoadListResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.db.LoadListResponse} LoadListResponse
             */
            LoadListResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.db.LoadListResponse)
                    return object;
                var message = new $root.lebai.db.LoadListResponse();
                if (object.names) {
                    if (!Array.isArray(object.names))
                        throw TypeError(".lebai.db.LoadListResponse.names: array expected");
                    message.names = [];
                    for (var i = 0; i < object.names.length; ++i)
                        message.names[i] = String(object.names[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a LoadListResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.db.LoadListResponse
             * @static
             * @param {lebai.db.LoadListResponse} message LoadListResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LoadListResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.names = [];
                if (message.names && message.names.length) {
                    object.names = [];
                    for (var j = 0; j < message.names.length; ++j)
                        object.names[j] = message.names[j];
                }
                return object;
            };

            /**
             * Converts this LoadListResponse to JSON.
             * @function toJSON
             * @memberof lebai.db.LoadListResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LoadListResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for LoadListResponse
             * @function getTypeUrl
             * @memberof lebai.db.LoadListResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            LoadListResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.db.LoadListResponse";
            };

            return LoadListResponse;
        })();

        db.DeleteRequest = (function() {

            /**
             * Properties of a DeleteRequest.
             * @memberof lebai.db
             * @interface IDeleteRequest
             * @property {string|null} [name] DeleteRequest name
             * @property {string|null} [dir] DeleteRequest dir
             */

            /**
             * Constructs a new DeleteRequest.
             * @memberof lebai.db
             * @classdesc Represents a DeleteRequest.
             * @implements IDeleteRequest
             * @constructor
             * @param {lebai.db.IDeleteRequest=} [properties] Properties to set
             */
            function DeleteRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DeleteRequest name.
             * @member {string} name
             * @memberof lebai.db.DeleteRequest
             * @instance
             */
            DeleteRequest.prototype.name = "";

            /**
             * DeleteRequest dir.
             * @member {string} dir
             * @memberof lebai.db.DeleteRequest
             * @instance
             */
            DeleteRequest.prototype.dir = "";

            /**
             * Creates a new DeleteRequest instance using the specified properties.
             * @function create
             * @memberof lebai.db.DeleteRequest
             * @static
             * @param {lebai.db.IDeleteRequest=} [properties] Properties to set
             * @returns {lebai.db.DeleteRequest} DeleteRequest instance
             */
            DeleteRequest.create = function create(properties) {
                return new DeleteRequest(properties);
            };

            /**
             * Encodes the specified DeleteRequest message. Does not implicitly {@link lebai.db.DeleteRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.db.DeleteRequest
             * @static
             * @param {lebai.db.IDeleteRequest} message DeleteRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.dir != null && Object.hasOwnProperty.call(message, "dir"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.dir);
                return writer;
            };

            /**
             * Encodes the specified DeleteRequest message, length delimited. Does not implicitly {@link lebai.db.DeleteRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.db.DeleteRequest
             * @static
             * @param {lebai.db.IDeleteRequest} message DeleteRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeleteRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.db.DeleteRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.db.DeleteRequest} DeleteRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.db.DeleteRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.name = reader.string();
                            break;
                        }
                    case 11: {
                            message.dir = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeleteRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.db.DeleteRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.db.DeleteRequest} DeleteRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeleteRequest message.
             * @function verify
             * @memberof lebai.db.DeleteRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeleteRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.dir != null && message.hasOwnProperty("dir"))
                    if (!$util.isString(message.dir))
                        return "dir: string expected";
                return null;
            };

            /**
             * Creates a DeleteRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.db.DeleteRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.db.DeleteRequest} DeleteRequest
             */
            DeleteRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.db.DeleteRequest)
                    return object;
                var message = new $root.lebai.db.DeleteRequest();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.dir != null)
                    message.dir = String(object.dir);
                return message;
            };

            /**
             * Creates a plain object from a DeleteRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.db.DeleteRequest
             * @static
             * @param {lebai.db.DeleteRequest} message DeleteRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeleteRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.dir = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.dir != null && message.hasOwnProperty("dir"))
                    object.dir = message.dir;
                return object;
            };

            /**
             * Converts this DeleteRequest to JSON.
             * @function toJSON
             * @memberof lebai.db.DeleteRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeleteRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DeleteRequest
             * @function getTypeUrl
             * @memberof lebai.db.DeleteRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DeleteRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.db.DeleteRequest";
            };

            return DeleteRequest;
        })();

        db.Dir = (function() {

            /**
             * Properties of a Dir.
             * @memberof lebai.db
             * @interface IDir
             * @property {string|null} [name] Dir name
             * @property {number|null} [id] Dir id
             */

            /**
             * Constructs a new Dir.
             * @memberof lebai.db
             * @classdesc Represents a Dir.
             * @implements IDir
             * @constructor
             * @param {lebai.db.IDir=} [properties] Properties to set
             */
            function Dir(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Dir name.
             * @member {string} name
             * @memberof lebai.db.Dir
             * @instance
             */
            Dir.prototype.name = "";

            /**
             * Dir id.
             * @member {number} id
             * @memberof lebai.db.Dir
             * @instance
             */
            Dir.prototype.id = 0;

            /**
             * Creates a new Dir instance using the specified properties.
             * @function create
             * @memberof lebai.db.Dir
             * @static
             * @param {lebai.db.IDir=} [properties] Properties to set
             * @returns {lebai.db.Dir} Dir instance
             */
            Dir.create = function create(properties) {
                return new Dir(properties);
            };

            /**
             * Encodes the specified Dir message. Does not implicitly {@link lebai.db.Dir.verify|verify} messages.
             * @function encode
             * @memberof lebai.db.Dir
             * @static
             * @param {lebai.db.IDir} message Dir message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Dir.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.id);
                return writer;
            };

            /**
             * Encodes the specified Dir message, length delimited. Does not implicitly {@link lebai.db.Dir.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.db.Dir
             * @static
             * @param {lebai.db.IDir} message Dir message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Dir.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Dir message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.db.Dir
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.db.Dir} Dir
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Dir.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.db.Dir();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.name = reader.string();
                            break;
                        }
                    case 2: {
                            message.id = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Dir message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.db.Dir
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.db.Dir} Dir
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Dir.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Dir message.
             * @function verify
             * @memberof lebai.db.Dir
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Dir.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id))
                        return "id: integer expected";
                return null;
            };

            /**
             * Creates a Dir message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.db.Dir
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.db.Dir} Dir
             */
            Dir.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.db.Dir)
                    return object;
                var message = new $root.lebai.db.Dir();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.id != null)
                    message.id = object.id >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a Dir message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.db.Dir
             * @static
             * @param {lebai.db.Dir} message Dir
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Dir.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.id = 0;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                return object;
            };

            /**
             * Converts this Dir to JSON.
             * @function toJSON
             * @memberof lebai.db.Dir
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Dir.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Dir
             * @function getTypeUrl
             * @memberof lebai.db.Dir
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Dir.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.db.Dir";
            };

            return Dir;
        })();

        db.UpdateDirRequest = (function() {

            /**
             * Properties of an UpdateDirRequest.
             * @memberof lebai.db
             * @interface IUpdateDirRequest
             * @property {string|null} [from] UpdateDirRequest from
             * @property {string|null} [to] UpdateDirRequest to
             */

            /**
             * Constructs a new UpdateDirRequest.
             * @memberof lebai.db
             * @classdesc Represents an UpdateDirRequest.
             * @implements IUpdateDirRequest
             * @constructor
             * @param {lebai.db.IUpdateDirRequest=} [properties] Properties to set
             */
            function UpdateDirRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UpdateDirRequest from.
             * @member {string} from
             * @memberof lebai.db.UpdateDirRequest
             * @instance
             */
            UpdateDirRequest.prototype.from = "";

            /**
             * UpdateDirRequest to.
             * @member {string} to
             * @memberof lebai.db.UpdateDirRequest
             * @instance
             */
            UpdateDirRequest.prototype.to = "";

            /**
             * Creates a new UpdateDirRequest instance using the specified properties.
             * @function create
             * @memberof lebai.db.UpdateDirRequest
             * @static
             * @param {lebai.db.IUpdateDirRequest=} [properties] Properties to set
             * @returns {lebai.db.UpdateDirRequest} UpdateDirRequest instance
             */
            UpdateDirRequest.create = function create(properties) {
                return new UpdateDirRequest(properties);
            };

            /**
             * Encodes the specified UpdateDirRequest message. Does not implicitly {@link lebai.db.UpdateDirRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.db.UpdateDirRequest
             * @static
             * @param {lebai.db.IUpdateDirRequest} message UpdateDirRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UpdateDirRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.from != null && Object.hasOwnProperty.call(message, "from"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.from);
                if (message.to != null && Object.hasOwnProperty.call(message, "to"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.to);
                return writer;
            };

            /**
             * Encodes the specified UpdateDirRequest message, length delimited. Does not implicitly {@link lebai.db.UpdateDirRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.db.UpdateDirRequest
             * @static
             * @param {lebai.db.IUpdateDirRequest} message UpdateDirRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UpdateDirRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an UpdateDirRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.db.UpdateDirRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.db.UpdateDirRequest} UpdateDirRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UpdateDirRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.db.UpdateDirRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.from = reader.string();
                            break;
                        }
                    case 2: {
                            message.to = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an UpdateDirRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.db.UpdateDirRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.db.UpdateDirRequest} UpdateDirRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UpdateDirRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an UpdateDirRequest message.
             * @function verify
             * @memberof lebai.db.UpdateDirRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UpdateDirRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.from != null && message.hasOwnProperty("from"))
                    if (!$util.isString(message.from))
                        return "from: string expected";
                if (message.to != null && message.hasOwnProperty("to"))
                    if (!$util.isString(message.to))
                        return "to: string expected";
                return null;
            };

            /**
             * Creates an UpdateDirRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.db.UpdateDirRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.db.UpdateDirRequest} UpdateDirRequest
             */
            UpdateDirRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.db.UpdateDirRequest)
                    return object;
                var message = new $root.lebai.db.UpdateDirRequest();
                if (object.from != null)
                    message.from = String(object.from);
                if (object.to != null)
                    message.to = String(object.to);
                return message;
            };

            /**
             * Creates a plain object from an UpdateDirRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.db.UpdateDirRequest
             * @static
             * @param {lebai.db.UpdateDirRequest} message UpdateDirRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UpdateDirRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.from = "";
                    object.to = "";
                }
                if (message.from != null && message.hasOwnProperty("from"))
                    object.from = message.from;
                if (message.to != null && message.hasOwnProperty("to"))
                    object.to = message.to;
                return object;
            };

            /**
             * Converts this UpdateDirRequest to JSON.
             * @function toJSON
             * @memberof lebai.db.UpdateDirRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UpdateDirRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for UpdateDirRequest
             * @function getTypeUrl
             * @memberof lebai.db.UpdateDirRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            UpdateDirRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.db.UpdateDirRequest";
            };

            return UpdateDirRequest;
        })();

        db.Dirs = (function() {

            /**
             * Properties of a Dirs.
             * @memberof lebai.db
             * @interface IDirs
             * @property {Array.<lebai.db.IDir>|null} [dirs] Dirs dirs
             */

            /**
             * Constructs a new Dirs.
             * @memberof lebai.db
             * @classdesc Represents a Dirs.
             * @implements IDirs
             * @constructor
             * @param {lebai.db.IDirs=} [properties] Properties to set
             */
            function Dirs(properties) {
                this.dirs = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Dirs dirs.
             * @member {Array.<lebai.db.IDir>} dirs
             * @memberof lebai.db.Dirs
             * @instance
             */
            Dirs.prototype.dirs = $util.emptyArray;

            /**
             * Creates a new Dirs instance using the specified properties.
             * @function create
             * @memberof lebai.db.Dirs
             * @static
             * @param {lebai.db.IDirs=} [properties] Properties to set
             * @returns {lebai.db.Dirs} Dirs instance
             */
            Dirs.create = function create(properties) {
                return new Dirs(properties);
            };

            /**
             * Encodes the specified Dirs message. Does not implicitly {@link lebai.db.Dirs.verify|verify} messages.
             * @function encode
             * @memberof lebai.db.Dirs
             * @static
             * @param {lebai.db.IDirs} message Dirs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Dirs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.dirs != null && message.dirs.length)
                    for (var i = 0; i < message.dirs.length; ++i)
                        $root.lebai.db.Dir.encode(message.dirs[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Dirs message, length delimited. Does not implicitly {@link lebai.db.Dirs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.db.Dirs
             * @static
             * @param {lebai.db.IDirs} message Dirs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Dirs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Dirs message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.db.Dirs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.db.Dirs} Dirs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Dirs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.db.Dirs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.dirs && message.dirs.length))
                                message.dirs = [];
                            message.dirs.push($root.lebai.db.Dir.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Dirs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.db.Dirs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.db.Dirs} Dirs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Dirs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Dirs message.
             * @function verify
             * @memberof lebai.db.Dirs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Dirs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.dirs != null && message.hasOwnProperty("dirs")) {
                    if (!Array.isArray(message.dirs))
                        return "dirs: array expected";
                    for (var i = 0; i < message.dirs.length; ++i) {
                        var error = $root.lebai.db.Dir.verify(message.dirs[i]);
                        if (error)
                            return "dirs." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Dirs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.db.Dirs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.db.Dirs} Dirs
             */
            Dirs.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.db.Dirs)
                    return object;
                var message = new $root.lebai.db.Dirs();
                if (object.dirs) {
                    if (!Array.isArray(object.dirs))
                        throw TypeError(".lebai.db.Dirs.dirs: array expected");
                    message.dirs = [];
                    for (var i = 0; i < object.dirs.length; ++i) {
                        if (typeof object.dirs[i] !== "object")
                            throw TypeError(".lebai.db.Dirs.dirs: object expected");
                        message.dirs[i] = $root.lebai.db.Dir.fromObject(object.dirs[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a Dirs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.db.Dirs
             * @static
             * @param {lebai.db.Dirs} message Dirs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Dirs.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.dirs = [];
                if (message.dirs && message.dirs.length) {
                    object.dirs = [];
                    for (var j = 0; j < message.dirs.length; ++j)
                        object.dirs[j] = $root.lebai.db.Dir.toObject(message.dirs[j], options);
                }
                return object;
            };

            /**
             * Converts this Dirs to JSON.
             * @function toJSON
             * @memberof lebai.db.Dirs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Dirs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Dirs
             * @function getTypeUrl
             * @memberof lebai.db.Dirs
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Dirs.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.db.Dirs";
            };

            return Dirs;
        })();

        db.DbService = (function() {

            /**
             * Constructs a new DbService service.
             * @memberof lebai.db
             * @classdesc Represents a DbService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function DbService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (DbService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = DbService;

            /**
             * Creates new DbService service using the specified rpc implementation.
             * @function create
             * @memberof lebai.db.DbService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {DbService} RPC service. Useful where requests and/or responses are streamed.
             */
            DbService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link lebai.db.DbService#createDir}.
             * @memberof lebai.db.DbService
             * @typedef CreateDirCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls CreateDir.
             * @function createDir
             * @memberof lebai.db.DbService
             * @instance
             * @param {lebai.db.IDir} request Dir message or plain object
             * @param {lebai.db.DbService.CreateDirCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(DbService.prototype.createDir = function createDir(request, callback) {
                return this.rpcCall(createDir, $root.lebai.db.Dir, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "CreateDir" });

            /**
             * Calls CreateDir.
             * @function createDir
             * @memberof lebai.db.DbService
             * @instance
             * @param {lebai.db.IDir} request Dir message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.db.DbService#updateDir}.
             * @memberof lebai.db.DbService
             * @typedef UpdateDirCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls UpdateDir.
             * @function updateDir
             * @memberof lebai.db.DbService
             * @instance
             * @param {lebai.db.IUpdateDirRequest} request UpdateDirRequest message or plain object
             * @param {lebai.db.DbService.UpdateDirCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(DbService.prototype.updateDir = function updateDir(request, callback) {
                return this.rpcCall(updateDir, $root.lebai.db.UpdateDirRequest, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "UpdateDir" });

            /**
             * Calls UpdateDir.
             * @function updateDir
             * @memberof lebai.db.DbService
             * @instance
             * @param {lebai.db.IUpdateDirRequest} request UpdateDirRequest message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.db.DbService#getDirs}.
             * @memberof lebai.db.DbService
             * @typedef GetDirsCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.db.Dirs} [response] Dirs
             */

            /**
             * Calls GetDirs.
             * @function getDirs
             * @memberof lebai.db.DbService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {lebai.db.DbService.GetDirsCallback} callback Node-style callback called with the error, if any, and Dirs
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(DbService.prototype.getDirs = function getDirs(request, callback) {
                return this.rpcCall(getDirs, $root.google.protobuf.Empty, $root.lebai.db.Dirs, request, callback);
            }, "name", { value: "GetDirs" });

            /**
             * Calls GetDirs.
             * @function getDirs
             * @memberof lebai.db.DbService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<lebai.db.Dirs>} Promise
             * @variation 2
             */

            return DbService;
        })();

        return db;
    })();

    lebai.dynamic = (function() {

        /**
         * Namespace dynamic.
         * @memberof lebai
         * @namespace
         */
        var dynamic = {};

        dynamic.Payload = (function() {

            /**
             * Properties of a Payload.
             * @memberof lebai.dynamic
             * @interface IPayload
             * @property {number|null} [mass] Payload mass
             * @property {lebai.posture.IPosition|null} [cog] Payload cog
             */

            /**
             * Constructs a new Payload.
             * @memberof lebai.dynamic
             * @classdesc Represents a Payload.
             * @implements IPayload
             * @constructor
             * @param {lebai.dynamic.IPayload=} [properties] Properties to set
             */
            function Payload(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Payload mass.
             * @member {number} mass
             * @memberof lebai.dynamic.Payload
             * @instance
             */
            Payload.prototype.mass = 0;

            /**
             * Payload cog.
             * @member {lebai.posture.IPosition|null|undefined} cog
             * @memberof lebai.dynamic.Payload
             * @instance
             */
            Payload.prototype.cog = null;

            /**
             * Creates a new Payload instance using the specified properties.
             * @function create
             * @memberof lebai.dynamic.Payload
             * @static
             * @param {lebai.dynamic.IPayload=} [properties] Properties to set
             * @returns {lebai.dynamic.Payload} Payload instance
             */
            Payload.create = function create(properties) {
                return new Payload(properties);
            };

            /**
             * Encodes the specified Payload message. Does not implicitly {@link lebai.dynamic.Payload.verify|verify} messages.
             * @function encode
             * @memberof lebai.dynamic.Payload
             * @static
             * @param {lebai.dynamic.IPayload} message Payload message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Payload.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.mass != null && Object.hasOwnProperty.call(message, "mass"))
                    writer.uint32(/* id 1, wireType 1 =*/9).double(message.mass);
                if (message.cog != null && Object.hasOwnProperty.call(message, "cog"))
                    $root.lebai.posture.Position.encode(message.cog, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Payload message, length delimited. Does not implicitly {@link lebai.dynamic.Payload.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.dynamic.Payload
             * @static
             * @param {lebai.dynamic.IPayload} message Payload message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Payload.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Payload message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.dynamic.Payload
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.dynamic.Payload} Payload
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Payload.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.dynamic.Payload();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.mass = reader.double();
                            break;
                        }
                    case 2: {
                            message.cog = $root.lebai.posture.Position.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Payload message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.dynamic.Payload
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.dynamic.Payload} Payload
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Payload.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Payload message.
             * @function verify
             * @memberof lebai.dynamic.Payload
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Payload.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.mass != null && message.hasOwnProperty("mass"))
                    if (typeof message.mass !== "number")
                        return "mass: number expected";
                if (message.cog != null && message.hasOwnProperty("cog")) {
                    var error = $root.lebai.posture.Position.verify(message.cog);
                    if (error)
                        return "cog." + error;
                }
                return null;
            };

            /**
             * Creates a Payload message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.dynamic.Payload
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.dynamic.Payload} Payload
             */
            Payload.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.dynamic.Payload)
                    return object;
                var message = new $root.lebai.dynamic.Payload();
                if (object.mass != null)
                    message.mass = Number(object.mass);
                if (object.cog != null) {
                    if (typeof object.cog !== "object")
                        throw TypeError(".lebai.dynamic.Payload.cog: object expected");
                    message.cog = $root.lebai.posture.Position.fromObject(object.cog);
                }
                return message;
            };

            /**
             * Creates a plain object from a Payload message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.dynamic.Payload
             * @static
             * @param {lebai.dynamic.Payload} message Payload
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Payload.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.mass = 0;
                    object.cog = null;
                }
                if (message.mass != null && message.hasOwnProperty("mass"))
                    object.mass = options.json && !isFinite(message.mass) ? String(message.mass) : message.mass;
                if (message.cog != null && message.hasOwnProperty("cog"))
                    object.cog = $root.lebai.posture.Position.toObject(message.cog, options);
                return object;
            };

            /**
             * Converts this Payload to JSON.
             * @function toJSON
             * @memberof lebai.dynamic.Payload
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Payload.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Payload
             * @function getTypeUrl
             * @memberof lebai.dynamic.Payload
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Payload.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.dynamic.Payload";
            };

            return Payload;
        })();

        dynamic.SetPayloadRequest = (function() {

            /**
             * Properties of a SetPayloadRequest.
             * @memberof lebai.dynamic
             * @interface ISetPayloadRequest
             * @property {number|null} [mass] SetPayloadRequest mass
             * @property {lebai.posture.IPosition|null} [cog] SetPayloadRequest cog
             */

            /**
             * Constructs a new SetPayloadRequest.
             * @memberof lebai.dynamic
             * @classdesc Represents a SetPayloadRequest.
             * @implements ISetPayloadRequest
             * @constructor
             * @param {lebai.dynamic.ISetPayloadRequest=} [properties] Properties to set
             */
            function SetPayloadRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SetPayloadRequest mass.
             * @member {number|null|undefined} mass
             * @memberof lebai.dynamic.SetPayloadRequest
             * @instance
             */
            SetPayloadRequest.prototype.mass = null;

            /**
             * SetPayloadRequest cog.
             * @member {lebai.posture.IPosition|null|undefined} cog
             * @memberof lebai.dynamic.SetPayloadRequest
             * @instance
             */
            SetPayloadRequest.prototype.cog = null;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * SetPayloadRequest _mass.
             * @member {"mass"|undefined} _mass
             * @memberof lebai.dynamic.SetPayloadRequest
             * @instance
             */
            Object.defineProperty(SetPayloadRequest.prototype, "_mass", {
                get: $util.oneOfGetter($oneOfFields = ["mass"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new SetPayloadRequest instance using the specified properties.
             * @function create
             * @memberof lebai.dynamic.SetPayloadRequest
             * @static
             * @param {lebai.dynamic.ISetPayloadRequest=} [properties] Properties to set
             * @returns {lebai.dynamic.SetPayloadRequest} SetPayloadRequest instance
             */
            SetPayloadRequest.create = function create(properties) {
                return new SetPayloadRequest(properties);
            };

            /**
             * Encodes the specified SetPayloadRequest message. Does not implicitly {@link lebai.dynamic.SetPayloadRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.dynamic.SetPayloadRequest
             * @static
             * @param {lebai.dynamic.ISetPayloadRequest} message SetPayloadRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetPayloadRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.mass != null && Object.hasOwnProperty.call(message, "mass"))
                    writer.uint32(/* id 1, wireType 1 =*/9).double(message.mass);
                if (message.cog != null && Object.hasOwnProperty.call(message, "cog"))
                    $root.lebai.posture.Position.encode(message.cog, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified SetPayloadRequest message, length delimited. Does not implicitly {@link lebai.dynamic.SetPayloadRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.dynamic.SetPayloadRequest
             * @static
             * @param {lebai.dynamic.ISetPayloadRequest} message SetPayloadRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetPayloadRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetPayloadRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.dynamic.SetPayloadRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.dynamic.SetPayloadRequest} SetPayloadRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetPayloadRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.dynamic.SetPayloadRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.mass = reader.double();
                            break;
                        }
                    case 2: {
                            message.cog = $root.lebai.posture.Position.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetPayloadRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.dynamic.SetPayloadRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.dynamic.SetPayloadRequest} SetPayloadRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetPayloadRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetPayloadRequest message.
             * @function verify
             * @memberof lebai.dynamic.SetPayloadRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetPayloadRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.mass != null && message.hasOwnProperty("mass")) {
                    properties._mass = 1;
                    if (typeof message.mass !== "number")
                        return "mass: number expected";
                }
                if (message.cog != null && message.hasOwnProperty("cog")) {
                    var error = $root.lebai.posture.Position.verify(message.cog);
                    if (error)
                        return "cog." + error;
                }
                return null;
            };

            /**
             * Creates a SetPayloadRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.dynamic.SetPayloadRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.dynamic.SetPayloadRequest} SetPayloadRequest
             */
            SetPayloadRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.dynamic.SetPayloadRequest)
                    return object;
                var message = new $root.lebai.dynamic.SetPayloadRequest();
                if (object.mass != null)
                    message.mass = Number(object.mass);
                if (object.cog != null) {
                    if (typeof object.cog !== "object")
                        throw TypeError(".lebai.dynamic.SetPayloadRequest.cog: object expected");
                    message.cog = $root.lebai.posture.Position.fromObject(object.cog);
                }
                return message;
            };

            /**
             * Creates a plain object from a SetPayloadRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.dynamic.SetPayloadRequest
             * @static
             * @param {lebai.dynamic.SetPayloadRequest} message SetPayloadRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetPayloadRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.cog = null;
                if (message.mass != null && message.hasOwnProperty("mass")) {
                    object.mass = options.json && !isFinite(message.mass) ? String(message.mass) : message.mass;
                    if (options.oneofs)
                        object._mass = "mass";
                }
                if (message.cog != null && message.hasOwnProperty("cog"))
                    object.cog = $root.lebai.posture.Position.toObject(message.cog, options);
                return object;
            };

            /**
             * Converts this SetPayloadRequest to JSON.
             * @function toJSON
             * @memberof lebai.dynamic.SetPayloadRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetPayloadRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetPayloadRequest
             * @function getTypeUrl
             * @memberof lebai.dynamic.SetPayloadRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetPayloadRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.dynamic.SetPayloadRequest";
            };

            return SetPayloadRequest;
        })();

        dynamic.SavePayloadRequest = (function() {

            /**
             * Properties of a SavePayloadRequest.
             * @memberof lebai.dynamic
             * @interface ISavePayloadRequest
             * @property {string|null} [name] SavePayloadRequest name
             * @property {lebai.dynamic.IPayload|null} [data] SavePayloadRequest data
             * @property {string|null} [dir] SavePayloadRequest dir
             */

            /**
             * Constructs a new SavePayloadRequest.
             * @memberof lebai.dynamic
             * @classdesc Represents a SavePayloadRequest.
             * @implements ISavePayloadRequest
             * @constructor
             * @param {lebai.dynamic.ISavePayloadRequest=} [properties] Properties to set
             */
            function SavePayloadRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SavePayloadRequest name.
             * @member {string} name
             * @memberof lebai.dynamic.SavePayloadRequest
             * @instance
             */
            SavePayloadRequest.prototype.name = "";

            /**
             * SavePayloadRequest data.
             * @member {lebai.dynamic.IPayload|null|undefined} data
             * @memberof lebai.dynamic.SavePayloadRequest
             * @instance
             */
            SavePayloadRequest.prototype.data = null;

            /**
             * SavePayloadRequest dir.
             * @member {string} dir
             * @memberof lebai.dynamic.SavePayloadRequest
             * @instance
             */
            SavePayloadRequest.prototype.dir = "";

            /**
             * Creates a new SavePayloadRequest instance using the specified properties.
             * @function create
             * @memberof lebai.dynamic.SavePayloadRequest
             * @static
             * @param {lebai.dynamic.ISavePayloadRequest=} [properties] Properties to set
             * @returns {lebai.dynamic.SavePayloadRequest} SavePayloadRequest instance
             */
            SavePayloadRequest.create = function create(properties) {
                return new SavePayloadRequest(properties);
            };

            /**
             * Encodes the specified SavePayloadRequest message. Does not implicitly {@link lebai.dynamic.SavePayloadRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.dynamic.SavePayloadRequest
             * @static
             * @param {lebai.dynamic.ISavePayloadRequest} message SavePayloadRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SavePayloadRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    $root.lebai.dynamic.Payload.encode(message.data, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.dir != null && Object.hasOwnProperty.call(message, "dir"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.dir);
                return writer;
            };

            /**
             * Encodes the specified SavePayloadRequest message, length delimited. Does not implicitly {@link lebai.dynamic.SavePayloadRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.dynamic.SavePayloadRequest
             * @static
             * @param {lebai.dynamic.ISavePayloadRequest} message SavePayloadRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SavePayloadRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SavePayloadRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.dynamic.SavePayloadRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.dynamic.SavePayloadRequest} SavePayloadRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SavePayloadRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.dynamic.SavePayloadRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.name = reader.string();
                            break;
                        }
                    case 2: {
                            message.data = $root.lebai.dynamic.Payload.decode(reader, reader.uint32());
                            break;
                        }
                    case 11: {
                            message.dir = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SavePayloadRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.dynamic.SavePayloadRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.dynamic.SavePayloadRequest} SavePayloadRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SavePayloadRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SavePayloadRequest message.
             * @function verify
             * @memberof lebai.dynamic.SavePayloadRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SavePayloadRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.data != null && message.hasOwnProperty("data")) {
                    var error = $root.lebai.dynamic.Payload.verify(message.data);
                    if (error)
                        return "data." + error;
                }
                if (message.dir != null && message.hasOwnProperty("dir"))
                    if (!$util.isString(message.dir))
                        return "dir: string expected";
                return null;
            };

            /**
             * Creates a SavePayloadRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.dynamic.SavePayloadRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.dynamic.SavePayloadRequest} SavePayloadRequest
             */
            SavePayloadRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.dynamic.SavePayloadRequest)
                    return object;
                var message = new $root.lebai.dynamic.SavePayloadRequest();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.data != null) {
                    if (typeof object.data !== "object")
                        throw TypeError(".lebai.dynamic.SavePayloadRequest.data: object expected");
                    message.data = $root.lebai.dynamic.Payload.fromObject(object.data);
                }
                if (object.dir != null)
                    message.dir = String(object.dir);
                return message;
            };

            /**
             * Creates a plain object from a SavePayloadRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.dynamic.SavePayloadRequest
             * @static
             * @param {lebai.dynamic.SavePayloadRequest} message SavePayloadRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SavePayloadRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.data = null;
                    object.dir = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.data != null && message.hasOwnProperty("data"))
                    object.data = $root.lebai.dynamic.Payload.toObject(message.data, options);
                if (message.dir != null && message.hasOwnProperty("dir"))
                    object.dir = message.dir;
                return object;
            };

            /**
             * Converts this SavePayloadRequest to JSON.
             * @function toJSON
             * @memberof lebai.dynamic.SavePayloadRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SavePayloadRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SavePayloadRequest
             * @function getTypeUrl
             * @memberof lebai.dynamic.SavePayloadRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SavePayloadRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.dynamic.SavePayloadRequest";
            };

            return SavePayloadRequest;
        })();

        dynamic.DynamicService = (function() {

            /**
             * Constructs a new DynamicService service.
             * @memberof lebai.dynamic
             * @classdesc Represents a DynamicService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function DynamicService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (DynamicService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = DynamicService;

            /**
             * Creates new DynamicService service using the specified rpc implementation.
             * @function create
             * @memberof lebai.dynamic.DynamicService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {DynamicService} RPC service. Useful where requests and/or responses are streamed.
             */
            DynamicService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link lebai.dynamic.DynamicService#savePayload}.
             * @memberof lebai.dynamic.DynamicService
             * @typedef SavePayloadCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls SavePayload.
             * @function savePayload
             * @memberof lebai.dynamic.DynamicService
             * @instance
             * @param {lebai.dynamic.ISavePayloadRequest} request SavePayloadRequest message or plain object
             * @param {lebai.dynamic.DynamicService.SavePayloadCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(DynamicService.prototype.savePayload = function savePayload(request, callback) {
                return this.rpcCall(savePayload, $root.lebai.dynamic.SavePayloadRequest, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "SavePayload" });

            /**
             * Calls SavePayload.
             * @function savePayload
             * @memberof lebai.dynamic.DynamicService
             * @instance
             * @param {lebai.dynamic.ISavePayloadRequest} request SavePayloadRequest message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.dynamic.DynamicService#loadPayload}.
             * @memberof lebai.dynamic.DynamicService
             * @typedef LoadPayloadCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.dynamic.Payload} [response] Payload
             */

            /**
             * Calls LoadPayload.
             * @function loadPayload
             * @memberof lebai.dynamic.DynamicService
             * @instance
             * @param {lebai.db.ILoadRequest} request LoadRequest message or plain object
             * @param {lebai.dynamic.DynamicService.LoadPayloadCallback} callback Node-style callback called with the error, if any, and Payload
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(DynamicService.prototype.loadPayload = function loadPayload(request, callback) {
                return this.rpcCall(loadPayload, $root.lebai.db.LoadRequest, $root.lebai.dynamic.Payload, request, callback);
            }, "name", { value: "LoadPayload" });

            /**
             * Calls LoadPayload.
             * @function loadPayload
             * @memberof lebai.dynamic.DynamicService
             * @instance
             * @param {lebai.db.ILoadRequest} request LoadRequest message or plain object
             * @returns {Promise<lebai.dynamic.Payload>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.dynamic.DynamicService#loadPayloadList}.
             * @memberof lebai.dynamic.DynamicService
             * @typedef LoadPayloadListCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.db.LoadListResponse} [response] LoadListResponse
             */

            /**
             * Calls LoadPayloadList.
             * @function loadPayloadList
             * @memberof lebai.dynamic.DynamicService
             * @instance
             * @param {lebai.db.ILoadListRequest} request LoadListRequest message or plain object
             * @param {lebai.dynamic.DynamicService.LoadPayloadListCallback} callback Node-style callback called with the error, if any, and LoadListResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(DynamicService.prototype.loadPayloadList = function loadPayloadList(request, callback) {
                return this.rpcCall(loadPayloadList, $root.lebai.db.LoadListRequest, $root.lebai.db.LoadListResponse, request, callback);
            }, "name", { value: "LoadPayloadList" });

            /**
             * Calls LoadPayloadList.
             * @function loadPayloadList
             * @memberof lebai.dynamic.DynamicService
             * @instance
             * @param {lebai.db.ILoadListRequest} request LoadListRequest message or plain object
             * @returns {Promise<lebai.db.LoadListResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.dynamic.DynamicService#setPayload}.
             * @memberof lebai.dynamic.DynamicService
             * @typedef SetPayloadCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls SetPayload.
             * @function setPayload
             * @memberof lebai.dynamic.DynamicService
             * @instance
             * @param {lebai.dynamic.ISetPayloadRequest} request SetPayloadRequest message or plain object
             * @param {lebai.dynamic.DynamicService.SetPayloadCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(DynamicService.prototype.setPayload = function setPayload(request, callback) {
                return this.rpcCall(setPayload, $root.lebai.dynamic.SetPayloadRequest, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "SetPayload" });

            /**
             * Calls SetPayload.
             * @function setPayload
             * @memberof lebai.dynamic.DynamicService
             * @instance
             * @param {lebai.dynamic.ISetPayloadRequest} request SetPayloadRequest message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.dynamic.DynamicService#getPayload}.
             * @memberof lebai.dynamic.DynamicService
             * @typedef GetPayloadCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.dynamic.Payload} [response] Payload
             */

            /**
             * Calls GetPayload.
             * @function getPayload
             * @memberof lebai.dynamic.DynamicService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {lebai.dynamic.DynamicService.GetPayloadCallback} callback Node-style callback called with the error, if any, and Payload
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(DynamicService.prototype.getPayload = function getPayload(request, callback) {
                return this.rpcCall(getPayload, $root.google.protobuf.Empty, $root.lebai.dynamic.Payload, request, callback);
            }, "name", { value: "GetPayload" });

            /**
             * Calls GetPayload.
             * @function getPayload
             * @memberof lebai.dynamic.DynamicService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<lebai.dynamic.Payload>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.dynamic.DynamicService#setGravity}.
             * @memberof lebai.dynamic.DynamicService
             * @typedef SetGravityCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls SetGravity.
             * @function setGravity
             * @memberof lebai.dynamic.DynamicService
             * @instance
             * @param {lebai.posture.IPosition} request Position message or plain object
             * @param {lebai.dynamic.DynamicService.SetGravityCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(DynamicService.prototype.setGravity = function setGravity(request, callback) {
                return this.rpcCall(setGravity, $root.lebai.posture.Position, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "SetGravity" });

            /**
             * Calls SetGravity.
             * @function setGravity
             * @memberof lebai.dynamic.DynamicService
             * @instance
             * @param {lebai.posture.IPosition} request Position message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.dynamic.DynamicService#getGravity}.
             * @memberof lebai.dynamic.DynamicService
             * @typedef GetGravityCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.posture.Position} [response] Position
             */

            /**
             * Calls GetGravity.
             * @function getGravity
             * @memberof lebai.dynamic.DynamicService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {lebai.dynamic.DynamicService.GetGravityCallback} callback Node-style callback called with the error, if any, and Position
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(DynamicService.prototype.getGravity = function getGravity(request, callback) {
                return this.rpcCall(getGravity, $root.google.protobuf.Empty, $root.lebai.posture.Position, request, callback);
            }, "name", { value: "GetGravity" });

            /**
             * Calls GetGravity.
             * @function getGravity
             * @memberof lebai.dynamic.DynamicService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<lebai.posture.Position>} Promise
             * @variation 2
             */

            return DynamicService;
        })();

        return dynamic;
    })();

    lebai.posture = (function() {

        /**
         * Namespace posture.
         * @memberof lebai
         * @namespace
         */
        var posture = {};

        posture.JointPose = (function() {

            /**
             * Properties of a JointPose.
             * @memberof lebai.posture
             * @interface IJointPose
             * @property {Array.<number>|null} [joint] JointPose joint
             */

            /**
             * Constructs a new JointPose.
             * @memberof lebai.posture
             * @classdesc Represents a JointPose.
             * @implements IJointPose
             * @constructor
             * @param {lebai.posture.IJointPose=} [properties] Properties to set
             */
            function JointPose(properties) {
                this.joint = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * JointPose joint.
             * @member {Array.<number>} joint
             * @memberof lebai.posture.JointPose
             * @instance
             */
            JointPose.prototype.joint = $util.emptyArray;

            /**
             * Creates a new JointPose instance using the specified properties.
             * @function create
             * @memberof lebai.posture.JointPose
             * @static
             * @param {lebai.posture.IJointPose=} [properties] Properties to set
             * @returns {lebai.posture.JointPose} JointPose instance
             */
            JointPose.create = function create(properties) {
                return new JointPose(properties);
            };

            /**
             * Encodes the specified JointPose message. Does not implicitly {@link lebai.posture.JointPose.verify|verify} messages.
             * @function encode
             * @memberof lebai.posture.JointPose
             * @static
             * @param {lebai.posture.IJointPose} message JointPose message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            JointPose.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.joint != null && message.joint.length) {
                    writer.uint32(/* id 1, wireType 2 =*/10).fork();
                    for (var i = 0; i < message.joint.length; ++i)
                        writer.double(message.joint[i]);
                    writer.ldelim();
                }
                return writer;
            };

            /**
             * Encodes the specified JointPose message, length delimited. Does not implicitly {@link lebai.posture.JointPose.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.posture.JointPose
             * @static
             * @param {lebai.posture.IJointPose} message JointPose message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            JointPose.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a JointPose message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.posture.JointPose
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.posture.JointPose} JointPose
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            JointPose.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.posture.JointPose();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.joint && message.joint.length))
                                message.joint = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.joint.push(reader.double());
                            } else
                                message.joint.push(reader.double());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a JointPose message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.posture.JointPose
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.posture.JointPose} JointPose
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            JointPose.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a JointPose message.
             * @function verify
             * @memberof lebai.posture.JointPose
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            JointPose.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.joint != null && message.hasOwnProperty("joint")) {
                    if (!Array.isArray(message.joint))
                        return "joint: array expected";
                    for (var i = 0; i < message.joint.length; ++i)
                        if (typeof message.joint[i] !== "number")
                            return "joint: number[] expected";
                }
                return null;
            };

            /**
             * Creates a JointPose message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.posture.JointPose
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.posture.JointPose} JointPose
             */
            JointPose.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.posture.JointPose)
                    return object;
                var message = new $root.lebai.posture.JointPose();
                if (object.joint) {
                    if (!Array.isArray(object.joint))
                        throw TypeError(".lebai.posture.JointPose.joint: array expected");
                    message.joint = [];
                    for (var i = 0; i < object.joint.length; ++i)
                        message.joint[i] = Number(object.joint[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a JointPose message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.posture.JointPose
             * @static
             * @param {lebai.posture.JointPose} message JointPose
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            JointPose.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.joint = [];
                if (message.joint && message.joint.length) {
                    object.joint = [];
                    for (var j = 0; j < message.joint.length; ++j)
                        object.joint[j] = options.json && !isFinite(message.joint[j]) ? String(message.joint[j]) : message.joint[j];
                }
                return object;
            };

            /**
             * Converts this JointPose to JSON.
             * @function toJSON
             * @memberof lebai.posture.JointPose
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            JointPose.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for JointPose
             * @function getTypeUrl
             * @memberof lebai.posture.JointPose
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            JointPose.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.posture.JointPose";
            };

            return JointPose;
        })();

        posture.JointFrame = (function() {

            /**
             * Properties of a JointFrame.
             * @memberof lebai.posture
             * @interface IJointFrame
             * @property {lebai.posture.JointFrame.Kind|null} [kind] JointFrame kind
             * @property {lebai.posture.IJointPose|null} [pose] JointFrame pose
             */

            /**
             * Constructs a new JointFrame.
             * @memberof lebai.posture
             * @classdesc Represents a JointFrame.
             * @implements IJointFrame
             * @constructor
             * @param {lebai.posture.IJointFrame=} [properties] Properties to set
             */
            function JointFrame(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * JointFrame kind.
             * @member {lebai.posture.JointFrame.Kind} kind
             * @memberof lebai.posture.JointFrame
             * @instance
             */
            JointFrame.prototype.kind = 0;

            /**
             * JointFrame pose.
             * @member {lebai.posture.IJointPose|null|undefined} pose
             * @memberof lebai.posture.JointFrame
             * @instance
             */
            JointFrame.prototype.pose = null;

            /**
             * Creates a new JointFrame instance using the specified properties.
             * @function create
             * @memberof lebai.posture.JointFrame
             * @static
             * @param {lebai.posture.IJointFrame=} [properties] Properties to set
             * @returns {lebai.posture.JointFrame} JointFrame instance
             */
            JointFrame.create = function create(properties) {
                return new JointFrame(properties);
            };

            /**
             * Encodes the specified JointFrame message. Does not implicitly {@link lebai.posture.JointFrame.verify|verify} messages.
             * @function encode
             * @memberof lebai.posture.JointFrame
             * @static
             * @param {lebai.posture.IJointFrame} message JointFrame message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            JointFrame.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.kind != null && Object.hasOwnProperty.call(message, "kind"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.kind);
                if (message.pose != null && Object.hasOwnProperty.call(message, "pose"))
                    $root.lebai.posture.JointPose.encode(message.pose, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified JointFrame message, length delimited. Does not implicitly {@link lebai.posture.JointFrame.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.posture.JointFrame
             * @static
             * @param {lebai.posture.IJointFrame} message JointFrame message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            JointFrame.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a JointFrame message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.posture.JointFrame
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.posture.JointFrame} JointFrame
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            JointFrame.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.posture.JointFrame();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.kind = reader.int32();
                            break;
                        }
                    case 2: {
                            message.pose = $root.lebai.posture.JointPose.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a JointFrame message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.posture.JointFrame
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.posture.JointFrame} JointFrame
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            JointFrame.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a JointFrame message.
             * @function verify
             * @memberof lebai.posture.JointFrame
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            JointFrame.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.kind != null && message.hasOwnProperty("kind"))
                    switch (message.kind) {
                    default:
                        return "kind: enum value expected";
                    case 0:
                    case 1:
                    case 11:
                    case 99:
                        break;
                    }
                if (message.pose != null && message.hasOwnProperty("pose")) {
                    var error = $root.lebai.posture.JointPose.verify(message.pose);
                    if (error)
                        return "pose." + error;
                }
                return null;
            };

            /**
             * Creates a JointFrame message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.posture.JointFrame
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.posture.JointFrame} JointFrame
             */
            JointFrame.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.posture.JointFrame)
                    return object;
                var message = new $root.lebai.posture.JointFrame();
                switch (object.kind) {
                default:
                    if (typeof object.kind === "number") {
                        message.kind = object.kind;
                        break;
                    }
                    break;
                case "BASE":
                case 0:
                    message.kind = 0;
                    break;
                case "CURRENT":
                case 1:
                    message.kind = 1;
                    break;
                case "LAST":
                case 11:
                    message.kind = 11;
                    break;
                case "CUSTOM":
                case 99:
                    message.kind = 99;
                    break;
                }
                if (object.pose != null) {
                    if (typeof object.pose !== "object")
                        throw TypeError(".lebai.posture.JointFrame.pose: object expected");
                    message.pose = $root.lebai.posture.JointPose.fromObject(object.pose);
                }
                return message;
            };

            /**
             * Creates a plain object from a JointFrame message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.posture.JointFrame
             * @static
             * @param {lebai.posture.JointFrame} message JointFrame
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            JointFrame.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.kind = options.enums === String ? "BASE" : 0;
                    object.pose = null;
                }
                if (message.kind != null && message.hasOwnProperty("kind"))
                    object.kind = options.enums === String ? $root.lebai.posture.JointFrame.Kind[message.kind] === undefined ? message.kind : $root.lebai.posture.JointFrame.Kind[message.kind] : message.kind;
                if (message.pose != null && message.hasOwnProperty("pose"))
                    object.pose = $root.lebai.posture.JointPose.toObject(message.pose, options);
                return object;
            };

            /**
             * Converts this JointFrame to JSON.
             * @function toJSON
             * @memberof lebai.posture.JointFrame
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            JointFrame.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for JointFrame
             * @function getTypeUrl
             * @memberof lebai.posture.JointFrame
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            JointFrame.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.posture.JointFrame";
            };

            /**
             * Kind enum.
             * @name lebai.posture.JointFrame.Kind
             * @enum {number}
             * @property {number} BASE=0 BASE value
             * @property {number} CURRENT=1 CURRENT value
             * @property {number} LAST=11 LAST value
             * @property {number} CUSTOM=99 CUSTOM value
             */
            JointFrame.Kind = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "BASE"] = 0;
                values[valuesById[1] = "CURRENT"] = 1;
                values[valuesById[11] = "LAST"] = 11;
                values[valuesById[99] = "CUSTOM"] = 99;
                return values;
            })();

            return JointFrame;
        })();

        posture.RotationMatrix = (function() {

            /**
             * Properties of a RotationMatrix.
             * @memberof lebai.posture
             * @interface IRotationMatrix
             * @property {number|null} [m11] RotationMatrix m11
             * @property {number|null} [m12] RotationMatrix m12
             * @property {number|null} [m13] RotationMatrix m13
             * @property {number|null} [m21] RotationMatrix m21
             * @property {number|null} [m22] RotationMatrix m22
             * @property {number|null} [m23] RotationMatrix m23
             * @property {number|null} [m31] RotationMatrix m31
             * @property {number|null} [m32] RotationMatrix m32
             * @property {number|null} [m33] RotationMatrix m33
             */

            /**
             * Constructs a new RotationMatrix.
             * @memberof lebai.posture
             * @classdesc Represents a RotationMatrix.
             * @implements IRotationMatrix
             * @constructor
             * @param {lebai.posture.IRotationMatrix=} [properties] Properties to set
             */
            function RotationMatrix(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RotationMatrix m11.
             * @member {number} m11
             * @memberof lebai.posture.RotationMatrix
             * @instance
             */
            RotationMatrix.prototype.m11 = 0;

            /**
             * RotationMatrix m12.
             * @member {number} m12
             * @memberof lebai.posture.RotationMatrix
             * @instance
             */
            RotationMatrix.prototype.m12 = 0;

            /**
             * RotationMatrix m13.
             * @member {number} m13
             * @memberof lebai.posture.RotationMatrix
             * @instance
             */
            RotationMatrix.prototype.m13 = 0;

            /**
             * RotationMatrix m21.
             * @member {number} m21
             * @memberof lebai.posture.RotationMatrix
             * @instance
             */
            RotationMatrix.prototype.m21 = 0;

            /**
             * RotationMatrix m22.
             * @member {number} m22
             * @memberof lebai.posture.RotationMatrix
             * @instance
             */
            RotationMatrix.prototype.m22 = 0;

            /**
             * RotationMatrix m23.
             * @member {number} m23
             * @memberof lebai.posture.RotationMatrix
             * @instance
             */
            RotationMatrix.prototype.m23 = 0;

            /**
             * RotationMatrix m31.
             * @member {number} m31
             * @memberof lebai.posture.RotationMatrix
             * @instance
             */
            RotationMatrix.prototype.m31 = 0;

            /**
             * RotationMatrix m32.
             * @member {number} m32
             * @memberof lebai.posture.RotationMatrix
             * @instance
             */
            RotationMatrix.prototype.m32 = 0;

            /**
             * RotationMatrix m33.
             * @member {number} m33
             * @memberof lebai.posture.RotationMatrix
             * @instance
             */
            RotationMatrix.prototype.m33 = 0;

            /**
             * Creates a new RotationMatrix instance using the specified properties.
             * @function create
             * @memberof lebai.posture.RotationMatrix
             * @static
             * @param {lebai.posture.IRotationMatrix=} [properties] Properties to set
             * @returns {lebai.posture.RotationMatrix} RotationMatrix instance
             */
            RotationMatrix.create = function create(properties) {
                return new RotationMatrix(properties);
            };

            /**
             * Encodes the specified RotationMatrix message. Does not implicitly {@link lebai.posture.RotationMatrix.verify|verify} messages.
             * @function encode
             * @memberof lebai.posture.RotationMatrix
             * @static
             * @param {lebai.posture.IRotationMatrix} message RotationMatrix message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RotationMatrix.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.m11 != null && Object.hasOwnProperty.call(message, "m11"))
                    writer.uint32(/* id 11, wireType 1 =*/89).double(message.m11);
                if (message.m12 != null && Object.hasOwnProperty.call(message, "m12"))
                    writer.uint32(/* id 12, wireType 1 =*/97).double(message.m12);
                if (message.m13 != null && Object.hasOwnProperty.call(message, "m13"))
                    writer.uint32(/* id 13, wireType 1 =*/105).double(message.m13);
                if (message.m21 != null && Object.hasOwnProperty.call(message, "m21"))
                    writer.uint32(/* id 21, wireType 1 =*/169).double(message.m21);
                if (message.m22 != null && Object.hasOwnProperty.call(message, "m22"))
                    writer.uint32(/* id 22, wireType 1 =*/177).double(message.m22);
                if (message.m23 != null && Object.hasOwnProperty.call(message, "m23"))
                    writer.uint32(/* id 23, wireType 1 =*/185).double(message.m23);
                if (message.m31 != null && Object.hasOwnProperty.call(message, "m31"))
                    writer.uint32(/* id 31, wireType 1 =*/249).double(message.m31);
                if (message.m32 != null && Object.hasOwnProperty.call(message, "m32"))
                    writer.uint32(/* id 32, wireType 1 =*/257).double(message.m32);
                if (message.m33 != null && Object.hasOwnProperty.call(message, "m33"))
                    writer.uint32(/* id 33, wireType 1 =*/265).double(message.m33);
                return writer;
            };

            /**
             * Encodes the specified RotationMatrix message, length delimited. Does not implicitly {@link lebai.posture.RotationMatrix.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.posture.RotationMatrix
             * @static
             * @param {lebai.posture.IRotationMatrix} message RotationMatrix message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RotationMatrix.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RotationMatrix message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.posture.RotationMatrix
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.posture.RotationMatrix} RotationMatrix
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RotationMatrix.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.posture.RotationMatrix();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 11: {
                            message.m11 = reader.double();
                            break;
                        }
                    case 12: {
                            message.m12 = reader.double();
                            break;
                        }
                    case 13: {
                            message.m13 = reader.double();
                            break;
                        }
                    case 21: {
                            message.m21 = reader.double();
                            break;
                        }
                    case 22: {
                            message.m22 = reader.double();
                            break;
                        }
                    case 23: {
                            message.m23 = reader.double();
                            break;
                        }
                    case 31: {
                            message.m31 = reader.double();
                            break;
                        }
                    case 32: {
                            message.m32 = reader.double();
                            break;
                        }
                    case 33: {
                            message.m33 = reader.double();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RotationMatrix message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.posture.RotationMatrix
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.posture.RotationMatrix} RotationMatrix
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RotationMatrix.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RotationMatrix message.
             * @function verify
             * @memberof lebai.posture.RotationMatrix
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RotationMatrix.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.m11 != null && message.hasOwnProperty("m11"))
                    if (typeof message.m11 !== "number")
                        return "m11: number expected";
                if (message.m12 != null && message.hasOwnProperty("m12"))
                    if (typeof message.m12 !== "number")
                        return "m12: number expected";
                if (message.m13 != null && message.hasOwnProperty("m13"))
                    if (typeof message.m13 !== "number")
                        return "m13: number expected";
                if (message.m21 != null && message.hasOwnProperty("m21"))
                    if (typeof message.m21 !== "number")
                        return "m21: number expected";
                if (message.m22 != null && message.hasOwnProperty("m22"))
                    if (typeof message.m22 !== "number")
                        return "m22: number expected";
                if (message.m23 != null && message.hasOwnProperty("m23"))
                    if (typeof message.m23 !== "number")
                        return "m23: number expected";
                if (message.m31 != null && message.hasOwnProperty("m31"))
                    if (typeof message.m31 !== "number")
                        return "m31: number expected";
                if (message.m32 != null && message.hasOwnProperty("m32"))
                    if (typeof message.m32 !== "number")
                        return "m32: number expected";
                if (message.m33 != null && message.hasOwnProperty("m33"))
                    if (typeof message.m33 !== "number")
                        return "m33: number expected";
                return null;
            };

            /**
             * Creates a RotationMatrix message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.posture.RotationMatrix
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.posture.RotationMatrix} RotationMatrix
             */
            RotationMatrix.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.posture.RotationMatrix)
                    return object;
                var message = new $root.lebai.posture.RotationMatrix();
                if (object.m11 != null)
                    message.m11 = Number(object.m11);
                if (object.m12 != null)
                    message.m12 = Number(object.m12);
                if (object.m13 != null)
                    message.m13 = Number(object.m13);
                if (object.m21 != null)
                    message.m21 = Number(object.m21);
                if (object.m22 != null)
                    message.m22 = Number(object.m22);
                if (object.m23 != null)
                    message.m23 = Number(object.m23);
                if (object.m31 != null)
                    message.m31 = Number(object.m31);
                if (object.m32 != null)
                    message.m32 = Number(object.m32);
                if (object.m33 != null)
                    message.m33 = Number(object.m33);
                return message;
            };

            /**
             * Creates a plain object from a RotationMatrix message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.posture.RotationMatrix
             * @static
             * @param {lebai.posture.RotationMatrix} message RotationMatrix
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RotationMatrix.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.m11 = 0;
                    object.m12 = 0;
                    object.m13 = 0;
                    object.m21 = 0;
                    object.m22 = 0;
                    object.m23 = 0;
                    object.m31 = 0;
                    object.m32 = 0;
                    object.m33 = 0;
                }
                if (message.m11 != null && message.hasOwnProperty("m11"))
                    object.m11 = options.json && !isFinite(message.m11) ? String(message.m11) : message.m11;
                if (message.m12 != null && message.hasOwnProperty("m12"))
                    object.m12 = options.json && !isFinite(message.m12) ? String(message.m12) : message.m12;
                if (message.m13 != null && message.hasOwnProperty("m13"))
                    object.m13 = options.json && !isFinite(message.m13) ? String(message.m13) : message.m13;
                if (message.m21 != null && message.hasOwnProperty("m21"))
                    object.m21 = options.json && !isFinite(message.m21) ? String(message.m21) : message.m21;
                if (message.m22 != null && message.hasOwnProperty("m22"))
                    object.m22 = options.json && !isFinite(message.m22) ? String(message.m22) : message.m22;
                if (message.m23 != null && message.hasOwnProperty("m23"))
                    object.m23 = options.json && !isFinite(message.m23) ? String(message.m23) : message.m23;
                if (message.m31 != null && message.hasOwnProperty("m31"))
                    object.m31 = options.json && !isFinite(message.m31) ? String(message.m31) : message.m31;
                if (message.m32 != null && message.hasOwnProperty("m32"))
                    object.m32 = options.json && !isFinite(message.m32) ? String(message.m32) : message.m32;
                if (message.m33 != null && message.hasOwnProperty("m33"))
                    object.m33 = options.json && !isFinite(message.m33) ? String(message.m33) : message.m33;
                return object;
            };

            /**
             * Converts this RotationMatrix to JSON.
             * @function toJSON
             * @memberof lebai.posture.RotationMatrix
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RotationMatrix.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for RotationMatrix
             * @function getTypeUrl
             * @memberof lebai.posture.RotationMatrix
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            RotationMatrix.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.posture.RotationMatrix";
            };

            return RotationMatrix;
        })();

        posture.EulerZyx = (function() {

            /**
             * Properties of an EulerZyx.
             * @memberof lebai.posture
             * @interface IEulerZyx
             * @property {number|null} [x] EulerZyx x
             * @property {number|null} [y] EulerZyx y
             * @property {number|null} [z] EulerZyx z
             */

            /**
             * Constructs a new EulerZyx.
             * @memberof lebai.posture
             * @classdesc Represents an EulerZyx.
             * @implements IEulerZyx
             * @constructor
             * @param {lebai.posture.IEulerZyx=} [properties] Properties to set
             */
            function EulerZyx(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EulerZyx x.
             * @member {number} x
             * @memberof lebai.posture.EulerZyx
             * @instance
             */
            EulerZyx.prototype.x = 0;

            /**
             * EulerZyx y.
             * @member {number} y
             * @memberof lebai.posture.EulerZyx
             * @instance
             */
            EulerZyx.prototype.y = 0;

            /**
             * EulerZyx z.
             * @member {number} z
             * @memberof lebai.posture.EulerZyx
             * @instance
             */
            EulerZyx.prototype.z = 0;

            /**
             * Creates a new EulerZyx instance using the specified properties.
             * @function create
             * @memberof lebai.posture.EulerZyx
             * @static
             * @param {lebai.posture.IEulerZyx=} [properties] Properties to set
             * @returns {lebai.posture.EulerZyx} EulerZyx instance
             */
            EulerZyx.create = function create(properties) {
                return new EulerZyx(properties);
            };

            /**
             * Encodes the specified EulerZyx message. Does not implicitly {@link lebai.posture.EulerZyx.verify|verify} messages.
             * @function encode
             * @memberof lebai.posture.EulerZyx
             * @static
             * @param {lebai.posture.IEulerZyx} message EulerZyx message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EulerZyx.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                    writer.uint32(/* id 1, wireType 1 =*/9).double(message.x);
                if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                    writer.uint32(/* id 2, wireType 1 =*/17).double(message.y);
                if (message.z != null && Object.hasOwnProperty.call(message, "z"))
                    writer.uint32(/* id 3, wireType 1 =*/25).double(message.z);
                return writer;
            };

            /**
             * Encodes the specified EulerZyx message, length delimited. Does not implicitly {@link lebai.posture.EulerZyx.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.posture.EulerZyx
             * @static
             * @param {lebai.posture.IEulerZyx} message EulerZyx message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EulerZyx.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EulerZyx message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.posture.EulerZyx
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.posture.EulerZyx} EulerZyx
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EulerZyx.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.posture.EulerZyx();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.x = reader.double();
                            break;
                        }
                    case 2: {
                            message.y = reader.double();
                            break;
                        }
                    case 3: {
                            message.z = reader.double();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EulerZyx message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.posture.EulerZyx
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.posture.EulerZyx} EulerZyx
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EulerZyx.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EulerZyx message.
             * @function verify
             * @memberof lebai.posture.EulerZyx
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EulerZyx.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.x != null && message.hasOwnProperty("x"))
                    if (typeof message.x !== "number")
                        return "x: number expected";
                if (message.y != null && message.hasOwnProperty("y"))
                    if (typeof message.y !== "number")
                        return "y: number expected";
                if (message.z != null && message.hasOwnProperty("z"))
                    if (typeof message.z !== "number")
                        return "z: number expected";
                return null;
            };

            /**
             * Creates an EulerZyx message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.posture.EulerZyx
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.posture.EulerZyx} EulerZyx
             */
            EulerZyx.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.posture.EulerZyx)
                    return object;
                var message = new $root.lebai.posture.EulerZyx();
                if (object.x != null)
                    message.x = Number(object.x);
                if (object.y != null)
                    message.y = Number(object.y);
                if (object.z != null)
                    message.z = Number(object.z);
                return message;
            };

            /**
             * Creates a plain object from an EulerZyx message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.posture.EulerZyx
             * @static
             * @param {lebai.posture.EulerZyx} message EulerZyx
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EulerZyx.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.x = 0;
                    object.y = 0;
                    object.z = 0;
                }
                if (message.x != null && message.hasOwnProperty("x"))
                    object.x = options.json && !isFinite(message.x) ? String(message.x) : message.x;
                if (message.y != null && message.hasOwnProperty("y"))
                    object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;
                if (message.z != null && message.hasOwnProperty("z"))
                    object.z = options.json && !isFinite(message.z) ? String(message.z) : message.z;
                return object;
            };

            /**
             * Converts this EulerZyx to JSON.
             * @function toJSON
             * @memberof lebai.posture.EulerZyx
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EulerZyx.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for EulerZyx
             * @function getTypeUrl
             * @memberof lebai.posture.EulerZyx
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            EulerZyx.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.posture.EulerZyx";
            };

            return EulerZyx;
        })();

        posture.Quaternion = (function() {

            /**
             * Properties of a Quaternion.
             * @memberof lebai.posture
             * @interface IQuaternion
             * @property {number|null} [w] Quaternion w
             * @property {number|null} [i] Quaternion i
             * @property {number|null} [j] Quaternion j
             * @property {number|null} [k] Quaternion k
             */

            /**
             * Constructs a new Quaternion.
             * @memberof lebai.posture
             * @classdesc Represents a Quaternion.
             * @implements IQuaternion
             * @constructor
             * @param {lebai.posture.IQuaternion=} [properties] Properties to set
             */
            function Quaternion(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Quaternion w.
             * @member {number} w
             * @memberof lebai.posture.Quaternion
             * @instance
             */
            Quaternion.prototype.w = 0;

            /**
             * Quaternion i.
             * @member {number} i
             * @memberof lebai.posture.Quaternion
             * @instance
             */
            Quaternion.prototype.i = 0;

            /**
             * Quaternion j.
             * @member {number} j
             * @memberof lebai.posture.Quaternion
             * @instance
             */
            Quaternion.prototype.j = 0;

            /**
             * Quaternion k.
             * @member {number} k
             * @memberof lebai.posture.Quaternion
             * @instance
             */
            Quaternion.prototype.k = 0;

            /**
             * Creates a new Quaternion instance using the specified properties.
             * @function create
             * @memberof lebai.posture.Quaternion
             * @static
             * @param {lebai.posture.IQuaternion=} [properties] Properties to set
             * @returns {lebai.posture.Quaternion} Quaternion instance
             */
            Quaternion.create = function create(properties) {
                return new Quaternion(properties);
            };

            /**
             * Encodes the specified Quaternion message. Does not implicitly {@link lebai.posture.Quaternion.verify|verify} messages.
             * @function encode
             * @memberof lebai.posture.Quaternion
             * @static
             * @param {lebai.posture.IQuaternion} message Quaternion message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Quaternion.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.w != null && Object.hasOwnProperty.call(message, "w"))
                    writer.uint32(/* id 1, wireType 1 =*/9).double(message.w);
                if (message.i != null && Object.hasOwnProperty.call(message, "i"))
                    writer.uint32(/* id 2, wireType 1 =*/17).double(message.i);
                if (message.j != null && Object.hasOwnProperty.call(message, "j"))
                    writer.uint32(/* id 3, wireType 1 =*/25).double(message.j);
                if (message.k != null && Object.hasOwnProperty.call(message, "k"))
                    writer.uint32(/* id 4, wireType 1 =*/33).double(message.k);
                return writer;
            };

            /**
             * Encodes the specified Quaternion message, length delimited. Does not implicitly {@link lebai.posture.Quaternion.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.posture.Quaternion
             * @static
             * @param {lebai.posture.IQuaternion} message Quaternion message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Quaternion.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Quaternion message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.posture.Quaternion
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.posture.Quaternion} Quaternion
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Quaternion.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.posture.Quaternion();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.w = reader.double();
                            break;
                        }
                    case 2: {
                            message.i = reader.double();
                            break;
                        }
                    case 3: {
                            message.j = reader.double();
                            break;
                        }
                    case 4: {
                            message.k = reader.double();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Quaternion message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.posture.Quaternion
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.posture.Quaternion} Quaternion
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Quaternion.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Quaternion message.
             * @function verify
             * @memberof lebai.posture.Quaternion
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Quaternion.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.w != null && message.hasOwnProperty("w"))
                    if (typeof message.w !== "number")
                        return "w: number expected";
                if (message.i != null && message.hasOwnProperty("i"))
                    if (typeof message.i !== "number")
                        return "i: number expected";
                if (message.j != null && message.hasOwnProperty("j"))
                    if (typeof message.j !== "number")
                        return "j: number expected";
                if (message.k != null && message.hasOwnProperty("k"))
                    if (typeof message.k !== "number")
                        return "k: number expected";
                return null;
            };

            /**
             * Creates a Quaternion message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.posture.Quaternion
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.posture.Quaternion} Quaternion
             */
            Quaternion.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.posture.Quaternion)
                    return object;
                var message = new $root.lebai.posture.Quaternion();
                if (object.w != null)
                    message.w = Number(object.w);
                if (object.i != null)
                    message.i = Number(object.i);
                if (object.j != null)
                    message.j = Number(object.j);
                if (object.k != null)
                    message.k = Number(object.k);
                return message;
            };

            /**
             * Creates a plain object from a Quaternion message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.posture.Quaternion
             * @static
             * @param {lebai.posture.Quaternion} message Quaternion
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Quaternion.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.w = 0;
                    object.i = 0;
                    object.j = 0;
                    object.k = 0;
                }
                if (message.w != null && message.hasOwnProperty("w"))
                    object.w = options.json && !isFinite(message.w) ? String(message.w) : message.w;
                if (message.i != null && message.hasOwnProperty("i"))
                    object.i = options.json && !isFinite(message.i) ? String(message.i) : message.i;
                if (message.j != null && message.hasOwnProperty("j"))
                    object.j = options.json && !isFinite(message.j) ? String(message.j) : message.j;
                if (message.k != null && message.hasOwnProperty("k"))
                    object.k = options.json && !isFinite(message.k) ? String(message.k) : message.k;
                return object;
            };

            /**
             * Converts this Quaternion to JSON.
             * @function toJSON
             * @memberof lebai.posture.Quaternion
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Quaternion.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Quaternion
             * @function getTypeUrl
             * @memberof lebai.posture.Quaternion
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Quaternion.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.posture.Quaternion";
            };

            return Quaternion;
        })();

        posture.Rotation = (function() {

            /**
             * Properties of a Rotation.
             * @memberof lebai.posture
             * @interface IRotation
             * @property {lebai.posture.IEulerZyx|null} [eulerZyx] Rotation eulerZyx
             * @property {lebai.posture.IQuaternion|null} [quaternion] Rotation quaternion
             * @property {lebai.posture.IRotationMatrix|null} [matrix] Rotation matrix
             */

            /**
             * Constructs a new Rotation.
             * @memberof lebai.posture
             * @classdesc Represents a Rotation.
             * @implements IRotation
             * @constructor
             * @param {lebai.posture.IRotation=} [properties] Properties to set
             */
            function Rotation(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Rotation eulerZyx.
             * @member {lebai.posture.IEulerZyx|null|undefined} eulerZyx
             * @memberof lebai.posture.Rotation
             * @instance
             */
            Rotation.prototype.eulerZyx = null;

            /**
             * Rotation quaternion.
             * @member {lebai.posture.IQuaternion|null|undefined} quaternion
             * @memberof lebai.posture.Rotation
             * @instance
             */
            Rotation.prototype.quaternion = null;

            /**
             * Rotation matrix.
             * @member {lebai.posture.IRotationMatrix|null|undefined} matrix
             * @memberof lebai.posture.Rotation
             * @instance
             */
            Rotation.prototype.matrix = null;

            /**
             * Creates a new Rotation instance using the specified properties.
             * @function create
             * @memberof lebai.posture.Rotation
             * @static
             * @param {lebai.posture.IRotation=} [properties] Properties to set
             * @returns {lebai.posture.Rotation} Rotation instance
             */
            Rotation.create = function create(properties) {
                return new Rotation(properties);
            };

            /**
             * Encodes the specified Rotation message. Does not implicitly {@link lebai.posture.Rotation.verify|verify} messages.
             * @function encode
             * @memberof lebai.posture.Rotation
             * @static
             * @param {lebai.posture.IRotation} message Rotation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Rotation.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.eulerZyx != null && Object.hasOwnProperty.call(message, "eulerZyx"))
                    $root.lebai.posture.EulerZyx.encode(message.eulerZyx, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.quaternion != null && Object.hasOwnProperty.call(message, "quaternion"))
                    $root.lebai.posture.Quaternion.encode(message.quaternion, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.matrix != null && Object.hasOwnProperty.call(message, "matrix"))
                    $root.lebai.posture.RotationMatrix.encode(message.matrix, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Rotation message, length delimited. Does not implicitly {@link lebai.posture.Rotation.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.posture.Rotation
             * @static
             * @param {lebai.posture.IRotation} message Rotation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Rotation.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Rotation message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.posture.Rotation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.posture.Rotation} Rotation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Rotation.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.posture.Rotation();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.eulerZyx = $root.lebai.posture.EulerZyx.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.quaternion = $root.lebai.posture.Quaternion.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            message.matrix = $root.lebai.posture.RotationMatrix.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Rotation message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.posture.Rotation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.posture.Rotation} Rotation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Rotation.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Rotation message.
             * @function verify
             * @memberof lebai.posture.Rotation
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Rotation.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.eulerZyx != null && message.hasOwnProperty("eulerZyx")) {
                    var error = $root.lebai.posture.EulerZyx.verify(message.eulerZyx);
                    if (error)
                        return "eulerZyx." + error;
                }
                if (message.quaternion != null && message.hasOwnProperty("quaternion")) {
                    var error = $root.lebai.posture.Quaternion.verify(message.quaternion);
                    if (error)
                        return "quaternion." + error;
                }
                if (message.matrix != null && message.hasOwnProperty("matrix")) {
                    var error = $root.lebai.posture.RotationMatrix.verify(message.matrix);
                    if (error)
                        return "matrix." + error;
                }
                return null;
            };

            /**
             * Creates a Rotation message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.posture.Rotation
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.posture.Rotation} Rotation
             */
            Rotation.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.posture.Rotation)
                    return object;
                var message = new $root.lebai.posture.Rotation();
                if (object.eulerZyx != null) {
                    if (typeof object.eulerZyx !== "object")
                        throw TypeError(".lebai.posture.Rotation.eulerZyx: object expected");
                    message.eulerZyx = $root.lebai.posture.EulerZyx.fromObject(object.eulerZyx);
                }
                if (object.quaternion != null) {
                    if (typeof object.quaternion !== "object")
                        throw TypeError(".lebai.posture.Rotation.quaternion: object expected");
                    message.quaternion = $root.lebai.posture.Quaternion.fromObject(object.quaternion);
                }
                if (object.matrix != null) {
                    if (typeof object.matrix !== "object")
                        throw TypeError(".lebai.posture.Rotation.matrix: object expected");
                    message.matrix = $root.lebai.posture.RotationMatrix.fromObject(object.matrix);
                }
                return message;
            };

            /**
             * Creates a plain object from a Rotation message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.posture.Rotation
             * @static
             * @param {lebai.posture.Rotation} message Rotation
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Rotation.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.eulerZyx = null;
                    object.quaternion = null;
                    object.matrix = null;
                }
                if (message.eulerZyx != null && message.hasOwnProperty("eulerZyx"))
                    object.eulerZyx = $root.lebai.posture.EulerZyx.toObject(message.eulerZyx, options);
                if (message.quaternion != null && message.hasOwnProperty("quaternion"))
                    object.quaternion = $root.lebai.posture.Quaternion.toObject(message.quaternion, options);
                if (message.matrix != null && message.hasOwnProperty("matrix"))
                    object.matrix = $root.lebai.posture.RotationMatrix.toObject(message.matrix, options);
                return object;
            };

            /**
             * Converts this Rotation to JSON.
             * @function toJSON
             * @memberof lebai.posture.Rotation
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Rotation.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Rotation
             * @function getTypeUrl
             * @memberof lebai.posture.Rotation
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Rotation.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.posture.Rotation";
            };

            return Rotation;
        })();

        posture.Position = (function() {

            /**
             * Properties of a Position.
             * @memberof lebai.posture
             * @interface IPosition
             * @property {number|null} [x] Position x
             * @property {number|null} [y] Position y
             * @property {number|null} [z] Position z
             */

            /**
             * Constructs a new Position.
             * @memberof lebai.posture
             * @classdesc Represents a Position.
             * @implements IPosition
             * @constructor
             * @param {lebai.posture.IPosition=} [properties] Properties to set
             */
            function Position(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Position x.
             * @member {number} x
             * @memberof lebai.posture.Position
             * @instance
             */
            Position.prototype.x = 0;

            /**
             * Position y.
             * @member {number} y
             * @memberof lebai.posture.Position
             * @instance
             */
            Position.prototype.y = 0;

            /**
             * Position z.
             * @member {number} z
             * @memberof lebai.posture.Position
             * @instance
             */
            Position.prototype.z = 0;

            /**
             * Creates a new Position instance using the specified properties.
             * @function create
             * @memberof lebai.posture.Position
             * @static
             * @param {lebai.posture.IPosition=} [properties] Properties to set
             * @returns {lebai.posture.Position} Position instance
             */
            Position.create = function create(properties) {
                return new Position(properties);
            };

            /**
             * Encodes the specified Position message. Does not implicitly {@link lebai.posture.Position.verify|verify} messages.
             * @function encode
             * @memberof lebai.posture.Position
             * @static
             * @param {lebai.posture.IPosition} message Position message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Position.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                    writer.uint32(/* id 1, wireType 1 =*/9).double(message.x);
                if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                    writer.uint32(/* id 2, wireType 1 =*/17).double(message.y);
                if (message.z != null && Object.hasOwnProperty.call(message, "z"))
                    writer.uint32(/* id 3, wireType 1 =*/25).double(message.z);
                return writer;
            };

            /**
             * Encodes the specified Position message, length delimited. Does not implicitly {@link lebai.posture.Position.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.posture.Position
             * @static
             * @param {lebai.posture.IPosition} message Position message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Position.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Position message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.posture.Position
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.posture.Position} Position
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Position.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.posture.Position();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.x = reader.double();
                            break;
                        }
                    case 2: {
                            message.y = reader.double();
                            break;
                        }
                    case 3: {
                            message.z = reader.double();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Position message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.posture.Position
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.posture.Position} Position
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Position.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Position message.
             * @function verify
             * @memberof lebai.posture.Position
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Position.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.x != null && message.hasOwnProperty("x"))
                    if (typeof message.x !== "number")
                        return "x: number expected";
                if (message.y != null && message.hasOwnProperty("y"))
                    if (typeof message.y !== "number")
                        return "y: number expected";
                if (message.z != null && message.hasOwnProperty("z"))
                    if (typeof message.z !== "number")
                        return "z: number expected";
                return null;
            };

            /**
             * Creates a Position message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.posture.Position
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.posture.Position} Position
             */
            Position.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.posture.Position)
                    return object;
                var message = new $root.lebai.posture.Position();
                if (object.x != null)
                    message.x = Number(object.x);
                if (object.y != null)
                    message.y = Number(object.y);
                if (object.z != null)
                    message.z = Number(object.z);
                return message;
            };

            /**
             * Creates a plain object from a Position message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.posture.Position
             * @static
             * @param {lebai.posture.Position} message Position
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Position.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.x = 0;
                    object.y = 0;
                    object.z = 0;
                }
                if (message.x != null && message.hasOwnProperty("x"))
                    object.x = options.json && !isFinite(message.x) ? String(message.x) : message.x;
                if (message.y != null && message.hasOwnProperty("y"))
                    object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;
                if (message.z != null && message.hasOwnProperty("z"))
                    object.z = options.json && !isFinite(message.z) ? String(message.z) : message.z;
                return object;
            };

            /**
             * Converts this Position to JSON.
             * @function toJSON
             * @memberof lebai.posture.Position
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Position.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Position
             * @function getTypeUrl
             * @memberof lebai.posture.Position
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Position.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.posture.Position";
            };

            return Position;
        })();

        posture.CartesianPose = (function() {

            /**
             * Properties of a CartesianPose.
             * @memberof lebai.posture
             * @interface ICartesianPose
             * @property {lebai.posture.IPosition|null} [position] CartesianPose position
             * @property {lebai.posture.IRotation|null} [rotation] CartesianPose rotation
             */

            /**
             * Constructs a new CartesianPose.
             * @memberof lebai.posture
             * @classdesc Represents a CartesianPose.
             * @implements ICartesianPose
             * @constructor
             * @param {lebai.posture.ICartesianPose=} [properties] Properties to set
             */
            function CartesianPose(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CartesianPose position.
             * @member {lebai.posture.IPosition|null|undefined} position
             * @memberof lebai.posture.CartesianPose
             * @instance
             */
            CartesianPose.prototype.position = null;

            /**
             * CartesianPose rotation.
             * @member {lebai.posture.IRotation|null|undefined} rotation
             * @memberof lebai.posture.CartesianPose
             * @instance
             */
            CartesianPose.prototype.rotation = null;

            /**
             * Creates a new CartesianPose instance using the specified properties.
             * @function create
             * @memberof lebai.posture.CartesianPose
             * @static
             * @param {lebai.posture.ICartesianPose=} [properties] Properties to set
             * @returns {lebai.posture.CartesianPose} CartesianPose instance
             */
            CartesianPose.create = function create(properties) {
                return new CartesianPose(properties);
            };

            /**
             * Encodes the specified CartesianPose message. Does not implicitly {@link lebai.posture.CartesianPose.verify|verify} messages.
             * @function encode
             * @memberof lebai.posture.CartesianPose
             * @static
             * @param {lebai.posture.ICartesianPose} message CartesianPose message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CartesianPose.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.position != null && Object.hasOwnProperty.call(message, "position"))
                    $root.lebai.posture.Position.encode(message.position, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.rotation != null && Object.hasOwnProperty.call(message, "rotation"))
                    $root.lebai.posture.Rotation.encode(message.rotation, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified CartesianPose message, length delimited. Does not implicitly {@link lebai.posture.CartesianPose.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.posture.CartesianPose
             * @static
             * @param {lebai.posture.ICartesianPose} message CartesianPose message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CartesianPose.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CartesianPose message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.posture.CartesianPose
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.posture.CartesianPose} CartesianPose
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CartesianPose.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.posture.CartesianPose();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.position = $root.lebai.posture.Position.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.rotation = $root.lebai.posture.Rotation.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CartesianPose message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.posture.CartesianPose
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.posture.CartesianPose} CartesianPose
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CartesianPose.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CartesianPose message.
             * @function verify
             * @memberof lebai.posture.CartesianPose
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CartesianPose.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.position != null && message.hasOwnProperty("position")) {
                    var error = $root.lebai.posture.Position.verify(message.position);
                    if (error)
                        return "position." + error;
                }
                if (message.rotation != null && message.hasOwnProperty("rotation")) {
                    var error = $root.lebai.posture.Rotation.verify(message.rotation);
                    if (error)
                        return "rotation." + error;
                }
                return null;
            };

            /**
             * Creates a CartesianPose message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.posture.CartesianPose
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.posture.CartesianPose} CartesianPose
             */
            CartesianPose.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.posture.CartesianPose)
                    return object;
                var message = new $root.lebai.posture.CartesianPose();
                if (object.position != null) {
                    if (typeof object.position !== "object")
                        throw TypeError(".lebai.posture.CartesianPose.position: object expected");
                    message.position = $root.lebai.posture.Position.fromObject(object.position);
                }
                if (object.rotation != null) {
                    if (typeof object.rotation !== "object")
                        throw TypeError(".lebai.posture.CartesianPose.rotation: object expected");
                    message.rotation = $root.lebai.posture.Rotation.fromObject(object.rotation);
                }
                return message;
            };

            /**
             * Creates a plain object from a CartesianPose message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.posture.CartesianPose
             * @static
             * @param {lebai.posture.CartesianPose} message CartesianPose
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CartesianPose.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.position = null;
                    object.rotation = null;
                }
                if (message.position != null && message.hasOwnProperty("position"))
                    object.position = $root.lebai.posture.Position.toObject(message.position, options);
                if (message.rotation != null && message.hasOwnProperty("rotation"))
                    object.rotation = $root.lebai.posture.Rotation.toObject(message.rotation, options);
                return object;
            };

            /**
             * Converts this CartesianPose to JSON.
             * @function toJSON
             * @memberof lebai.posture.CartesianPose
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CartesianPose.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for CartesianPose
             * @function getTypeUrl
             * @memberof lebai.posture.CartesianPose
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            CartesianPose.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.posture.CartesianPose";
            };

            return CartesianPose;
        })();

        posture.CartesianMatrix = (function() {

            /**
             * Properties of a CartesianMatrix.
             * @memberof lebai.posture
             * @interface ICartesianMatrix
             * @property {number|null} [m11] CartesianMatrix m11
             * @property {number|null} [m12] CartesianMatrix m12
             * @property {number|null} [m13] CartesianMatrix m13
             * @property {number|null} [m14] CartesianMatrix m14
             * @property {number|null} [m21] CartesianMatrix m21
             * @property {number|null} [m22] CartesianMatrix m22
             * @property {number|null} [m23] CartesianMatrix m23
             * @property {number|null} [m24] CartesianMatrix m24
             * @property {number|null} [m31] CartesianMatrix m31
             * @property {number|null} [m32] CartesianMatrix m32
             * @property {number|null} [m33] CartesianMatrix m33
             * @property {number|null} [m34] CartesianMatrix m34
             * @property {number|null} [m41] CartesianMatrix m41
             * @property {number|null} [m42] CartesianMatrix m42
             * @property {number|null} [m43] CartesianMatrix m43
             * @property {number|null} [m44] CartesianMatrix m44
             */

            /**
             * Constructs a new CartesianMatrix.
             * @memberof lebai.posture
             * @classdesc Represents a CartesianMatrix.
             * @implements ICartesianMatrix
             * @constructor
             * @param {lebai.posture.ICartesianMatrix=} [properties] Properties to set
             */
            function CartesianMatrix(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CartesianMatrix m11.
             * @member {number} m11
             * @memberof lebai.posture.CartesianMatrix
             * @instance
             */
            CartesianMatrix.prototype.m11 = 0;

            /**
             * CartesianMatrix m12.
             * @member {number} m12
             * @memberof lebai.posture.CartesianMatrix
             * @instance
             */
            CartesianMatrix.prototype.m12 = 0;

            /**
             * CartesianMatrix m13.
             * @member {number} m13
             * @memberof lebai.posture.CartesianMatrix
             * @instance
             */
            CartesianMatrix.prototype.m13 = 0;

            /**
             * CartesianMatrix m14.
             * @member {number} m14
             * @memberof lebai.posture.CartesianMatrix
             * @instance
             */
            CartesianMatrix.prototype.m14 = 0;

            /**
             * CartesianMatrix m21.
             * @member {number} m21
             * @memberof lebai.posture.CartesianMatrix
             * @instance
             */
            CartesianMatrix.prototype.m21 = 0;

            /**
             * CartesianMatrix m22.
             * @member {number} m22
             * @memberof lebai.posture.CartesianMatrix
             * @instance
             */
            CartesianMatrix.prototype.m22 = 0;

            /**
             * CartesianMatrix m23.
             * @member {number} m23
             * @memberof lebai.posture.CartesianMatrix
             * @instance
             */
            CartesianMatrix.prototype.m23 = 0;

            /**
             * CartesianMatrix m24.
             * @member {number} m24
             * @memberof lebai.posture.CartesianMatrix
             * @instance
             */
            CartesianMatrix.prototype.m24 = 0;

            /**
             * CartesianMatrix m31.
             * @member {number} m31
             * @memberof lebai.posture.CartesianMatrix
             * @instance
             */
            CartesianMatrix.prototype.m31 = 0;

            /**
             * CartesianMatrix m32.
             * @member {number} m32
             * @memberof lebai.posture.CartesianMatrix
             * @instance
             */
            CartesianMatrix.prototype.m32 = 0;

            /**
             * CartesianMatrix m33.
             * @member {number} m33
             * @memberof lebai.posture.CartesianMatrix
             * @instance
             */
            CartesianMatrix.prototype.m33 = 0;

            /**
             * CartesianMatrix m34.
             * @member {number} m34
             * @memberof lebai.posture.CartesianMatrix
             * @instance
             */
            CartesianMatrix.prototype.m34 = 0;

            /**
             * CartesianMatrix m41.
             * @member {number} m41
             * @memberof lebai.posture.CartesianMatrix
             * @instance
             */
            CartesianMatrix.prototype.m41 = 0;

            /**
             * CartesianMatrix m42.
             * @member {number} m42
             * @memberof lebai.posture.CartesianMatrix
             * @instance
             */
            CartesianMatrix.prototype.m42 = 0;

            /**
             * CartesianMatrix m43.
             * @member {number} m43
             * @memberof lebai.posture.CartesianMatrix
             * @instance
             */
            CartesianMatrix.prototype.m43 = 0;

            /**
             * CartesianMatrix m44.
             * @member {number} m44
             * @memberof lebai.posture.CartesianMatrix
             * @instance
             */
            CartesianMatrix.prototype.m44 = 0;

            /**
             * Creates a new CartesianMatrix instance using the specified properties.
             * @function create
             * @memberof lebai.posture.CartesianMatrix
             * @static
             * @param {lebai.posture.ICartesianMatrix=} [properties] Properties to set
             * @returns {lebai.posture.CartesianMatrix} CartesianMatrix instance
             */
            CartesianMatrix.create = function create(properties) {
                return new CartesianMatrix(properties);
            };

            /**
             * Encodes the specified CartesianMatrix message. Does not implicitly {@link lebai.posture.CartesianMatrix.verify|verify} messages.
             * @function encode
             * @memberof lebai.posture.CartesianMatrix
             * @static
             * @param {lebai.posture.ICartesianMatrix} message CartesianMatrix message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CartesianMatrix.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.m11 != null && Object.hasOwnProperty.call(message, "m11"))
                    writer.uint32(/* id 11, wireType 1 =*/89).double(message.m11);
                if (message.m12 != null && Object.hasOwnProperty.call(message, "m12"))
                    writer.uint32(/* id 12, wireType 1 =*/97).double(message.m12);
                if (message.m13 != null && Object.hasOwnProperty.call(message, "m13"))
                    writer.uint32(/* id 13, wireType 1 =*/105).double(message.m13);
                if (message.m14 != null && Object.hasOwnProperty.call(message, "m14"))
                    writer.uint32(/* id 14, wireType 1 =*/113).double(message.m14);
                if (message.m21 != null && Object.hasOwnProperty.call(message, "m21"))
                    writer.uint32(/* id 21, wireType 1 =*/169).double(message.m21);
                if (message.m22 != null && Object.hasOwnProperty.call(message, "m22"))
                    writer.uint32(/* id 22, wireType 1 =*/177).double(message.m22);
                if (message.m23 != null && Object.hasOwnProperty.call(message, "m23"))
                    writer.uint32(/* id 23, wireType 1 =*/185).double(message.m23);
                if (message.m24 != null && Object.hasOwnProperty.call(message, "m24"))
                    writer.uint32(/* id 24, wireType 1 =*/193).double(message.m24);
                if (message.m31 != null && Object.hasOwnProperty.call(message, "m31"))
                    writer.uint32(/* id 31, wireType 1 =*/249).double(message.m31);
                if (message.m32 != null && Object.hasOwnProperty.call(message, "m32"))
                    writer.uint32(/* id 32, wireType 1 =*/257).double(message.m32);
                if (message.m33 != null && Object.hasOwnProperty.call(message, "m33"))
                    writer.uint32(/* id 33, wireType 1 =*/265).double(message.m33);
                if (message.m34 != null && Object.hasOwnProperty.call(message, "m34"))
                    writer.uint32(/* id 34, wireType 1 =*/273).double(message.m34);
                if (message.m41 != null && Object.hasOwnProperty.call(message, "m41"))
                    writer.uint32(/* id 41, wireType 1 =*/329).double(message.m41);
                if (message.m42 != null && Object.hasOwnProperty.call(message, "m42"))
                    writer.uint32(/* id 42, wireType 1 =*/337).double(message.m42);
                if (message.m43 != null && Object.hasOwnProperty.call(message, "m43"))
                    writer.uint32(/* id 43, wireType 1 =*/345).double(message.m43);
                if (message.m44 != null && Object.hasOwnProperty.call(message, "m44"))
                    writer.uint32(/* id 44, wireType 1 =*/353).double(message.m44);
                return writer;
            };

            /**
             * Encodes the specified CartesianMatrix message, length delimited. Does not implicitly {@link lebai.posture.CartesianMatrix.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.posture.CartesianMatrix
             * @static
             * @param {lebai.posture.ICartesianMatrix} message CartesianMatrix message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CartesianMatrix.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CartesianMatrix message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.posture.CartesianMatrix
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.posture.CartesianMatrix} CartesianMatrix
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CartesianMatrix.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.posture.CartesianMatrix();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 11: {
                            message.m11 = reader.double();
                            break;
                        }
                    case 12: {
                            message.m12 = reader.double();
                            break;
                        }
                    case 13: {
                            message.m13 = reader.double();
                            break;
                        }
                    case 14: {
                            message.m14 = reader.double();
                            break;
                        }
                    case 21: {
                            message.m21 = reader.double();
                            break;
                        }
                    case 22: {
                            message.m22 = reader.double();
                            break;
                        }
                    case 23: {
                            message.m23 = reader.double();
                            break;
                        }
                    case 24: {
                            message.m24 = reader.double();
                            break;
                        }
                    case 31: {
                            message.m31 = reader.double();
                            break;
                        }
                    case 32: {
                            message.m32 = reader.double();
                            break;
                        }
                    case 33: {
                            message.m33 = reader.double();
                            break;
                        }
                    case 34: {
                            message.m34 = reader.double();
                            break;
                        }
                    case 41: {
                            message.m41 = reader.double();
                            break;
                        }
                    case 42: {
                            message.m42 = reader.double();
                            break;
                        }
                    case 43: {
                            message.m43 = reader.double();
                            break;
                        }
                    case 44: {
                            message.m44 = reader.double();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CartesianMatrix message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.posture.CartesianMatrix
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.posture.CartesianMatrix} CartesianMatrix
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CartesianMatrix.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CartesianMatrix message.
             * @function verify
             * @memberof lebai.posture.CartesianMatrix
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CartesianMatrix.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.m11 != null && message.hasOwnProperty("m11"))
                    if (typeof message.m11 !== "number")
                        return "m11: number expected";
                if (message.m12 != null && message.hasOwnProperty("m12"))
                    if (typeof message.m12 !== "number")
                        return "m12: number expected";
                if (message.m13 != null && message.hasOwnProperty("m13"))
                    if (typeof message.m13 !== "number")
                        return "m13: number expected";
                if (message.m14 != null && message.hasOwnProperty("m14"))
                    if (typeof message.m14 !== "number")
                        return "m14: number expected";
                if (message.m21 != null && message.hasOwnProperty("m21"))
                    if (typeof message.m21 !== "number")
                        return "m21: number expected";
                if (message.m22 != null && message.hasOwnProperty("m22"))
                    if (typeof message.m22 !== "number")
                        return "m22: number expected";
                if (message.m23 != null && message.hasOwnProperty("m23"))
                    if (typeof message.m23 !== "number")
                        return "m23: number expected";
                if (message.m24 != null && message.hasOwnProperty("m24"))
                    if (typeof message.m24 !== "number")
                        return "m24: number expected";
                if (message.m31 != null && message.hasOwnProperty("m31"))
                    if (typeof message.m31 !== "number")
                        return "m31: number expected";
                if (message.m32 != null && message.hasOwnProperty("m32"))
                    if (typeof message.m32 !== "number")
                        return "m32: number expected";
                if (message.m33 != null && message.hasOwnProperty("m33"))
                    if (typeof message.m33 !== "number")
                        return "m33: number expected";
                if (message.m34 != null && message.hasOwnProperty("m34"))
                    if (typeof message.m34 !== "number")
                        return "m34: number expected";
                if (message.m41 != null && message.hasOwnProperty("m41"))
                    if (typeof message.m41 !== "number")
                        return "m41: number expected";
                if (message.m42 != null && message.hasOwnProperty("m42"))
                    if (typeof message.m42 !== "number")
                        return "m42: number expected";
                if (message.m43 != null && message.hasOwnProperty("m43"))
                    if (typeof message.m43 !== "number")
                        return "m43: number expected";
                if (message.m44 != null && message.hasOwnProperty("m44"))
                    if (typeof message.m44 !== "number")
                        return "m44: number expected";
                return null;
            };

            /**
             * Creates a CartesianMatrix message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.posture.CartesianMatrix
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.posture.CartesianMatrix} CartesianMatrix
             */
            CartesianMatrix.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.posture.CartesianMatrix)
                    return object;
                var message = new $root.lebai.posture.CartesianMatrix();
                if (object.m11 != null)
                    message.m11 = Number(object.m11);
                if (object.m12 != null)
                    message.m12 = Number(object.m12);
                if (object.m13 != null)
                    message.m13 = Number(object.m13);
                if (object.m14 != null)
                    message.m14 = Number(object.m14);
                if (object.m21 != null)
                    message.m21 = Number(object.m21);
                if (object.m22 != null)
                    message.m22 = Number(object.m22);
                if (object.m23 != null)
                    message.m23 = Number(object.m23);
                if (object.m24 != null)
                    message.m24 = Number(object.m24);
                if (object.m31 != null)
                    message.m31 = Number(object.m31);
                if (object.m32 != null)
                    message.m32 = Number(object.m32);
                if (object.m33 != null)
                    message.m33 = Number(object.m33);
                if (object.m34 != null)
                    message.m34 = Number(object.m34);
                if (object.m41 != null)
                    message.m41 = Number(object.m41);
                if (object.m42 != null)
                    message.m42 = Number(object.m42);
                if (object.m43 != null)
                    message.m43 = Number(object.m43);
                if (object.m44 != null)
                    message.m44 = Number(object.m44);
                return message;
            };

            /**
             * Creates a plain object from a CartesianMatrix message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.posture.CartesianMatrix
             * @static
             * @param {lebai.posture.CartesianMatrix} message CartesianMatrix
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CartesianMatrix.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.m11 = 0;
                    object.m12 = 0;
                    object.m13 = 0;
                    object.m14 = 0;
                    object.m21 = 0;
                    object.m22 = 0;
                    object.m23 = 0;
                    object.m24 = 0;
                    object.m31 = 0;
                    object.m32 = 0;
                    object.m33 = 0;
                    object.m34 = 0;
                    object.m41 = 0;
                    object.m42 = 0;
                    object.m43 = 0;
                    object.m44 = 0;
                }
                if (message.m11 != null && message.hasOwnProperty("m11"))
                    object.m11 = options.json && !isFinite(message.m11) ? String(message.m11) : message.m11;
                if (message.m12 != null && message.hasOwnProperty("m12"))
                    object.m12 = options.json && !isFinite(message.m12) ? String(message.m12) : message.m12;
                if (message.m13 != null && message.hasOwnProperty("m13"))
                    object.m13 = options.json && !isFinite(message.m13) ? String(message.m13) : message.m13;
                if (message.m14 != null && message.hasOwnProperty("m14"))
                    object.m14 = options.json && !isFinite(message.m14) ? String(message.m14) : message.m14;
                if (message.m21 != null && message.hasOwnProperty("m21"))
                    object.m21 = options.json && !isFinite(message.m21) ? String(message.m21) : message.m21;
                if (message.m22 != null && message.hasOwnProperty("m22"))
                    object.m22 = options.json && !isFinite(message.m22) ? String(message.m22) : message.m22;
                if (message.m23 != null && message.hasOwnProperty("m23"))
                    object.m23 = options.json && !isFinite(message.m23) ? String(message.m23) : message.m23;
                if (message.m24 != null && message.hasOwnProperty("m24"))
                    object.m24 = options.json && !isFinite(message.m24) ? String(message.m24) : message.m24;
                if (message.m31 != null && message.hasOwnProperty("m31"))
                    object.m31 = options.json && !isFinite(message.m31) ? String(message.m31) : message.m31;
                if (message.m32 != null && message.hasOwnProperty("m32"))
                    object.m32 = options.json && !isFinite(message.m32) ? String(message.m32) : message.m32;
                if (message.m33 != null && message.hasOwnProperty("m33"))
                    object.m33 = options.json && !isFinite(message.m33) ? String(message.m33) : message.m33;
                if (message.m34 != null && message.hasOwnProperty("m34"))
                    object.m34 = options.json && !isFinite(message.m34) ? String(message.m34) : message.m34;
                if (message.m41 != null && message.hasOwnProperty("m41"))
                    object.m41 = options.json && !isFinite(message.m41) ? String(message.m41) : message.m41;
                if (message.m42 != null && message.hasOwnProperty("m42"))
                    object.m42 = options.json && !isFinite(message.m42) ? String(message.m42) : message.m42;
                if (message.m43 != null && message.hasOwnProperty("m43"))
                    object.m43 = options.json && !isFinite(message.m43) ? String(message.m43) : message.m43;
                if (message.m44 != null && message.hasOwnProperty("m44"))
                    object.m44 = options.json && !isFinite(message.m44) ? String(message.m44) : message.m44;
                return object;
            };

            /**
             * Converts this CartesianMatrix to JSON.
             * @function toJSON
             * @memberof lebai.posture.CartesianMatrix
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CartesianMatrix.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for CartesianMatrix
             * @function getTypeUrl
             * @memberof lebai.posture.CartesianMatrix
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            CartesianMatrix.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.posture.CartesianMatrix";
            };

            return CartesianMatrix;
        })();

        posture.CartesianFrame = (function() {

            /**
             * Properties of a CartesianFrame.
             * @memberof lebai.posture
             * @interface ICartesianFrame
             * @property {lebai.posture.CartesianFrame.Kind|null} [positionKind] CartesianFrame positionKind
             * @property {lebai.posture.IPosition|null} [position] CartesianFrame position
             * @property {lebai.posture.CartesianFrame.Kind|null} [rotationKind] CartesianFrame rotationKind
             * @property {lebai.posture.IRotation|null} [rotation] CartesianFrame rotation
             */

            /**
             * Constructs a new CartesianFrame.
             * @memberof lebai.posture
             * @classdesc Represents a CartesianFrame.
             * @implements ICartesianFrame
             * @constructor
             * @param {lebai.posture.ICartesianFrame=} [properties] Properties to set
             */
            function CartesianFrame(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CartesianFrame positionKind.
             * @member {lebai.posture.CartesianFrame.Kind} positionKind
             * @memberof lebai.posture.CartesianFrame
             * @instance
             */
            CartesianFrame.prototype.positionKind = 0;

            /**
             * CartesianFrame position.
             * @member {lebai.posture.IPosition|null|undefined} position
             * @memberof lebai.posture.CartesianFrame
             * @instance
             */
            CartesianFrame.prototype.position = null;

            /**
             * CartesianFrame rotationKind.
             * @member {lebai.posture.CartesianFrame.Kind} rotationKind
             * @memberof lebai.posture.CartesianFrame
             * @instance
             */
            CartesianFrame.prototype.rotationKind = 0;

            /**
             * CartesianFrame rotation.
             * @member {lebai.posture.IRotation|null|undefined} rotation
             * @memberof lebai.posture.CartesianFrame
             * @instance
             */
            CartesianFrame.prototype.rotation = null;

            /**
             * Creates a new CartesianFrame instance using the specified properties.
             * @function create
             * @memberof lebai.posture.CartesianFrame
             * @static
             * @param {lebai.posture.ICartesianFrame=} [properties] Properties to set
             * @returns {lebai.posture.CartesianFrame} CartesianFrame instance
             */
            CartesianFrame.create = function create(properties) {
                return new CartesianFrame(properties);
            };

            /**
             * Encodes the specified CartesianFrame message. Does not implicitly {@link lebai.posture.CartesianFrame.verify|verify} messages.
             * @function encode
             * @memberof lebai.posture.CartesianFrame
             * @static
             * @param {lebai.posture.ICartesianFrame} message CartesianFrame message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CartesianFrame.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.positionKind != null && Object.hasOwnProperty.call(message, "positionKind"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.positionKind);
                if (message.position != null && Object.hasOwnProperty.call(message, "position"))
                    $root.lebai.posture.Position.encode(message.position, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.rotationKind != null && Object.hasOwnProperty.call(message, "rotationKind"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.rotationKind);
                if (message.rotation != null && Object.hasOwnProperty.call(message, "rotation"))
                    $root.lebai.posture.Rotation.encode(message.rotation, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified CartesianFrame message, length delimited. Does not implicitly {@link lebai.posture.CartesianFrame.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.posture.CartesianFrame
             * @static
             * @param {lebai.posture.ICartesianFrame} message CartesianFrame message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CartesianFrame.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CartesianFrame message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.posture.CartesianFrame
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.posture.CartesianFrame} CartesianFrame
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CartesianFrame.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.posture.CartesianFrame();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.positionKind = reader.int32();
                            break;
                        }
                    case 2: {
                            message.position = $root.lebai.posture.Position.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            message.rotationKind = reader.int32();
                            break;
                        }
                    case 4: {
                            message.rotation = $root.lebai.posture.Rotation.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CartesianFrame message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.posture.CartesianFrame
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.posture.CartesianFrame} CartesianFrame
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CartesianFrame.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CartesianFrame message.
             * @function verify
             * @memberof lebai.posture.CartesianFrame
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CartesianFrame.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.positionKind != null && message.hasOwnProperty("positionKind"))
                    switch (message.positionKind) {
                    default:
                        return "positionKind: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 11:
                    case 12:
                    case 99:
                        break;
                    }
                if (message.position != null && message.hasOwnProperty("position")) {
                    var error = $root.lebai.posture.Position.verify(message.position);
                    if (error)
                        return "position." + error;
                }
                if (message.rotationKind != null && message.hasOwnProperty("rotationKind"))
                    switch (message.rotationKind) {
                    default:
                        return "rotationKind: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 11:
                    case 12:
                    case 99:
                        break;
                    }
                if (message.rotation != null && message.hasOwnProperty("rotation")) {
                    var error = $root.lebai.posture.Rotation.verify(message.rotation);
                    if (error)
                        return "rotation." + error;
                }
                return null;
            };

            /**
             * Creates a CartesianFrame message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.posture.CartesianFrame
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.posture.CartesianFrame} CartesianFrame
             */
            CartesianFrame.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.posture.CartesianFrame)
                    return object;
                var message = new $root.lebai.posture.CartesianFrame();
                switch (object.positionKind) {
                default:
                    if (typeof object.positionKind === "number") {
                        message.positionKind = object.positionKind;
                        break;
                    }
                    break;
                case "BASE":
                case 0:
                    message.positionKind = 0;
                    break;
                case "FLANGE":
                case 1:
                    message.positionKind = 1;
                    break;
                case "TCP":
                case 2:
                    message.positionKind = 2;
                    break;
                case "LAST_FLANGE":
                case 11:
                    message.positionKind = 11;
                    break;
                case "LAST_TCP":
                case 12:
                    message.positionKind = 12;
                    break;
                case "CUSTOM":
                case 99:
                    message.positionKind = 99;
                    break;
                }
                if (object.position != null) {
                    if (typeof object.position !== "object")
                        throw TypeError(".lebai.posture.CartesianFrame.position: object expected");
                    message.position = $root.lebai.posture.Position.fromObject(object.position);
                }
                switch (object.rotationKind) {
                default:
                    if (typeof object.rotationKind === "number") {
                        message.rotationKind = object.rotationKind;
                        break;
                    }
                    break;
                case "BASE":
                case 0:
                    message.rotationKind = 0;
                    break;
                case "FLANGE":
                case 1:
                    message.rotationKind = 1;
                    break;
                case "TCP":
                case 2:
                    message.rotationKind = 2;
                    break;
                case "LAST_FLANGE":
                case 11:
                    message.rotationKind = 11;
                    break;
                case "LAST_TCP":
                case 12:
                    message.rotationKind = 12;
                    break;
                case "CUSTOM":
                case 99:
                    message.rotationKind = 99;
                    break;
                }
                if (object.rotation != null) {
                    if (typeof object.rotation !== "object")
                        throw TypeError(".lebai.posture.CartesianFrame.rotation: object expected");
                    message.rotation = $root.lebai.posture.Rotation.fromObject(object.rotation);
                }
                return message;
            };

            /**
             * Creates a plain object from a CartesianFrame message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.posture.CartesianFrame
             * @static
             * @param {lebai.posture.CartesianFrame} message CartesianFrame
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CartesianFrame.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.positionKind = options.enums === String ? "BASE" : 0;
                    object.position = null;
                    object.rotationKind = options.enums === String ? "BASE" : 0;
                    object.rotation = null;
                }
                if (message.positionKind != null && message.hasOwnProperty("positionKind"))
                    object.positionKind = options.enums === String ? $root.lebai.posture.CartesianFrame.Kind[message.positionKind] === undefined ? message.positionKind : $root.lebai.posture.CartesianFrame.Kind[message.positionKind] : message.positionKind;
                if (message.position != null && message.hasOwnProperty("position"))
                    object.position = $root.lebai.posture.Position.toObject(message.position, options);
                if (message.rotationKind != null && message.hasOwnProperty("rotationKind"))
                    object.rotationKind = options.enums === String ? $root.lebai.posture.CartesianFrame.Kind[message.rotationKind] === undefined ? message.rotationKind : $root.lebai.posture.CartesianFrame.Kind[message.rotationKind] : message.rotationKind;
                if (message.rotation != null && message.hasOwnProperty("rotation"))
                    object.rotation = $root.lebai.posture.Rotation.toObject(message.rotation, options);
                return object;
            };

            /**
             * Converts this CartesianFrame to JSON.
             * @function toJSON
             * @memberof lebai.posture.CartesianFrame
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CartesianFrame.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for CartesianFrame
             * @function getTypeUrl
             * @memberof lebai.posture.CartesianFrame
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            CartesianFrame.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.posture.CartesianFrame";
            };

            /**
             * Kind enum.
             * @name lebai.posture.CartesianFrame.Kind
             * @enum {number}
             * @property {number} BASE=0 BASE value
             * @property {number} FLANGE=1 FLANGE value
             * @property {number} TCP=2 TCP value
             * @property {number} LAST_FLANGE=11 LAST_FLANGE value
             * @property {number} LAST_TCP=12 LAST_TCP value
             * @property {number} CUSTOM=99 CUSTOM value
             */
            CartesianFrame.Kind = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "BASE"] = 0;
                values[valuesById[1] = "FLANGE"] = 1;
                values[valuesById[2] = "TCP"] = 2;
                values[valuesById[11] = "LAST_FLANGE"] = 11;
                values[valuesById[12] = "LAST_TCP"] = 12;
                values[valuesById[99] = "CUSTOM"] = 99;
                return values;
            })();

            return CartesianFrame;
        })();

        posture.Pose = (function() {

            /**
             * Properties of a Pose.
             * @memberof lebai.posture
             * @interface IPose
             * @property {lebai.posture.Pose.Kind|null} [kind] Pose kind
             * @property {lebai.posture.ICartesianPose|null} [cart] Pose cart
             * @property {lebai.db.ILoadRequest|null} [cartFrameIndex] Pose cartFrameIndex
             * @property {lebai.posture.ICartesianFrame|null} [cartFrame] Pose cartFrame
             * @property {lebai.posture.IJointPose|null} [joint] Pose joint
             */

            /**
             * Constructs a new Pose.
             * @memberof lebai.posture
             * @classdesc Represents a Pose.
             * @implements IPose
             * @constructor
             * @param {lebai.posture.IPose=} [properties] Properties to set
             */
            function Pose(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Pose kind.
             * @member {lebai.posture.Pose.Kind} kind
             * @memberof lebai.posture.Pose
             * @instance
             */
            Pose.prototype.kind = 0;

            /**
             * Pose cart.
             * @member {lebai.posture.ICartesianPose|null|undefined} cart
             * @memberof lebai.posture.Pose
             * @instance
             */
            Pose.prototype.cart = null;

            /**
             * Pose cartFrameIndex.
             * @member {lebai.db.ILoadRequest|null|undefined} cartFrameIndex
             * @memberof lebai.posture.Pose
             * @instance
             */
            Pose.prototype.cartFrameIndex = null;

            /**
             * Pose cartFrame.
             * @member {lebai.posture.ICartesianFrame|null|undefined} cartFrame
             * @memberof lebai.posture.Pose
             * @instance
             */
            Pose.prototype.cartFrame = null;

            /**
             * Pose joint.
             * @member {lebai.posture.IJointPose|null|undefined} joint
             * @memberof lebai.posture.Pose
             * @instance
             */
            Pose.prototype.joint = null;

            /**
             * Creates a new Pose instance using the specified properties.
             * @function create
             * @memberof lebai.posture.Pose
             * @static
             * @param {lebai.posture.IPose=} [properties] Properties to set
             * @returns {lebai.posture.Pose} Pose instance
             */
            Pose.create = function create(properties) {
                return new Pose(properties);
            };

            /**
             * Encodes the specified Pose message. Does not implicitly {@link lebai.posture.Pose.verify|verify} messages.
             * @function encode
             * @memberof lebai.posture.Pose
             * @static
             * @param {lebai.posture.IPose} message Pose message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Pose.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.kind != null && Object.hasOwnProperty.call(message, "kind"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.kind);
                if (message.cart != null && Object.hasOwnProperty.call(message, "cart"))
                    $root.lebai.posture.CartesianPose.encode(message.cart, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                if (message.cartFrameIndex != null && Object.hasOwnProperty.call(message, "cartFrameIndex"))
                    $root.lebai.db.LoadRequest.encode(message.cartFrameIndex, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                if (message.cartFrame != null && Object.hasOwnProperty.call(message, "cartFrame"))
                    $root.lebai.posture.CartesianFrame.encode(message.cartFrame, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                if (message.joint != null && Object.hasOwnProperty.call(message, "joint"))
                    $root.lebai.posture.JointPose.encode(message.joint, writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Pose message, length delimited. Does not implicitly {@link lebai.posture.Pose.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.posture.Pose
             * @static
             * @param {lebai.posture.IPose} message Pose message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Pose.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Pose message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.posture.Pose
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.posture.Pose} Pose
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Pose.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.posture.Pose();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.kind = reader.int32();
                            break;
                        }
                    case 11: {
                            message.cart = $root.lebai.posture.CartesianPose.decode(reader, reader.uint32());
                            break;
                        }
                    case 12: {
                            message.cartFrameIndex = $root.lebai.db.LoadRequest.decode(reader, reader.uint32());
                            break;
                        }
                    case 13: {
                            message.cartFrame = $root.lebai.posture.CartesianFrame.decode(reader, reader.uint32());
                            break;
                        }
                    case 21: {
                            message.joint = $root.lebai.posture.JointPose.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Pose message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.posture.Pose
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.posture.Pose} Pose
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Pose.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Pose message.
             * @function verify
             * @memberof lebai.posture.Pose
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Pose.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.kind != null && message.hasOwnProperty("kind"))
                    switch (message.kind) {
                    default:
                        return "kind: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.cart != null && message.hasOwnProperty("cart")) {
                    var error = $root.lebai.posture.CartesianPose.verify(message.cart);
                    if (error)
                        return "cart." + error;
                }
                if (message.cartFrameIndex != null && message.hasOwnProperty("cartFrameIndex")) {
                    var error = $root.lebai.db.LoadRequest.verify(message.cartFrameIndex);
                    if (error)
                        return "cartFrameIndex." + error;
                }
                if (message.cartFrame != null && message.hasOwnProperty("cartFrame")) {
                    var error = $root.lebai.posture.CartesianFrame.verify(message.cartFrame);
                    if (error)
                        return "cartFrame." + error;
                }
                if (message.joint != null && message.hasOwnProperty("joint")) {
                    var error = $root.lebai.posture.JointPose.verify(message.joint);
                    if (error)
                        return "joint." + error;
                }
                return null;
            };

            /**
             * Creates a Pose message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.posture.Pose
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.posture.Pose} Pose
             */
            Pose.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.posture.Pose)
                    return object;
                var message = new $root.lebai.posture.Pose();
                switch (object.kind) {
                default:
                    if (typeof object.kind === "number") {
                        message.kind = object.kind;
                        break;
                    }
                    break;
                case "UNKNOWN":
                case 0:
                    message.kind = 0;
                    break;
                case "JOINT":
                case 1:
                    message.kind = 1;
                    break;
                case "CARTESIAN":
                case 2:
                    message.kind = 2;
                    break;
                }
                if (object.cart != null) {
                    if (typeof object.cart !== "object")
                        throw TypeError(".lebai.posture.Pose.cart: object expected");
                    message.cart = $root.lebai.posture.CartesianPose.fromObject(object.cart);
                }
                if (object.cartFrameIndex != null) {
                    if (typeof object.cartFrameIndex !== "object")
                        throw TypeError(".lebai.posture.Pose.cartFrameIndex: object expected");
                    message.cartFrameIndex = $root.lebai.db.LoadRequest.fromObject(object.cartFrameIndex);
                }
                if (object.cartFrame != null) {
                    if (typeof object.cartFrame !== "object")
                        throw TypeError(".lebai.posture.Pose.cartFrame: object expected");
                    message.cartFrame = $root.lebai.posture.CartesianFrame.fromObject(object.cartFrame);
                }
                if (object.joint != null) {
                    if (typeof object.joint !== "object")
                        throw TypeError(".lebai.posture.Pose.joint: object expected");
                    message.joint = $root.lebai.posture.JointPose.fromObject(object.joint);
                }
                return message;
            };

            /**
             * Creates a plain object from a Pose message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.posture.Pose
             * @static
             * @param {lebai.posture.Pose} message Pose
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Pose.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.kind = options.enums === String ? "UNKNOWN" : 0;
                    object.cart = null;
                    object.cartFrameIndex = null;
                    object.cartFrame = null;
                    object.joint = null;
                }
                if (message.kind != null && message.hasOwnProperty("kind"))
                    object.kind = options.enums === String ? $root.lebai.posture.Pose.Kind[message.kind] === undefined ? message.kind : $root.lebai.posture.Pose.Kind[message.kind] : message.kind;
                if (message.cart != null && message.hasOwnProperty("cart"))
                    object.cart = $root.lebai.posture.CartesianPose.toObject(message.cart, options);
                if (message.cartFrameIndex != null && message.hasOwnProperty("cartFrameIndex"))
                    object.cartFrameIndex = $root.lebai.db.LoadRequest.toObject(message.cartFrameIndex, options);
                if (message.cartFrame != null && message.hasOwnProperty("cartFrame"))
                    object.cartFrame = $root.lebai.posture.CartesianFrame.toObject(message.cartFrame, options);
                if (message.joint != null && message.hasOwnProperty("joint"))
                    object.joint = $root.lebai.posture.JointPose.toObject(message.joint, options);
                return object;
            };

            /**
             * Converts this Pose to JSON.
             * @function toJSON
             * @memberof lebai.posture.Pose
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Pose.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Pose
             * @function getTypeUrl
             * @memberof lebai.posture.Pose
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Pose.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.posture.Pose";
            };

            /**
             * Kind enum.
             * @name lebai.posture.Pose.Kind
             * @enum {number}
             * @property {number} UNKNOWN=0 UNKNOWN value
             * @property {number} JOINT=1 JOINT value
             * @property {number} CARTESIAN=2 CARTESIAN value
             */
            Pose.Kind = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN"] = 0;
                values[valuesById[1] = "JOINT"] = 1;
                values[valuesById[2] = "CARTESIAN"] = 2;
                return values;
            })();

            return Pose;
        })();

        posture.SavePoseRequest = (function() {

            /**
             * Properties of a SavePoseRequest.
             * @memberof lebai.posture
             * @interface ISavePoseRequest
             * @property {string|null} [name] SavePoseRequest name
             * @property {lebai.posture.IPose|null} [data] SavePoseRequest data
             * @property {string|null} [dir] SavePoseRequest dir
             */

            /**
             * Constructs a new SavePoseRequest.
             * @memberof lebai.posture
             * @classdesc Represents a SavePoseRequest.
             * @implements ISavePoseRequest
             * @constructor
             * @param {lebai.posture.ISavePoseRequest=} [properties] Properties to set
             */
            function SavePoseRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SavePoseRequest name.
             * @member {string} name
             * @memberof lebai.posture.SavePoseRequest
             * @instance
             */
            SavePoseRequest.prototype.name = "";

            /**
             * SavePoseRequest data.
             * @member {lebai.posture.IPose|null|undefined} data
             * @memberof lebai.posture.SavePoseRequest
             * @instance
             */
            SavePoseRequest.prototype.data = null;

            /**
             * SavePoseRequest dir.
             * @member {string} dir
             * @memberof lebai.posture.SavePoseRequest
             * @instance
             */
            SavePoseRequest.prototype.dir = "";

            /**
             * Creates a new SavePoseRequest instance using the specified properties.
             * @function create
             * @memberof lebai.posture.SavePoseRequest
             * @static
             * @param {lebai.posture.ISavePoseRequest=} [properties] Properties to set
             * @returns {lebai.posture.SavePoseRequest} SavePoseRequest instance
             */
            SavePoseRequest.create = function create(properties) {
                return new SavePoseRequest(properties);
            };

            /**
             * Encodes the specified SavePoseRequest message. Does not implicitly {@link lebai.posture.SavePoseRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.posture.SavePoseRequest
             * @static
             * @param {lebai.posture.ISavePoseRequest} message SavePoseRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SavePoseRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    $root.lebai.posture.Pose.encode(message.data, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.dir != null && Object.hasOwnProperty.call(message, "dir"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.dir);
                return writer;
            };

            /**
             * Encodes the specified SavePoseRequest message, length delimited. Does not implicitly {@link lebai.posture.SavePoseRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.posture.SavePoseRequest
             * @static
             * @param {lebai.posture.ISavePoseRequest} message SavePoseRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SavePoseRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SavePoseRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.posture.SavePoseRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.posture.SavePoseRequest} SavePoseRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SavePoseRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.posture.SavePoseRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.name = reader.string();
                            break;
                        }
                    case 2: {
                            message.data = $root.lebai.posture.Pose.decode(reader, reader.uint32());
                            break;
                        }
                    case 11: {
                            message.dir = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SavePoseRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.posture.SavePoseRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.posture.SavePoseRequest} SavePoseRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SavePoseRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SavePoseRequest message.
             * @function verify
             * @memberof lebai.posture.SavePoseRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SavePoseRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.data != null && message.hasOwnProperty("data")) {
                    var error = $root.lebai.posture.Pose.verify(message.data);
                    if (error)
                        return "data." + error;
                }
                if (message.dir != null && message.hasOwnProperty("dir"))
                    if (!$util.isString(message.dir))
                        return "dir: string expected";
                return null;
            };

            /**
             * Creates a SavePoseRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.posture.SavePoseRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.posture.SavePoseRequest} SavePoseRequest
             */
            SavePoseRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.posture.SavePoseRequest)
                    return object;
                var message = new $root.lebai.posture.SavePoseRequest();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.data != null) {
                    if (typeof object.data !== "object")
                        throw TypeError(".lebai.posture.SavePoseRequest.data: object expected");
                    message.data = $root.lebai.posture.Pose.fromObject(object.data);
                }
                if (object.dir != null)
                    message.dir = String(object.dir);
                return message;
            };

            /**
             * Creates a plain object from a SavePoseRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.posture.SavePoseRequest
             * @static
             * @param {lebai.posture.SavePoseRequest} message SavePoseRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SavePoseRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.data = null;
                    object.dir = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.data != null && message.hasOwnProperty("data"))
                    object.data = $root.lebai.posture.Pose.toObject(message.data, options);
                if (message.dir != null && message.hasOwnProperty("dir"))
                    object.dir = message.dir;
                return object;
            };

            /**
             * Converts this SavePoseRequest to JSON.
             * @function toJSON
             * @memberof lebai.posture.SavePoseRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SavePoseRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SavePoseRequest
             * @function getTypeUrl
             * @memberof lebai.posture.SavePoseRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SavePoseRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.posture.SavePoseRequest";
            };

            return SavePoseRequest;
        })();

        posture.SaveFrameRequest = (function() {

            /**
             * Properties of a SaveFrameRequest.
             * @memberof lebai.posture
             * @interface ISaveFrameRequest
             * @property {string|null} [name] SaveFrameRequest name
             * @property {lebai.posture.ICartesianFrame|null} [data] SaveFrameRequest data
             * @property {string|null} [dir] SaveFrameRequest dir
             */

            /**
             * Constructs a new SaveFrameRequest.
             * @memberof lebai.posture
             * @classdesc Represents a SaveFrameRequest.
             * @implements ISaveFrameRequest
             * @constructor
             * @param {lebai.posture.ISaveFrameRequest=} [properties] Properties to set
             */
            function SaveFrameRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SaveFrameRequest name.
             * @member {string} name
             * @memberof lebai.posture.SaveFrameRequest
             * @instance
             */
            SaveFrameRequest.prototype.name = "";

            /**
             * SaveFrameRequest data.
             * @member {lebai.posture.ICartesianFrame|null|undefined} data
             * @memberof lebai.posture.SaveFrameRequest
             * @instance
             */
            SaveFrameRequest.prototype.data = null;

            /**
             * SaveFrameRequest dir.
             * @member {string} dir
             * @memberof lebai.posture.SaveFrameRequest
             * @instance
             */
            SaveFrameRequest.prototype.dir = "";

            /**
             * Creates a new SaveFrameRequest instance using the specified properties.
             * @function create
             * @memberof lebai.posture.SaveFrameRequest
             * @static
             * @param {lebai.posture.ISaveFrameRequest=} [properties] Properties to set
             * @returns {lebai.posture.SaveFrameRequest} SaveFrameRequest instance
             */
            SaveFrameRequest.create = function create(properties) {
                return new SaveFrameRequest(properties);
            };

            /**
             * Encodes the specified SaveFrameRequest message. Does not implicitly {@link lebai.posture.SaveFrameRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.posture.SaveFrameRequest
             * @static
             * @param {lebai.posture.ISaveFrameRequest} message SaveFrameRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SaveFrameRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    $root.lebai.posture.CartesianFrame.encode(message.data, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.dir != null && Object.hasOwnProperty.call(message, "dir"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.dir);
                return writer;
            };

            /**
             * Encodes the specified SaveFrameRequest message, length delimited. Does not implicitly {@link lebai.posture.SaveFrameRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.posture.SaveFrameRequest
             * @static
             * @param {lebai.posture.ISaveFrameRequest} message SaveFrameRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SaveFrameRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SaveFrameRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.posture.SaveFrameRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.posture.SaveFrameRequest} SaveFrameRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SaveFrameRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.posture.SaveFrameRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.name = reader.string();
                            break;
                        }
                    case 2: {
                            message.data = $root.lebai.posture.CartesianFrame.decode(reader, reader.uint32());
                            break;
                        }
                    case 11: {
                            message.dir = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SaveFrameRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.posture.SaveFrameRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.posture.SaveFrameRequest} SaveFrameRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SaveFrameRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SaveFrameRequest message.
             * @function verify
             * @memberof lebai.posture.SaveFrameRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SaveFrameRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.data != null && message.hasOwnProperty("data")) {
                    var error = $root.lebai.posture.CartesianFrame.verify(message.data);
                    if (error)
                        return "data." + error;
                }
                if (message.dir != null && message.hasOwnProperty("dir"))
                    if (!$util.isString(message.dir))
                        return "dir: string expected";
                return null;
            };

            /**
             * Creates a SaveFrameRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.posture.SaveFrameRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.posture.SaveFrameRequest} SaveFrameRequest
             */
            SaveFrameRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.posture.SaveFrameRequest)
                    return object;
                var message = new $root.lebai.posture.SaveFrameRequest();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.data != null) {
                    if (typeof object.data !== "object")
                        throw TypeError(".lebai.posture.SaveFrameRequest.data: object expected");
                    message.data = $root.lebai.posture.CartesianFrame.fromObject(object.data);
                }
                if (object.dir != null)
                    message.dir = String(object.dir);
                return message;
            };

            /**
             * Creates a plain object from a SaveFrameRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.posture.SaveFrameRequest
             * @static
             * @param {lebai.posture.SaveFrameRequest} message SaveFrameRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SaveFrameRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.data = null;
                    object.dir = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.data != null && message.hasOwnProperty("data"))
                    object.data = $root.lebai.posture.CartesianFrame.toObject(message.data, options);
                if (message.dir != null && message.hasOwnProperty("dir"))
                    object.dir = message.dir;
                return object;
            };

            /**
             * Converts this SaveFrameRequest to JSON.
             * @function toJSON
             * @memberof lebai.posture.SaveFrameRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SaveFrameRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SaveFrameRequest
             * @function getTypeUrl
             * @memberof lebai.posture.SaveFrameRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SaveFrameRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.posture.SaveFrameRequest";
            };

            return SaveFrameRequest;
        })();

        posture.PoseRequest = (function() {

            /**
             * Properties of a PoseRequest.
             * @memberof lebai.posture
             * @interface IPoseRequest
             * @property {lebai.posture.IPose|null} [pose] PoseRequest pose
             */

            /**
             * Constructs a new PoseRequest.
             * @memberof lebai.posture
             * @classdesc Represents a PoseRequest.
             * @implements IPoseRequest
             * @constructor
             * @param {lebai.posture.IPoseRequest=} [properties] Properties to set
             */
            function PoseRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PoseRequest pose.
             * @member {lebai.posture.IPose|null|undefined} pose
             * @memberof lebai.posture.PoseRequest
             * @instance
             */
            PoseRequest.prototype.pose = null;

            /**
             * Creates a new PoseRequest instance using the specified properties.
             * @function create
             * @memberof lebai.posture.PoseRequest
             * @static
             * @param {lebai.posture.IPoseRequest=} [properties] Properties to set
             * @returns {lebai.posture.PoseRequest} PoseRequest instance
             */
            PoseRequest.create = function create(properties) {
                return new PoseRequest(properties);
            };

            /**
             * Encodes the specified PoseRequest message. Does not implicitly {@link lebai.posture.PoseRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.posture.PoseRequest
             * @static
             * @param {lebai.posture.IPoseRequest} message PoseRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PoseRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.pose != null && Object.hasOwnProperty.call(message, "pose"))
                    $root.lebai.posture.Pose.encode(message.pose, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified PoseRequest message, length delimited. Does not implicitly {@link lebai.posture.PoseRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.posture.PoseRequest
             * @static
             * @param {lebai.posture.IPoseRequest} message PoseRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PoseRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PoseRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.posture.PoseRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.posture.PoseRequest} PoseRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PoseRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.posture.PoseRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.pose = $root.lebai.posture.Pose.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PoseRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.posture.PoseRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.posture.PoseRequest} PoseRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PoseRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PoseRequest message.
             * @function verify
             * @memberof lebai.posture.PoseRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PoseRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.pose != null && message.hasOwnProperty("pose")) {
                    var error = $root.lebai.posture.Pose.verify(message.pose);
                    if (error)
                        return "pose." + error;
                }
                return null;
            };

            /**
             * Creates a PoseRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.posture.PoseRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.posture.PoseRequest} PoseRequest
             */
            PoseRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.posture.PoseRequest)
                    return object;
                var message = new $root.lebai.posture.PoseRequest();
                if (object.pose != null) {
                    if (typeof object.pose !== "object")
                        throw TypeError(".lebai.posture.PoseRequest.pose: object expected");
                    message.pose = $root.lebai.posture.Pose.fromObject(object.pose);
                }
                return message;
            };

            /**
             * Creates a plain object from a PoseRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.posture.PoseRequest
             * @static
             * @param {lebai.posture.PoseRequest} message PoseRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PoseRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.pose = null;
                if (message.pose != null && message.hasOwnProperty("pose"))
                    object.pose = $root.lebai.posture.Pose.toObject(message.pose, options);
                return object;
            };

            /**
             * Converts this PoseRequest to JSON.
             * @function toJSON
             * @memberof lebai.posture.PoseRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PoseRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for PoseRequest
             * @function getTypeUrl
             * @memberof lebai.posture.PoseRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            PoseRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.posture.PoseRequest";
            };

            return PoseRequest;
        })();

        posture.GetInverseKinRequest = (function() {

            /**
             * Properties of a GetInverseKinRequest.
             * @memberof lebai.posture
             * @interface IGetInverseKinRequest
             * @property {lebai.posture.IPose|null} [pose] GetInverseKinRequest pose
             * @property {lebai.posture.IJointPose|null} [refer] GetInverseKinRequest refer
             */

            /**
             * Constructs a new GetInverseKinRequest.
             * @memberof lebai.posture
             * @classdesc Represents a GetInverseKinRequest.
             * @implements IGetInverseKinRequest
             * @constructor
             * @param {lebai.posture.IGetInverseKinRequest=} [properties] Properties to set
             */
            function GetInverseKinRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetInverseKinRequest pose.
             * @member {lebai.posture.IPose|null|undefined} pose
             * @memberof lebai.posture.GetInverseKinRequest
             * @instance
             */
            GetInverseKinRequest.prototype.pose = null;

            /**
             * GetInverseKinRequest refer.
             * @member {lebai.posture.IJointPose|null|undefined} refer
             * @memberof lebai.posture.GetInverseKinRequest
             * @instance
             */
            GetInverseKinRequest.prototype.refer = null;

            /**
             * Creates a new GetInverseKinRequest instance using the specified properties.
             * @function create
             * @memberof lebai.posture.GetInverseKinRequest
             * @static
             * @param {lebai.posture.IGetInverseKinRequest=} [properties] Properties to set
             * @returns {lebai.posture.GetInverseKinRequest} GetInverseKinRequest instance
             */
            GetInverseKinRequest.create = function create(properties) {
                return new GetInverseKinRequest(properties);
            };

            /**
             * Encodes the specified GetInverseKinRequest message. Does not implicitly {@link lebai.posture.GetInverseKinRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.posture.GetInverseKinRequest
             * @static
             * @param {lebai.posture.IGetInverseKinRequest} message GetInverseKinRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetInverseKinRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.pose != null && Object.hasOwnProperty.call(message, "pose"))
                    $root.lebai.posture.Pose.encode(message.pose, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.refer != null && Object.hasOwnProperty.call(message, "refer"))
                    $root.lebai.posture.JointPose.encode(message.refer, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetInverseKinRequest message, length delimited. Does not implicitly {@link lebai.posture.GetInverseKinRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.posture.GetInverseKinRequest
             * @static
             * @param {lebai.posture.IGetInverseKinRequest} message GetInverseKinRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetInverseKinRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetInverseKinRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.posture.GetInverseKinRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.posture.GetInverseKinRequest} GetInverseKinRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetInverseKinRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.posture.GetInverseKinRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.pose = $root.lebai.posture.Pose.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.refer = $root.lebai.posture.JointPose.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetInverseKinRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.posture.GetInverseKinRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.posture.GetInverseKinRequest} GetInverseKinRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetInverseKinRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetInverseKinRequest message.
             * @function verify
             * @memberof lebai.posture.GetInverseKinRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetInverseKinRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.pose != null && message.hasOwnProperty("pose")) {
                    var error = $root.lebai.posture.Pose.verify(message.pose);
                    if (error)
                        return "pose." + error;
                }
                if (message.refer != null && message.hasOwnProperty("refer")) {
                    var error = $root.lebai.posture.JointPose.verify(message.refer);
                    if (error)
                        return "refer." + error;
                }
                return null;
            };

            /**
             * Creates a GetInverseKinRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.posture.GetInverseKinRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.posture.GetInverseKinRequest} GetInverseKinRequest
             */
            GetInverseKinRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.posture.GetInverseKinRequest)
                    return object;
                var message = new $root.lebai.posture.GetInverseKinRequest();
                if (object.pose != null) {
                    if (typeof object.pose !== "object")
                        throw TypeError(".lebai.posture.GetInverseKinRequest.pose: object expected");
                    message.pose = $root.lebai.posture.Pose.fromObject(object.pose);
                }
                if (object.refer != null) {
                    if (typeof object.refer !== "object")
                        throw TypeError(".lebai.posture.GetInverseKinRequest.refer: object expected");
                    message.refer = $root.lebai.posture.JointPose.fromObject(object.refer);
                }
                return message;
            };

            /**
             * Creates a plain object from a GetInverseKinRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.posture.GetInverseKinRequest
             * @static
             * @param {lebai.posture.GetInverseKinRequest} message GetInverseKinRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetInverseKinRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.pose = null;
                    object.refer = null;
                }
                if (message.pose != null && message.hasOwnProperty("pose"))
                    object.pose = $root.lebai.posture.Pose.toObject(message.pose, options);
                if (message.refer != null && message.hasOwnProperty("refer"))
                    object.refer = $root.lebai.posture.JointPose.toObject(message.refer, options);
                return object;
            };

            /**
             * Converts this GetInverseKinRequest to JSON.
             * @function toJSON
             * @memberof lebai.posture.GetInverseKinRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetInverseKinRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetInverseKinRequest
             * @function getTypeUrl
             * @memberof lebai.posture.GetInverseKinRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetInverseKinRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.posture.GetInverseKinRequest";
            };

            return GetInverseKinRequest;
        })();

        posture.GetPoseTransRequest = (function() {

            /**
             * Properties of a GetPoseTransRequest.
             * @memberof lebai.posture
             * @interface IGetPoseTransRequest
             * @property {lebai.posture.IPose|null} [from] GetPoseTransRequest from
             * @property {lebai.posture.IPose|null} [fromTo] GetPoseTransRequest fromTo
             */

            /**
             * Constructs a new GetPoseTransRequest.
             * @memberof lebai.posture
             * @classdesc Represents a GetPoseTransRequest.
             * @implements IGetPoseTransRequest
             * @constructor
             * @param {lebai.posture.IGetPoseTransRequest=} [properties] Properties to set
             */
            function GetPoseTransRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetPoseTransRequest from.
             * @member {lebai.posture.IPose|null|undefined} from
             * @memberof lebai.posture.GetPoseTransRequest
             * @instance
             */
            GetPoseTransRequest.prototype.from = null;

            /**
             * GetPoseTransRequest fromTo.
             * @member {lebai.posture.IPose|null|undefined} fromTo
             * @memberof lebai.posture.GetPoseTransRequest
             * @instance
             */
            GetPoseTransRequest.prototype.fromTo = null;

            /**
             * Creates a new GetPoseTransRequest instance using the specified properties.
             * @function create
             * @memberof lebai.posture.GetPoseTransRequest
             * @static
             * @param {lebai.posture.IGetPoseTransRequest=} [properties] Properties to set
             * @returns {lebai.posture.GetPoseTransRequest} GetPoseTransRequest instance
             */
            GetPoseTransRequest.create = function create(properties) {
                return new GetPoseTransRequest(properties);
            };

            /**
             * Encodes the specified GetPoseTransRequest message. Does not implicitly {@link lebai.posture.GetPoseTransRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.posture.GetPoseTransRequest
             * @static
             * @param {lebai.posture.IGetPoseTransRequest} message GetPoseTransRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetPoseTransRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.from != null && Object.hasOwnProperty.call(message, "from"))
                    $root.lebai.posture.Pose.encode(message.from, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.fromTo != null && Object.hasOwnProperty.call(message, "fromTo"))
                    $root.lebai.posture.Pose.encode(message.fromTo, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetPoseTransRequest message, length delimited. Does not implicitly {@link lebai.posture.GetPoseTransRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.posture.GetPoseTransRequest
             * @static
             * @param {lebai.posture.IGetPoseTransRequest} message GetPoseTransRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetPoseTransRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetPoseTransRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.posture.GetPoseTransRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.posture.GetPoseTransRequest} GetPoseTransRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetPoseTransRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.posture.GetPoseTransRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.from = $root.lebai.posture.Pose.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.fromTo = $root.lebai.posture.Pose.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetPoseTransRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.posture.GetPoseTransRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.posture.GetPoseTransRequest} GetPoseTransRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetPoseTransRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetPoseTransRequest message.
             * @function verify
             * @memberof lebai.posture.GetPoseTransRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetPoseTransRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.from != null && message.hasOwnProperty("from")) {
                    var error = $root.lebai.posture.Pose.verify(message.from);
                    if (error)
                        return "from." + error;
                }
                if (message.fromTo != null && message.hasOwnProperty("fromTo")) {
                    var error = $root.lebai.posture.Pose.verify(message.fromTo);
                    if (error)
                        return "fromTo." + error;
                }
                return null;
            };

            /**
             * Creates a GetPoseTransRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.posture.GetPoseTransRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.posture.GetPoseTransRequest} GetPoseTransRequest
             */
            GetPoseTransRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.posture.GetPoseTransRequest)
                    return object;
                var message = new $root.lebai.posture.GetPoseTransRequest();
                if (object.from != null) {
                    if (typeof object.from !== "object")
                        throw TypeError(".lebai.posture.GetPoseTransRequest.from: object expected");
                    message.from = $root.lebai.posture.Pose.fromObject(object.from);
                }
                if (object.fromTo != null) {
                    if (typeof object.fromTo !== "object")
                        throw TypeError(".lebai.posture.GetPoseTransRequest.fromTo: object expected");
                    message.fromTo = $root.lebai.posture.Pose.fromObject(object.fromTo);
                }
                return message;
            };

            /**
             * Creates a plain object from a GetPoseTransRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.posture.GetPoseTransRequest
             * @static
             * @param {lebai.posture.GetPoseTransRequest} message GetPoseTransRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetPoseTransRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.from = null;
                    object.fromTo = null;
                }
                if (message.from != null && message.hasOwnProperty("from"))
                    object.from = $root.lebai.posture.Pose.toObject(message.from, options);
                if (message.fromTo != null && message.hasOwnProperty("fromTo"))
                    object.fromTo = $root.lebai.posture.Pose.toObject(message.fromTo, options);
                return object;
            };

            /**
             * Converts this GetPoseTransRequest to JSON.
             * @function toJSON
             * @memberof lebai.posture.GetPoseTransRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetPoseTransRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetPoseTransRequest
             * @function getTypeUrl
             * @memberof lebai.posture.GetPoseTransRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetPoseTransRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.posture.GetPoseTransRequest";
            };

            return GetPoseTransRequest;
        })();

        posture.GetPoseAddRequest = (function() {

            /**
             * Properties of a GetPoseAddRequest.
             * @memberof lebai.posture
             * @interface IGetPoseAddRequest
             * @property {lebai.posture.IPose|null} [pose] GetPoseAddRequest pose
             * @property {lebai.posture.IPose|null} [delta] GetPoseAddRequest delta
             */

            /**
             * Constructs a new GetPoseAddRequest.
             * @memberof lebai.posture
             * @classdesc Represents a GetPoseAddRequest.
             * @implements IGetPoseAddRequest
             * @constructor
             * @param {lebai.posture.IGetPoseAddRequest=} [properties] Properties to set
             */
            function GetPoseAddRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetPoseAddRequest pose.
             * @member {lebai.posture.IPose|null|undefined} pose
             * @memberof lebai.posture.GetPoseAddRequest
             * @instance
             */
            GetPoseAddRequest.prototype.pose = null;

            /**
             * GetPoseAddRequest delta.
             * @member {lebai.posture.IPose|null|undefined} delta
             * @memberof lebai.posture.GetPoseAddRequest
             * @instance
             */
            GetPoseAddRequest.prototype.delta = null;

            /**
             * Creates a new GetPoseAddRequest instance using the specified properties.
             * @function create
             * @memberof lebai.posture.GetPoseAddRequest
             * @static
             * @param {lebai.posture.IGetPoseAddRequest=} [properties] Properties to set
             * @returns {lebai.posture.GetPoseAddRequest} GetPoseAddRequest instance
             */
            GetPoseAddRequest.create = function create(properties) {
                return new GetPoseAddRequest(properties);
            };

            /**
             * Encodes the specified GetPoseAddRequest message. Does not implicitly {@link lebai.posture.GetPoseAddRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.posture.GetPoseAddRequest
             * @static
             * @param {lebai.posture.IGetPoseAddRequest} message GetPoseAddRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetPoseAddRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.pose != null && Object.hasOwnProperty.call(message, "pose"))
                    $root.lebai.posture.Pose.encode(message.pose, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.delta != null && Object.hasOwnProperty.call(message, "delta"))
                    $root.lebai.posture.Pose.encode(message.delta, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetPoseAddRequest message, length delimited. Does not implicitly {@link lebai.posture.GetPoseAddRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.posture.GetPoseAddRequest
             * @static
             * @param {lebai.posture.IGetPoseAddRequest} message GetPoseAddRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetPoseAddRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetPoseAddRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.posture.GetPoseAddRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.posture.GetPoseAddRequest} GetPoseAddRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetPoseAddRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.posture.GetPoseAddRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.pose = $root.lebai.posture.Pose.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.delta = $root.lebai.posture.Pose.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetPoseAddRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.posture.GetPoseAddRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.posture.GetPoseAddRequest} GetPoseAddRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetPoseAddRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetPoseAddRequest message.
             * @function verify
             * @memberof lebai.posture.GetPoseAddRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetPoseAddRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.pose != null && message.hasOwnProperty("pose")) {
                    var error = $root.lebai.posture.Pose.verify(message.pose);
                    if (error)
                        return "pose." + error;
                }
                if (message.delta != null && message.hasOwnProperty("delta")) {
                    var error = $root.lebai.posture.Pose.verify(message.delta);
                    if (error)
                        return "delta." + error;
                }
                return null;
            };

            /**
             * Creates a GetPoseAddRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.posture.GetPoseAddRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.posture.GetPoseAddRequest} GetPoseAddRequest
             */
            GetPoseAddRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.posture.GetPoseAddRequest)
                    return object;
                var message = new $root.lebai.posture.GetPoseAddRequest();
                if (object.pose != null) {
                    if (typeof object.pose !== "object")
                        throw TypeError(".lebai.posture.GetPoseAddRequest.pose: object expected");
                    message.pose = $root.lebai.posture.Pose.fromObject(object.pose);
                }
                if (object.delta != null) {
                    if (typeof object.delta !== "object")
                        throw TypeError(".lebai.posture.GetPoseAddRequest.delta: object expected");
                    message.delta = $root.lebai.posture.Pose.fromObject(object.delta);
                }
                return message;
            };

            /**
             * Creates a plain object from a GetPoseAddRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.posture.GetPoseAddRequest
             * @static
             * @param {lebai.posture.GetPoseAddRequest} message GetPoseAddRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetPoseAddRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.pose = null;
                    object.delta = null;
                }
                if (message.pose != null && message.hasOwnProperty("pose"))
                    object.pose = $root.lebai.posture.Pose.toObject(message.pose, options);
                if (message.delta != null && message.hasOwnProperty("delta"))
                    object.delta = $root.lebai.posture.Pose.toObject(message.delta, options);
                return object;
            };

            /**
             * Converts this GetPoseAddRequest to JSON.
             * @function toJSON
             * @memberof lebai.posture.GetPoseAddRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetPoseAddRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetPoseAddRequest
             * @function getTypeUrl
             * @memberof lebai.posture.GetPoseAddRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetPoseAddRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.posture.GetPoseAddRequest";
            };

            return GetPoseAddRequest;
        })();

        posture.PostureService = (function() {

            /**
             * Constructs a new PostureService service.
             * @memberof lebai.posture
             * @classdesc Represents a PostureService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function PostureService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (PostureService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = PostureService;

            /**
             * Creates new PostureService service using the specified rpc implementation.
             * @function create
             * @memberof lebai.posture.PostureService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {PostureService} RPC service. Useful where requests and/or responses are streamed.
             */
            PostureService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link lebai.posture.PostureService#savePose}.
             * @memberof lebai.posture.PostureService
             * @typedef SavePoseCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls SavePose.
             * @function savePose
             * @memberof lebai.posture.PostureService
             * @instance
             * @param {lebai.posture.ISavePoseRequest} request SavePoseRequest message or plain object
             * @param {lebai.posture.PostureService.SavePoseCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(PostureService.prototype.savePose = function savePose(request, callback) {
                return this.rpcCall(savePose, $root.lebai.posture.SavePoseRequest, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "SavePose" });

            /**
             * Calls SavePose.
             * @function savePose
             * @memberof lebai.posture.PostureService
             * @instance
             * @param {lebai.posture.ISavePoseRequest} request SavePoseRequest message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.posture.PostureService#loadPose}.
             * @memberof lebai.posture.PostureService
             * @typedef LoadPoseCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.posture.Pose} [response] Pose
             */

            /**
             * Calls LoadPose.
             * @function loadPose
             * @memberof lebai.posture.PostureService
             * @instance
             * @param {lebai.db.ILoadRequest} request LoadRequest message or plain object
             * @param {lebai.posture.PostureService.LoadPoseCallback} callback Node-style callback called with the error, if any, and Pose
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(PostureService.prototype.loadPose = function loadPose(request, callback) {
                return this.rpcCall(loadPose, $root.lebai.db.LoadRequest, $root.lebai.posture.Pose, request, callback);
            }, "name", { value: "LoadPose" });

            /**
             * Calls LoadPose.
             * @function loadPose
             * @memberof lebai.posture.PostureService
             * @instance
             * @param {lebai.db.ILoadRequest} request LoadRequest message or plain object
             * @returns {Promise<lebai.posture.Pose>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.posture.PostureService#loadPoseList}.
             * @memberof lebai.posture.PostureService
             * @typedef LoadPoseListCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.db.LoadListResponse} [response] LoadListResponse
             */

            /**
             * Calls LoadPoseList.
             * @function loadPoseList
             * @memberof lebai.posture.PostureService
             * @instance
             * @param {lebai.db.ILoadListRequest} request LoadListRequest message or plain object
             * @param {lebai.posture.PostureService.LoadPoseListCallback} callback Node-style callback called with the error, if any, and LoadListResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(PostureService.prototype.loadPoseList = function loadPoseList(request, callback) {
                return this.rpcCall(loadPoseList, $root.lebai.db.LoadListRequest, $root.lebai.db.LoadListResponse, request, callback);
            }, "name", { value: "LoadPoseList" });

            /**
             * Calls LoadPoseList.
             * @function loadPoseList
             * @memberof lebai.posture.PostureService
             * @instance
             * @param {lebai.db.ILoadListRequest} request LoadListRequest message or plain object
             * @returns {Promise<lebai.db.LoadListResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.posture.PostureService#saveFrame}.
             * @memberof lebai.posture.PostureService
             * @typedef SaveFrameCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls SaveFrame.
             * @function saveFrame
             * @memberof lebai.posture.PostureService
             * @instance
             * @param {lebai.posture.ISaveFrameRequest} request SaveFrameRequest message or plain object
             * @param {lebai.posture.PostureService.SaveFrameCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(PostureService.prototype.saveFrame = function saveFrame(request, callback) {
                return this.rpcCall(saveFrame, $root.lebai.posture.SaveFrameRequest, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "SaveFrame" });

            /**
             * Calls SaveFrame.
             * @function saveFrame
             * @memberof lebai.posture.PostureService
             * @instance
             * @param {lebai.posture.ISaveFrameRequest} request SaveFrameRequest message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.posture.PostureService#loadFrame}.
             * @memberof lebai.posture.PostureService
             * @typedef LoadFrameCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.posture.CartesianFrame} [response] CartesianFrame
             */

            /**
             * Calls LoadFrame.
             * @function loadFrame
             * @memberof lebai.posture.PostureService
             * @instance
             * @param {lebai.db.ILoadRequest} request LoadRequest message or plain object
             * @param {lebai.posture.PostureService.LoadFrameCallback} callback Node-style callback called with the error, if any, and CartesianFrame
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(PostureService.prototype.loadFrame = function loadFrame(request, callback) {
                return this.rpcCall(loadFrame, $root.lebai.db.LoadRequest, $root.lebai.posture.CartesianFrame, request, callback);
            }, "name", { value: "LoadFrame" });

            /**
             * Calls LoadFrame.
             * @function loadFrame
             * @memberof lebai.posture.PostureService
             * @instance
             * @param {lebai.db.ILoadRequest} request LoadRequest message or plain object
             * @returns {Promise<lebai.posture.CartesianFrame>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.posture.PostureService#loadFrameList}.
             * @memberof lebai.posture.PostureService
             * @typedef LoadFrameListCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.db.LoadListResponse} [response] LoadListResponse
             */

            /**
             * Calls LoadFrameList.
             * @function loadFrameList
             * @memberof lebai.posture.PostureService
             * @instance
             * @param {lebai.db.ILoadListRequest} request LoadListRequest message or plain object
             * @param {lebai.posture.PostureService.LoadFrameListCallback} callback Node-style callback called with the error, if any, and LoadListResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(PostureService.prototype.loadFrameList = function loadFrameList(request, callback) {
                return this.rpcCall(loadFrameList, $root.lebai.db.LoadListRequest, $root.lebai.db.LoadListResponse, request, callback);
            }, "name", { value: "LoadFrameList" });

            /**
             * Calls LoadFrameList.
             * @function loadFrameList
             * @memberof lebai.posture.PostureService
             * @instance
             * @param {lebai.db.ILoadListRequest} request LoadListRequest message or plain object
             * @returns {Promise<lebai.db.LoadListResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.posture.PostureService#getForwardKin}.
             * @memberof lebai.posture.PostureService
             * @typedef GetForwardKinCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.posture.CartesianPose} [response] CartesianPose
             */

            /**
             * Calls GetForwardKin.
             * @function getForwardKin
             * @memberof lebai.posture.PostureService
             * @instance
             * @param {lebai.posture.IPoseRequest} request PoseRequest message or plain object
             * @param {lebai.posture.PostureService.GetForwardKinCallback} callback Node-style callback called with the error, if any, and CartesianPose
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(PostureService.prototype.getForwardKin = function getForwardKin(request, callback) {
                return this.rpcCall(getForwardKin, $root.lebai.posture.PoseRequest, $root.lebai.posture.CartesianPose, request, callback);
            }, "name", { value: "GetForwardKin" });

            /**
             * Calls GetForwardKin.
             * @function getForwardKin
             * @memberof lebai.posture.PostureService
             * @instance
             * @param {lebai.posture.IPoseRequest} request PoseRequest message or plain object
             * @returns {Promise<lebai.posture.CartesianPose>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.posture.PostureService#getInverseKin}.
             * @memberof lebai.posture.PostureService
             * @typedef GetInverseKinCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.posture.JointPose} [response] JointPose
             */

            /**
             * Calls GetInverseKin.
             * @function getInverseKin
             * @memberof lebai.posture.PostureService
             * @instance
             * @param {lebai.posture.IGetInverseKinRequest} request GetInverseKinRequest message or plain object
             * @param {lebai.posture.PostureService.GetInverseKinCallback} callback Node-style callback called with the error, if any, and JointPose
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(PostureService.prototype.getInverseKin = function getInverseKin(request, callback) {
                return this.rpcCall(getInverseKin, $root.lebai.posture.GetInverseKinRequest, $root.lebai.posture.JointPose, request, callback);
            }, "name", { value: "GetInverseKin" });

            /**
             * Calls GetInverseKin.
             * @function getInverseKin
             * @memberof lebai.posture.PostureService
             * @instance
             * @param {lebai.posture.IGetInverseKinRequest} request GetInverseKinRequest message or plain object
             * @returns {Promise<lebai.posture.JointPose>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.posture.PostureService#getPoseTrans}.
             * @memberof lebai.posture.PostureService
             * @typedef GetPoseTransCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.posture.CartesianPose} [response] CartesianPose
             */

            /**
             * Calls GetPoseTrans.
             * @function getPoseTrans
             * @memberof lebai.posture.PostureService
             * @instance
             * @param {lebai.posture.IGetPoseTransRequest} request GetPoseTransRequest message or plain object
             * @param {lebai.posture.PostureService.GetPoseTransCallback} callback Node-style callback called with the error, if any, and CartesianPose
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(PostureService.prototype.getPoseTrans = function getPoseTrans(request, callback) {
                return this.rpcCall(getPoseTrans, $root.lebai.posture.GetPoseTransRequest, $root.lebai.posture.CartesianPose, request, callback);
            }, "name", { value: "GetPoseTrans" });

            /**
             * Calls GetPoseTrans.
             * @function getPoseTrans
             * @memberof lebai.posture.PostureService
             * @instance
             * @param {lebai.posture.IGetPoseTransRequest} request GetPoseTransRequest message or plain object
             * @returns {Promise<lebai.posture.CartesianPose>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.posture.PostureService#getPoseAdd}.
             * @memberof lebai.posture.PostureService
             * @typedef GetPoseAddCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.posture.CartesianPose} [response] CartesianPose
             */

            /**
             * Calls GetPoseAdd.
             * @function getPoseAdd
             * @memberof lebai.posture.PostureService
             * @instance
             * @param {lebai.posture.IGetPoseAddRequest} request GetPoseAddRequest message or plain object
             * @param {lebai.posture.PostureService.GetPoseAddCallback} callback Node-style callback called with the error, if any, and CartesianPose
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(PostureService.prototype.getPoseAdd = function getPoseAdd(request, callback) {
                return this.rpcCall(getPoseAdd, $root.lebai.posture.GetPoseAddRequest, $root.lebai.posture.CartesianPose, request, callback);
            }, "name", { value: "GetPoseAdd" });

            /**
             * Calls GetPoseAdd.
             * @function getPoseAdd
             * @memberof lebai.posture.PostureService
             * @instance
             * @param {lebai.posture.IGetPoseAddRequest} request GetPoseAddRequest message or plain object
             * @returns {Promise<lebai.posture.CartesianPose>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.posture.PostureService#getPoseInverse}.
             * @memberof lebai.posture.PostureService
             * @typedef GetPoseInverseCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.posture.CartesianPose} [response] CartesianPose
             */

            /**
             * Calls GetPoseInverse.
             * @function getPoseInverse
             * @memberof lebai.posture.PostureService
             * @instance
             * @param {lebai.posture.IPoseRequest} request PoseRequest message or plain object
             * @param {lebai.posture.PostureService.GetPoseInverseCallback} callback Node-style callback called with the error, if any, and CartesianPose
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(PostureService.prototype.getPoseInverse = function getPoseInverse(request, callback) {
                return this.rpcCall(getPoseInverse, $root.lebai.posture.PoseRequest, $root.lebai.posture.CartesianPose, request, callback);
            }, "name", { value: "GetPoseInverse" });

            /**
             * Calls GetPoseInverse.
             * @function getPoseInverse
             * @memberof lebai.posture.PostureService
             * @instance
             * @param {lebai.posture.IPoseRequest} request PoseRequest message or plain object
             * @returns {Promise<lebai.posture.CartesianPose>} Promise
             * @variation 2
             */

            return PostureService;
        })();

        return posture;
    })();

    lebai.file = (function() {

        /**
         * Namespace file.
         * @memberof lebai
         * @namespace
         */
        var file = {};

        file.File = (function() {

            /**
             * Properties of a File.
             * @memberof lebai.file
             * @interface IFile
             * @property {boolean|null} [isDir] File isDir
             * @property {Uint8Array|null} [data] File data
             */

            /**
             * Constructs a new File.
             * @memberof lebai.file
             * @classdesc Represents a File.
             * @implements IFile
             * @constructor
             * @param {lebai.file.IFile=} [properties] Properties to set
             */
            function File(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * File isDir.
             * @member {boolean} isDir
             * @memberof lebai.file.File
             * @instance
             */
            File.prototype.isDir = false;

            /**
             * File data.
             * @member {Uint8Array} data
             * @memberof lebai.file.File
             * @instance
             */
            File.prototype.data = $util.newBuffer([]);

            /**
             * Creates a new File instance using the specified properties.
             * @function create
             * @memberof lebai.file.File
             * @static
             * @param {lebai.file.IFile=} [properties] Properties to set
             * @returns {lebai.file.File} File instance
             */
            File.create = function create(properties) {
                return new File(properties);
            };

            /**
             * Encodes the specified File message. Does not implicitly {@link lebai.file.File.verify|verify} messages.
             * @function encode
             * @memberof lebai.file.File
             * @static
             * @param {lebai.file.IFile} message File message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            File.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.isDir != null && Object.hasOwnProperty.call(message, "isDir"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isDir);
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    writer.uint32(/* id 10, wireType 2 =*/82).bytes(message.data);
                return writer;
            };

            /**
             * Encodes the specified File message, length delimited. Does not implicitly {@link lebai.file.File.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.file.File
             * @static
             * @param {lebai.file.IFile} message File message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            File.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a File message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.file.File
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.file.File} File
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            File.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.file.File();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 3: {
                            message.isDir = reader.bool();
                            break;
                        }
                    case 10: {
                            message.data = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a File message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.file.File
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.file.File} File
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            File.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a File message.
             * @function verify
             * @memberof lebai.file.File
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            File.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.isDir != null && message.hasOwnProperty("isDir"))
                    if (typeof message.isDir !== "boolean")
                        return "isDir: boolean expected";
                if (message.data != null && message.hasOwnProperty("data"))
                    if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                        return "data: buffer expected";
                return null;
            };

            /**
             * Creates a File message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.file.File
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.file.File} File
             */
            File.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.file.File)
                    return object;
                var message = new $root.lebai.file.File();
                if (object.isDir != null)
                    message.isDir = Boolean(object.isDir);
                if (object.data != null)
                    if (typeof object.data === "string")
                        $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                    else if (object.data.length >= 0)
                        message.data = object.data;
                return message;
            };

            /**
             * Creates a plain object from a File message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.file.File
             * @static
             * @param {lebai.file.File} message File
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            File.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.isDir = false;
                    if (options.bytes === String)
                        object.data = "";
                    else {
                        object.data = [];
                        if (options.bytes !== Array)
                            object.data = $util.newBuffer(object.data);
                    }
                }
                if (message.isDir != null && message.hasOwnProperty("isDir"))
                    object.isDir = message.isDir;
                if (message.data != null && message.hasOwnProperty("data"))
                    object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
                return object;
            };

            /**
             * Converts this File to JSON.
             * @function toJSON
             * @memberof lebai.file.File
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            File.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for File
             * @function getTypeUrl
             * @memberof lebai.file.File
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            File.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.file.File";
            };

            return File;
        })();

        file.FileIndex = (function() {

            /**
             * Properties of a FileIndex.
             * @memberof lebai.file
             * @interface IFileIndex
             * @property {string|null} [dir] FileIndex dir
             * @property {string|null} [name] FileIndex name
             */

            /**
             * Constructs a new FileIndex.
             * @memberof lebai.file
             * @classdesc Represents a FileIndex.
             * @implements IFileIndex
             * @constructor
             * @param {lebai.file.IFileIndex=} [properties] Properties to set
             */
            function FileIndex(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FileIndex dir.
             * @member {string} dir
             * @memberof lebai.file.FileIndex
             * @instance
             */
            FileIndex.prototype.dir = "";

            /**
             * FileIndex name.
             * @member {string} name
             * @memberof lebai.file.FileIndex
             * @instance
             */
            FileIndex.prototype.name = "";

            /**
             * Creates a new FileIndex instance using the specified properties.
             * @function create
             * @memberof lebai.file.FileIndex
             * @static
             * @param {lebai.file.IFileIndex=} [properties] Properties to set
             * @returns {lebai.file.FileIndex} FileIndex instance
             */
            FileIndex.create = function create(properties) {
                return new FileIndex(properties);
            };

            /**
             * Encodes the specified FileIndex message. Does not implicitly {@link lebai.file.FileIndex.verify|verify} messages.
             * @function encode
             * @memberof lebai.file.FileIndex
             * @static
             * @param {lebai.file.IFileIndex} message FileIndex message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileIndex.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.dir != null && Object.hasOwnProperty.call(message, "dir"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.dir);
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                return writer;
            };

            /**
             * Encodes the specified FileIndex message, length delimited. Does not implicitly {@link lebai.file.FileIndex.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.file.FileIndex
             * @static
             * @param {lebai.file.IFileIndex} message FileIndex message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileIndex.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FileIndex message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.file.FileIndex
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.file.FileIndex} FileIndex
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileIndex.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.file.FileIndex();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.dir = reader.string();
                            break;
                        }
                    case 2: {
                            message.name = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FileIndex message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.file.FileIndex
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.file.FileIndex} FileIndex
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileIndex.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FileIndex message.
             * @function verify
             * @memberof lebai.file.FileIndex
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FileIndex.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.dir != null && message.hasOwnProperty("dir"))
                    if (!$util.isString(message.dir))
                        return "dir: string expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                return null;
            };

            /**
             * Creates a FileIndex message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.file.FileIndex
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.file.FileIndex} FileIndex
             */
            FileIndex.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.file.FileIndex)
                    return object;
                var message = new $root.lebai.file.FileIndex();
                if (object.dir != null)
                    message.dir = String(object.dir);
                if (object.name != null)
                    message.name = String(object.name);
                return message;
            };

            /**
             * Creates a plain object from a FileIndex message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.file.FileIndex
             * @static
             * @param {lebai.file.FileIndex} message FileIndex
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FileIndex.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.dir = "";
                    object.name = "";
                }
                if (message.dir != null && message.hasOwnProperty("dir"))
                    object.dir = message.dir;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                return object;
            };

            /**
             * Converts this FileIndex to JSON.
             * @function toJSON
             * @memberof lebai.file.FileIndex
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FileIndex.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for FileIndex
             * @function getTypeUrl
             * @memberof lebai.file.FileIndex
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            FileIndex.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.file.FileIndex";
            };

            return FileIndex;
        })();

        file.FileName = (function() {

            /**
             * Properties of a FileName.
             * @memberof lebai.file
             * @interface IFileName
             * @property {string|null} [name] FileName name
             * @property {boolean|null} [isDir] FileName isDir
             */

            /**
             * Constructs a new FileName.
             * @memberof lebai.file
             * @classdesc Represents a FileName.
             * @implements IFileName
             * @constructor
             * @param {lebai.file.IFileName=} [properties] Properties to set
             */
            function FileName(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FileName name.
             * @member {string} name
             * @memberof lebai.file.FileName
             * @instance
             */
            FileName.prototype.name = "";

            /**
             * FileName isDir.
             * @member {boolean} isDir
             * @memberof lebai.file.FileName
             * @instance
             */
            FileName.prototype.isDir = false;

            /**
             * Creates a new FileName instance using the specified properties.
             * @function create
             * @memberof lebai.file.FileName
             * @static
             * @param {lebai.file.IFileName=} [properties] Properties to set
             * @returns {lebai.file.FileName} FileName instance
             */
            FileName.create = function create(properties) {
                return new FileName(properties);
            };

            /**
             * Encodes the specified FileName message. Does not implicitly {@link lebai.file.FileName.verify|verify} messages.
             * @function encode
             * @memberof lebai.file.FileName
             * @static
             * @param {lebai.file.IFileName} message FileName message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileName.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                if (message.isDir != null && Object.hasOwnProperty.call(message, "isDir"))
                    writer.uint32(/* id 10, wireType 0 =*/80).bool(message.isDir);
                return writer;
            };

            /**
             * Encodes the specified FileName message, length delimited. Does not implicitly {@link lebai.file.FileName.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.file.FileName
             * @static
             * @param {lebai.file.IFileName} message FileName message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileName.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FileName message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.file.FileName
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.file.FileName} FileName
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileName.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.file.FileName();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2: {
                            message.name = reader.string();
                            break;
                        }
                    case 10: {
                            message.isDir = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FileName message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.file.FileName
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.file.FileName} FileName
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileName.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FileName message.
             * @function verify
             * @memberof lebai.file.FileName
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FileName.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.isDir != null && message.hasOwnProperty("isDir"))
                    if (typeof message.isDir !== "boolean")
                        return "isDir: boolean expected";
                return null;
            };

            /**
             * Creates a FileName message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.file.FileName
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.file.FileName} FileName
             */
            FileName.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.file.FileName)
                    return object;
                var message = new $root.lebai.file.FileName();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.isDir != null)
                    message.isDir = Boolean(object.isDir);
                return message;
            };

            /**
             * Creates a plain object from a FileName message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.file.FileName
             * @static
             * @param {lebai.file.FileName} message FileName
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FileName.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.isDir = false;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.isDir != null && message.hasOwnProperty("isDir"))
                    object.isDir = message.isDir;
                return object;
            };

            /**
             * Converts this FileName to JSON.
             * @function toJSON
             * @memberof lebai.file.FileName
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FileName.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for FileName
             * @function getTypeUrl
             * @memberof lebai.file.FileName
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            FileName.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.file.FileName";
            };

            return FileName;
        })();

        file.SaveFileRequest = (function() {

            /**
             * Properties of a SaveFileRequest.
             * @memberof lebai.file
             * @interface ISaveFileRequest
             * @property {string|null} [dir] SaveFileRequest dir
             * @property {string|null} [name] SaveFileRequest name
             * @property {lebai.file.IFile|null} [file] SaveFileRequest file
             */

            /**
             * Constructs a new SaveFileRequest.
             * @memberof lebai.file
             * @classdesc Represents a SaveFileRequest.
             * @implements ISaveFileRequest
             * @constructor
             * @param {lebai.file.ISaveFileRequest=} [properties] Properties to set
             */
            function SaveFileRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SaveFileRequest dir.
             * @member {string} dir
             * @memberof lebai.file.SaveFileRequest
             * @instance
             */
            SaveFileRequest.prototype.dir = "";

            /**
             * SaveFileRequest name.
             * @member {string} name
             * @memberof lebai.file.SaveFileRequest
             * @instance
             */
            SaveFileRequest.prototype.name = "";

            /**
             * SaveFileRequest file.
             * @member {lebai.file.IFile|null|undefined} file
             * @memberof lebai.file.SaveFileRequest
             * @instance
             */
            SaveFileRequest.prototype.file = null;

            /**
             * Creates a new SaveFileRequest instance using the specified properties.
             * @function create
             * @memberof lebai.file.SaveFileRequest
             * @static
             * @param {lebai.file.ISaveFileRequest=} [properties] Properties to set
             * @returns {lebai.file.SaveFileRequest} SaveFileRequest instance
             */
            SaveFileRequest.create = function create(properties) {
                return new SaveFileRequest(properties);
            };

            /**
             * Encodes the specified SaveFileRequest message. Does not implicitly {@link lebai.file.SaveFileRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.file.SaveFileRequest
             * @static
             * @param {lebai.file.ISaveFileRequest} message SaveFileRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SaveFileRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.dir != null && Object.hasOwnProperty.call(message, "dir"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.dir);
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                if (message.file != null && Object.hasOwnProperty.call(message, "file"))
                    $root.lebai.file.File.encode(message.file, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified SaveFileRequest message, length delimited. Does not implicitly {@link lebai.file.SaveFileRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.file.SaveFileRequest
             * @static
             * @param {lebai.file.ISaveFileRequest} message SaveFileRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SaveFileRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SaveFileRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.file.SaveFileRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.file.SaveFileRequest} SaveFileRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SaveFileRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.file.SaveFileRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.dir = reader.string();
                            break;
                        }
                    case 2: {
                            message.name = reader.string();
                            break;
                        }
                    case 10: {
                            message.file = $root.lebai.file.File.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SaveFileRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.file.SaveFileRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.file.SaveFileRequest} SaveFileRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SaveFileRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SaveFileRequest message.
             * @function verify
             * @memberof lebai.file.SaveFileRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SaveFileRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.dir != null && message.hasOwnProperty("dir"))
                    if (!$util.isString(message.dir))
                        return "dir: string expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.file != null && message.hasOwnProperty("file")) {
                    var error = $root.lebai.file.File.verify(message.file);
                    if (error)
                        return "file." + error;
                }
                return null;
            };

            /**
             * Creates a SaveFileRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.file.SaveFileRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.file.SaveFileRequest} SaveFileRequest
             */
            SaveFileRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.file.SaveFileRequest)
                    return object;
                var message = new $root.lebai.file.SaveFileRequest();
                if (object.dir != null)
                    message.dir = String(object.dir);
                if (object.name != null)
                    message.name = String(object.name);
                if (object.file != null) {
                    if (typeof object.file !== "object")
                        throw TypeError(".lebai.file.SaveFileRequest.file: object expected");
                    message.file = $root.lebai.file.File.fromObject(object.file);
                }
                return message;
            };

            /**
             * Creates a plain object from a SaveFileRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.file.SaveFileRequest
             * @static
             * @param {lebai.file.SaveFileRequest} message SaveFileRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SaveFileRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.dir = "";
                    object.name = "";
                    object.file = null;
                }
                if (message.dir != null && message.hasOwnProperty("dir"))
                    object.dir = message.dir;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.file != null && message.hasOwnProperty("file"))
                    object.file = $root.lebai.file.File.toObject(message.file, options);
                return object;
            };

            /**
             * Converts this SaveFileRequest to JSON.
             * @function toJSON
             * @memberof lebai.file.SaveFileRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SaveFileRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SaveFileRequest
             * @function getTypeUrl
             * @memberof lebai.file.SaveFileRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SaveFileRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.file.SaveFileRequest";
            };

            return SaveFileRequest;
        })();

        file.DownloadFileRequest = (function() {

            /**
             * Properties of a DownloadFileRequest.
             * @memberof lebai.file
             * @interface IDownloadFileRequest
             * @property {string|null} [dir] DownloadFileRequest dir
             * @property {string|null} [name] DownloadFileRequest name
             * @property {string|null} [url] DownloadFileRequest url
             */

            /**
             * Constructs a new DownloadFileRequest.
             * @memberof lebai.file
             * @classdesc Represents a DownloadFileRequest.
             * @implements IDownloadFileRequest
             * @constructor
             * @param {lebai.file.IDownloadFileRequest=} [properties] Properties to set
             */
            function DownloadFileRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DownloadFileRequest dir.
             * @member {string} dir
             * @memberof lebai.file.DownloadFileRequest
             * @instance
             */
            DownloadFileRequest.prototype.dir = "";

            /**
             * DownloadFileRequest name.
             * @member {string} name
             * @memberof lebai.file.DownloadFileRequest
             * @instance
             */
            DownloadFileRequest.prototype.name = "";

            /**
             * DownloadFileRequest url.
             * @member {string} url
             * @memberof lebai.file.DownloadFileRequest
             * @instance
             */
            DownloadFileRequest.prototype.url = "";

            /**
             * Creates a new DownloadFileRequest instance using the specified properties.
             * @function create
             * @memberof lebai.file.DownloadFileRequest
             * @static
             * @param {lebai.file.IDownloadFileRequest=} [properties] Properties to set
             * @returns {lebai.file.DownloadFileRequest} DownloadFileRequest instance
             */
            DownloadFileRequest.create = function create(properties) {
                return new DownloadFileRequest(properties);
            };

            /**
             * Encodes the specified DownloadFileRequest message. Does not implicitly {@link lebai.file.DownloadFileRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.file.DownloadFileRequest
             * @static
             * @param {lebai.file.IDownloadFileRequest} message DownloadFileRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DownloadFileRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.dir != null && Object.hasOwnProperty.call(message, "dir"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.dir);
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                    writer.uint32(/* id 10, wireType 2 =*/82).string(message.url);
                return writer;
            };

            /**
             * Encodes the specified DownloadFileRequest message, length delimited. Does not implicitly {@link lebai.file.DownloadFileRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.file.DownloadFileRequest
             * @static
             * @param {lebai.file.IDownloadFileRequest} message DownloadFileRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DownloadFileRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DownloadFileRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.file.DownloadFileRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.file.DownloadFileRequest} DownloadFileRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DownloadFileRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.file.DownloadFileRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.dir = reader.string();
                            break;
                        }
                    case 2: {
                            message.name = reader.string();
                            break;
                        }
                    case 10: {
                            message.url = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DownloadFileRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.file.DownloadFileRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.file.DownloadFileRequest} DownloadFileRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DownloadFileRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DownloadFileRequest message.
             * @function verify
             * @memberof lebai.file.DownloadFileRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DownloadFileRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.dir != null && message.hasOwnProperty("dir"))
                    if (!$util.isString(message.dir))
                        return "dir: string expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.url != null && message.hasOwnProperty("url"))
                    if (!$util.isString(message.url))
                        return "url: string expected";
                return null;
            };

            /**
             * Creates a DownloadFileRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.file.DownloadFileRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.file.DownloadFileRequest} DownloadFileRequest
             */
            DownloadFileRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.file.DownloadFileRequest)
                    return object;
                var message = new $root.lebai.file.DownloadFileRequest();
                if (object.dir != null)
                    message.dir = String(object.dir);
                if (object.name != null)
                    message.name = String(object.name);
                if (object.url != null)
                    message.url = String(object.url);
                return message;
            };

            /**
             * Creates a plain object from a DownloadFileRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.file.DownloadFileRequest
             * @static
             * @param {lebai.file.DownloadFileRequest} message DownloadFileRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DownloadFileRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.dir = "";
                    object.name = "";
                    object.url = "";
                }
                if (message.dir != null && message.hasOwnProperty("dir"))
                    object.dir = message.dir;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.url != null && message.hasOwnProperty("url"))
                    object.url = message.url;
                return object;
            };

            /**
             * Converts this DownloadFileRequest to JSON.
             * @function toJSON
             * @memberof lebai.file.DownloadFileRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DownloadFileRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DownloadFileRequest
             * @function getTypeUrl
             * @memberof lebai.file.DownloadFileRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DownloadFileRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.file.DownloadFileRequest";
            };

            return DownloadFileRequest;
        })();

        file.RenameFileRequest = (function() {

            /**
             * Properties of a RenameFileRequest.
             * @memberof lebai.file
             * @interface IRenameFileRequest
             * @property {lebai.file.IFileIndex|null} [from] RenameFileRequest from
             * @property {lebai.file.IFileIndex|null} [to] RenameFileRequest to
             */

            /**
             * Constructs a new RenameFileRequest.
             * @memberof lebai.file
             * @classdesc Represents a RenameFileRequest.
             * @implements IRenameFileRequest
             * @constructor
             * @param {lebai.file.IRenameFileRequest=} [properties] Properties to set
             */
            function RenameFileRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RenameFileRequest from.
             * @member {lebai.file.IFileIndex|null|undefined} from
             * @memberof lebai.file.RenameFileRequest
             * @instance
             */
            RenameFileRequest.prototype.from = null;

            /**
             * RenameFileRequest to.
             * @member {lebai.file.IFileIndex|null|undefined} to
             * @memberof lebai.file.RenameFileRequest
             * @instance
             */
            RenameFileRequest.prototype.to = null;

            /**
             * Creates a new RenameFileRequest instance using the specified properties.
             * @function create
             * @memberof lebai.file.RenameFileRequest
             * @static
             * @param {lebai.file.IRenameFileRequest=} [properties] Properties to set
             * @returns {lebai.file.RenameFileRequest} RenameFileRequest instance
             */
            RenameFileRequest.create = function create(properties) {
                return new RenameFileRequest(properties);
            };

            /**
             * Encodes the specified RenameFileRequest message. Does not implicitly {@link lebai.file.RenameFileRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.file.RenameFileRequest
             * @static
             * @param {lebai.file.IRenameFileRequest} message RenameFileRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RenameFileRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.from != null && Object.hasOwnProperty.call(message, "from"))
                    $root.lebai.file.FileIndex.encode(message.from, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.to != null && Object.hasOwnProperty.call(message, "to"))
                    $root.lebai.file.FileIndex.encode(message.to, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RenameFileRequest message, length delimited. Does not implicitly {@link lebai.file.RenameFileRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.file.RenameFileRequest
             * @static
             * @param {lebai.file.IRenameFileRequest} message RenameFileRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RenameFileRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RenameFileRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.file.RenameFileRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.file.RenameFileRequest} RenameFileRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RenameFileRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.file.RenameFileRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.from = $root.lebai.file.FileIndex.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.to = $root.lebai.file.FileIndex.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RenameFileRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.file.RenameFileRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.file.RenameFileRequest} RenameFileRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RenameFileRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RenameFileRequest message.
             * @function verify
             * @memberof lebai.file.RenameFileRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RenameFileRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.from != null && message.hasOwnProperty("from")) {
                    var error = $root.lebai.file.FileIndex.verify(message.from);
                    if (error)
                        return "from." + error;
                }
                if (message.to != null && message.hasOwnProperty("to")) {
                    var error = $root.lebai.file.FileIndex.verify(message.to);
                    if (error)
                        return "to." + error;
                }
                return null;
            };

            /**
             * Creates a RenameFileRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.file.RenameFileRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.file.RenameFileRequest} RenameFileRequest
             */
            RenameFileRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.file.RenameFileRequest)
                    return object;
                var message = new $root.lebai.file.RenameFileRequest();
                if (object.from != null) {
                    if (typeof object.from !== "object")
                        throw TypeError(".lebai.file.RenameFileRequest.from: object expected");
                    message.from = $root.lebai.file.FileIndex.fromObject(object.from);
                }
                if (object.to != null) {
                    if (typeof object.to !== "object")
                        throw TypeError(".lebai.file.RenameFileRequest.to: object expected");
                    message.to = $root.lebai.file.FileIndex.fromObject(object.to);
                }
                return message;
            };

            /**
             * Creates a plain object from a RenameFileRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.file.RenameFileRequest
             * @static
             * @param {lebai.file.RenameFileRequest} message RenameFileRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RenameFileRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.from = null;
                    object.to = null;
                }
                if (message.from != null && message.hasOwnProperty("from"))
                    object.from = $root.lebai.file.FileIndex.toObject(message.from, options);
                if (message.to != null && message.hasOwnProperty("to"))
                    object.to = $root.lebai.file.FileIndex.toObject(message.to, options);
                return object;
            };

            /**
             * Converts this RenameFileRequest to JSON.
             * @function toJSON
             * @memberof lebai.file.RenameFileRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RenameFileRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for RenameFileRequest
             * @function getTypeUrl
             * @memberof lebai.file.RenameFileRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            RenameFileRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.file.RenameFileRequest";
            };

            return RenameFileRequest;
        })();

        file.LoadFileListRequest = (function() {

            /**
             * Properties of a LoadFileListRequest.
             * @memberof lebai.file
             * @interface ILoadFileListRequest
             * @property {string|null} [dir] LoadFileListRequest dir
             * @property {string|null} [prefix] LoadFileListRequest prefix
             * @property {string|null} [suffix] LoadFileListRequest suffix
             */

            /**
             * Constructs a new LoadFileListRequest.
             * @memberof lebai.file
             * @classdesc Represents a LoadFileListRequest.
             * @implements ILoadFileListRequest
             * @constructor
             * @param {lebai.file.ILoadFileListRequest=} [properties] Properties to set
             */
            function LoadFileListRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LoadFileListRequest dir.
             * @member {string} dir
             * @memberof lebai.file.LoadFileListRequest
             * @instance
             */
            LoadFileListRequest.prototype.dir = "";

            /**
             * LoadFileListRequest prefix.
             * @member {string} prefix
             * @memberof lebai.file.LoadFileListRequest
             * @instance
             */
            LoadFileListRequest.prototype.prefix = "";

            /**
             * LoadFileListRequest suffix.
             * @member {string} suffix
             * @memberof lebai.file.LoadFileListRequest
             * @instance
             */
            LoadFileListRequest.prototype.suffix = "";

            /**
             * Creates a new LoadFileListRequest instance using the specified properties.
             * @function create
             * @memberof lebai.file.LoadFileListRequest
             * @static
             * @param {lebai.file.ILoadFileListRequest=} [properties] Properties to set
             * @returns {lebai.file.LoadFileListRequest} LoadFileListRequest instance
             */
            LoadFileListRequest.create = function create(properties) {
                return new LoadFileListRequest(properties);
            };

            /**
             * Encodes the specified LoadFileListRequest message. Does not implicitly {@link lebai.file.LoadFileListRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.file.LoadFileListRequest
             * @static
             * @param {lebai.file.ILoadFileListRequest} message LoadFileListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LoadFileListRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.dir != null && Object.hasOwnProperty.call(message, "dir"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.dir);
                if (message.prefix != null && Object.hasOwnProperty.call(message, "prefix"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.prefix);
                if (message.suffix != null && Object.hasOwnProperty.call(message, "suffix"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.suffix);
                return writer;
            };

            /**
             * Encodes the specified LoadFileListRequest message, length delimited. Does not implicitly {@link lebai.file.LoadFileListRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.file.LoadFileListRequest
             * @static
             * @param {lebai.file.ILoadFileListRequest} message LoadFileListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LoadFileListRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LoadFileListRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.file.LoadFileListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.file.LoadFileListRequest} LoadFileListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LoadFileListRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.file.LoadFileListRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.dir = reader.string();
                            break;
                        }
                    case 2: {
                            message.prefix = reader.string();
                            break;
                        }
                    case 3: {
                            message.suffix = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LoadFileListRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.file.LoadFileListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.file.LoadFileListRequest} LoadFileListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LoadFileListRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LoadFileListRequest message.
             * @function verify
             * @memberof lebai.file.LoadFileListRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LoadFileListRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.dir != null && message.hasOwnProperty("dir"))
                    if (!$util.isString(message.dir))
                        return "dir: string expected";
                if (message.prefix != null && message.hasOwnProperty("prefix"))
                    if (!$util.isString(message.prefix))
                        return "prefix: string expected";
                if (message.suffix != null && message.hasOwnProperty("suffix"))
                    if (!$util.isString(message.suffix))
                        return "suffix: string expected";
                return null;
            };

            /**
             * Creates a LoadFileListRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.file.LoadFileListRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.file.LoadFileListRequest} LoadFileListRequest
             */
            LoadFileListRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.file.LoadFileListRequest)
                    return object;
                var message = new $root.lebai.file.LoadFileListRequest();
                if (object.dir != null)
                    message.dir = String(object.dir);
                if (object.prefix != null)
                    message.prefix = String(object.prefix);
                if (object.suffix != null)
                    message.suffix = String(object.suffix);
                return message;
            };

            /**
             * Creates a plain object from a LoadFileListRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.file.LoadFileListRequest
             * @static
             * @param {lebai.file.LoadFileListRequest} message LoadFileListRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LoadFileListRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.dir = "";
                    object.prefix = "";
                    object.suffix = "";
                }
                if (message.dir != null && message.hasOwnProperty("dir"))
                    object.dir = message.dir;
                if (message.prefix != null && message.hasOwnProperty("prefix"))
                    object.prefix = message.prefix;
                if (message.suffix != null && message.hasOwnProperty("suffix"))
                    object.suffix = message.suffix;
                return object;
            };

            /**
             * Converts this LoadFileListRequest to JSON.
             * @function toJSON
             * @memberof lebai.file.LoadFileListRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LoadFileListRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for LoadFileListRequest
             * @function getTypeUrl
             * @memberof lebai.file.LoadFileListRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            LoadFileListRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.file.LoadFileListRequest";
            };

            return LoadFileListRequest;
        })();

        file.LoadFileListResponse = (function() {

            /**
             * Properties of a LoadFileListResponse.
             * @memberof lebai.file
             * @interface ILoadFileListResponse
             * @property {Array.<lebai.file.IFileName>|null} [files] LoadFileListResponse files
             */

            /**
             * Constructs a new LoadFileListResponse.
             * @memberof lebai.file
             * @classdesc Represents a LoadFileListResponse.
             * @implements ILoadFileListResponse
             * @constructor
             * @param {lebai.file.ILoadFileListResponse=} [properties] Properties to set
             */
            function LoadFileListResponse(properties) {
                this.files = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LoadFileListResponse files.
             * @member {Array.<lebai.file.IFileName>} files
             * @memberof lebai.file.LoadFileListResponse
             * @instance
             */
            LoadFileListResponse.prototype.files = $util.emptyArray;

            /**
             * Creates a new LoadFileListResponse instance using the specified properties.
             * @function create
             * @memberof lebai.file.LoadFileListResponse
             * @static
             * @param {lebai.file.ILoadFileListResponse=} [properties] Properties to set
             * @returns {lebai.file.LoadFileListResponse} LoadFileListResponse instance
             */
            LoadFileListResponse.create = function create(properties) {
                return new LoadFileListResponse(properties);
            };

            /**
             * Encodes the specified LoadFileListResponse message. Does not implicitly {@link lebai.file.LoadFileListResponse.verify|verify} messages.
             * @function encode
             * @memberof lebai.file.LoadFileListResponse
             * @static
             * @param {lebai.file.ILoadFileListResponse} message LoadFileListResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LoadFileListResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.files != null && message.files.length)
                    for (var i = 0; i < message.files.length; ++i)
                        $root.lebai.file.FileName.encode(message.files[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified LoadFileListResponse message, length delimited. Does not implicitly {@link lebai.file.LoadFileListResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.file.LoadFileListResponse
             * @static
             * @param {lebai.file.ILoadFileListResponse} message LoadFileListResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LoadFileListResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LoadFileListResponse message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.file.LoadFileListResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.file.LoadFileListResponse} LoadFileListResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LoadFileListResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.file.LoadFileListResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.files && message.files.length))
                                message.files = [];
                            message.files.push($root.lebai.file.FileName.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LoadFileListResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.file.LoadFileListResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.file.LoadFileListResponse} LoadFileListResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LoadFileListResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LoadFileListResponse message.
             * @function verify
             * @memberof lebai.file.LoadFileListResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LoadFileListResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.files != null && message.hasOwnProperty("files")) {
                    if (!Array.isArray(message.files))
                        return "files: array expected";
                    for (var i = 0; i < message.files.length; ++i) {
                        var error = $root.lebai.file.FileName.verify(message.files[i]);
                        if (error)
                            return "files." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a LoadFileListResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.file.LoadFileListResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.file.LoadFileListResponse} LoadFileListResponse
             */
            LoadFileListResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.file.LoadFileListResponse)
                    return object;
                var message = new $root.lebai.file.LoadFileListResponse();
                if (object.files) {
                    if (!Array.isArray(object.files))
                        throw TypeError(".lebai.file.LoadFileListResponse.files: array expected");
                    message.files = [];
                    for (var i = 0; i < object.files.length; ++i) {
                        if (typeof object.files[i] !== "object")
                            throw TypeError(".lebai.file.LoadFileListResponse.files: object expected");
                        message.files[i] = $root.lebai.file.FileName.fromObject(object.files[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a LoadFileListResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.file.LoadFileListResponse
             * @static
             * @param {lebai.file.LoadFileListResponse} message LoadFileListResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LoadFileListResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.files = [];
                if (message.files && message.files.length) {
                    object.files = [];
                    for (var j = 0; j < message.files.length; ++j)
                        object.files[j] = $root.lebai.file.FileName.toObject(message.files[j], options);
                }
                return object;
            };

            /**
             * Converts this LoadFileListResponse to JSON.
             * @function toJSON
             * @memberof lebai.file.LoadFileListResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LoadFileListResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for LoadFileListResponse
             * @function getTypeUrl
             * @memberof lebai.file.LoadFileListResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            LoadFileListResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.file.LoadFileListResponse";
            };

            return LoadFileListResponse;
        })();

        file.ZipRequest = (function() {

            /**
             * Properties of a ZipRequest.
             * @memberof lebai.file
             * @interface IZipRequest
             * @property {lebai.file.IFileIndex|null} [zip] ZipRequest zip
             * @property {Array.<string>|null} [files] ZipRequest files
             * @property {string|null} [dir] ZipRequest dir
             */

            /**
             * Constructs a new ZipRequest.
             * @memberof lebai.file
             * @classdesc Represents a ZipRequest.
             * @implements IZipRequest
             * @constructor
             * @param {lebai.file.IZipRequest=} [properties] Properties to set
             */
            function ZipRequest(properties) {
                this.files = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ZipRequest zip.
             * @member {lebai.file.IFileIndex|null|undefined} zip
             * @memberof lebai.file.ZipRequest
             * @instance
             */
            ZipRequest.prototype.zip = null;

            /**
             * ZipRequest files.
             * @member {Array.<string>} files
             * @memberof lebai.file.ZipRequest
             * @instance
             */
            ZipRequest.prototype.files = $util.emptyArray;

            /**
             * ZipRequest dir.
             * @member {string} dir
             * @memberof lebai.file.ZipRequest
             * @instance
             */
            ZipRequest.prototype.dir = "";

            /**
             * Creates a new ZipRequest instance using the specified properties.
             * @function create
             * @memberof lebai.file.ZipRequest
             * @static
             * @param {lebai.file.IZipRequest=} [properties] Properties to set
             * @returns {lebai.file.ZipRequest} ZipRequest instance
             */
            ZipRequest.create = function create(properties) {
                return new ZipRequest(properties);
            };

            /**
             * Encodes the specified ZipRequest message. Does not implicitly {@link lebai.file.ZipRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.file.ZipRequest
             * @static
             * @param {lebai.file.IZipRequest} message ZipRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ZipRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.zip != null && Object.hasOwnProperty.call(message, "zip"))
                    $root.lebai.file.FileIndex.encode(message.zip, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.dir != null && Object.hasOwnProperty.call(message, "dir"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.dir);
                if (message.files != null && message.files.length)
                    for (var i = 0; i < message.files.length; ++i)
                        writer.uint32(/* id 11, wireType 2 =*/90).string(message.files[i]);
                return writer;
            };

            /**
             * Encodes the specified ZipRequest message, length delimited. Does not implicitly {@link lebai.file.ZipRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.file.ZipRequest
             * @static
             * @param {lebai.file.IZipRequest} message ZipRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ZipRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ZipRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.file.ZipRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.file.ZipRequest} ZipRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ZipRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.file.ZipRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.zip = $root.lebai.file.FileIndex.decode(reader, reader.uint32());
                            break;
                        }
                    case 11: {
                            if (!(message.files && message.files.length))
                                message.files = [];
                            message.files.push(reader.string());
                            break;
                        }
                    case 2: {
                            message.dir = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ZipRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.file.ZipRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.file.ZipRequest} ZipRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ZipRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ZipRequest message.
             * @function verify
             * @memberof lebai.file.ZipRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ZipRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.zip != null && message.hasOwnProperty("zip")) {
                    var error = $root.lebai.file.FileIndex.verify(message.zip);
                    if (error)
                        return "zip." + error;
                }
                if (message.files != null && message.hasOwnProperty("files")) {
                    if (!Array.isArray(message.files))
                        return "files: array expected";
                    for (var i = 0; i < message.files.length; ++i)
                        if (!$util.isString(message.files[i]))
                            return "files: string[] expected";
                }
                if (message.dir != null && message.hasOwnProperty("dir"))
                    if (!$util.isString(message.dir))
                        return "dir: string expected";
                return null;
            };

            /**
             * Creates a ZipRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.file.ZipRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.file.ZipRequest} ZipRequest
             */
            ZipRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.file.ZipRequest)
                    return object;
                var message = new $root.lebai.file.ZipRequest();
                if (object.zip != null) {
                    if (typeof object.zip !== "object")
                        throw TypeError(".lebai.file.ZipRequest.zip: object expected");
                    message.zip = $root.lebai.file.FileIndex.fromObject(object.zip);
                }
                if (object.files) {
                    if (!Array.isArray(object.files))
                        throw TypeError(".lebai.file.ZipRequest.files: array expected");
                    message.files = [];
                    for (var i = 0; i < object.files.length; ++i)
                        message.files[i] = String(object.files[i]);
                }
                if (object.dir != null)
                    message.dir = String(object.dir);
                return message;
            };

            /**
             * Creates a plain object from a ZipRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.file.ZipRequest
             * @static
             * @param {lebai.file.ZipRequest} message ZipRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ZipRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.files = [];
                if (options.defaults) {
                    object.zip = null;
                    object.dir = "";
                }
                if (message.zip != null && message.hasOwnProperty("zip"))
                    object.zip = $root.lebai.file.FileIndex.toObject(message.zip, options);
                if (message.dir != null && message.hasOwnProperty("dir"))
                    object.dir = message.dir;
                if (message.files && message.files.length) {
                    object.files = [];
                    for (var j = 0; j < message.files.length; ++j)
                        object.files[j] = message.files[j];
                }
                return object;
            };

            /**
             * Converts this ZipRequest to JSON.
             * @function toJSON
             * @memberof lebai.file.ZipRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ZipRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ZipRequest
             * @function getTypeUrl
             * @memberof lebai.file.ZipRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ZipRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.file.ZipRequest";
            };

            return ZipRequest;
        })();

        file.UnzipRequest = (function() {

            /**
             * Properties of an UnzipRequest.
             * @memberof lebai.file
             * @interface IUnzipRequest
             * @property {lebai.file.IFileIndex|null} [zip] UnzipRequest zip
             * @property {Array.<string>|null} [files] UnzipRequest files
             * @property {string|null} [dir] UnzipRequest dir
             */

            /**
             * Constructs a new UnzipRequest.
             * @memberof lebai.file
             * @classdesc Represents an UnzipRequest.
             * @implements IUnzipRequest
             * @constructor
             * @param {lebai.file.IUnzipRequest=} [properties] Properties to set
             */
            function UnzipRequest(properties) {
                this.files = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UnzipRequest zip.
             * @member {lebai.file.IFileIndex|null|undefined} zip
             * @memberof lebai.file.UnzipRequest
             * @instance
             */
            UnzipRequest.prototype.zip = null;

            /**
             * UnzipRequest files.
             * @member {Array.<string>} files
             * @memberof lebai.file.UnzipRequest
             * @instance
             */
            UnzipRequest.prototype.files = $util.emptyArray;

            /**
             * UnzipRequest dir.
             * @member {string} dir
             * @memberof lebai.file.UnzipRequest
             * @instance
             */
            UnzipRequest.prototype.dir = "";

            /**
             * Creates a new UnzipRequest instance using the specified properties.
             * @function create
             * @memberof lebai.file.UnzipRequest
             * @static
             * @param {lebai.file.IUnzipRequest=} [properties] Properties to set
             * @returns {lebai.file.UnzipRequest} UnzipRequest instance
             */
            UnzipRequest.create = function create(properties) {
                return new UnzipRequest(properties);
            };

            /**
             * Encodes the specified UnzipRequest message. Does not implicitly {@link lebai.file.UnzipRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.file.UnzipRequest
             * @static
             * @param {lebai.file.IUnzipRequest} message UnzipRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UnzipRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.zip != null && Object.hasOwnProperty.call(message, "zip"))
                    $root.lebai.file.FileIndex.encode(message.zip, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.files != null && message.files.length)
                    for (var i = 0; i < message.files.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.files[i]);
                if (message.dir != null && Object.hasOwnProperty.call(message, "dir"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.dir);
                return writer;
            };

            /**
             * Encodes the specified UnzipRequest message, length delimited. Does not implicitly {@link lebai.file.UnzipRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.file.UnzipRequest
             * @static
             * @param {lebai.file.IUnzipRequest} message UnzipRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UnzipRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an UnzipRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.file.UnzipRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.file.UnzipRequest} UnzipRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UnzipRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.file.UnzipRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.zip = $root.lebai.file.FileIndex.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            if (!(message.files && message.files.length))
                                message.files = [];
                            message.files.push(reader.string());
                            break;
                        }
                    case 11: {
                            message.dir = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an UnzipRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.file.UnzipRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.file.UnzipRequest} UnzipRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UnzipRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an UnzipRequest message.
             * @function verify
             * @memberof lebai.file.UnzipRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UnzipRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.zip != null && message.hasOwnProperty("zip")) {
                    var error = $root.lebai.file.FileIndex.verify(message.zip);
                    if (error)
                        return "zip." + error;
                }
                if (message.files != null && message.hasOwnProperty("files")) {
                    if (!Array.isArray(message.files))
                        return "files: array expected";
                    for (var i = 0; i < message.files.length; ++i)
                        if (!$util.isString(message.files[i]))
                            return "files: string[] expected";
                }
                if (message.dir != null && message.hasOwnProperty("dir"))
                    if (!$util.isString(message.dir))
                        return "dir: string expected";
                return null;
            };

            /**
             * Creates an UnzipRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.file.UnzipRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.file.UnzipRequest} UnzipRequest
             */
            UnzipRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.file.UnzipRequest)
                    return object;
                var message = new $root.lebai.file.UnzipRequest();
                if (object.zip != null) {
                    if (typeof object.zip !== "object")
                        throw TypeError(".lebai.file.UnzipRequest.zip: object expected");
                    message.zip = $root.lebai.file.FileIndex.fromObject(object.zip);
                }
                if (object.files) {
                    if (!Array.isArray(object.files))
                        throw TypeError(".lebai.file.UnzipRequest.files: array expected");
                    message.files = [];
                    for (var i = 0; i < object.files.length; ++i)
                        message.files[i] = String(object.files[i]);
                }
                if (object.dir != null)
                    message.dir = String(object.dir);
                return message;
            };

            /**
             * Creates a plain object from an UnzipRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.file.UnzipRequest
             * @static
             * @param {lebai.file.UnzipRequest} message UnzipRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UnzipRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.files = [];
                if (options.defaults) {
                    object.zip = null;
                    object.dir = "";
                }
                if (message.zip != null && message.hasOwnProperty("zip"))
                    object.zip = $root.lebai.file.FileIndex.toObject(message.zip, options);
                if (message.files && message.files.length) {
                    object.files = [];
                    for (var j = 0; j < message.files.length; ++j)
                        object.files[j] = message.files[j];
                }
                if (message.dir != null && message.hasOwnProperty("dir"))
                    object.dir = message.dir;
                return object;
            };

            /**
             * Converts this UnzipRequest to JSON.
             * @function toJSON
             * @memberof lebai.file.UnzipRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UnzipRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for UnzipRequest
             * @function getTypeUrl
             * @memberof lebai.file.UnzipRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            UnzipRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.file.UnzipRequest";
            };

            return UnzipRequest;
        })();

        file.LoadZipListRequest = (function() {

            /**
             * Properties of a LoadZipListRequest.
             * @memberof lebai.file
             * @interface ILoadZipListRequest
             * @property {lebai.file.IFileIndex|null} [zip] LoadZipListRequest zip
             * @property {string|null} [dir] LoadZipListRequest dir
             * @property {string|null} [prefix] LoadZipListRequest prefix
             * @property {string|null} [suffix] LoadZipListRequest suffix
             */

            /**
             * Constructs a new LoadZipListRequest.
             * @memberof lebai.file
             * @classdesc Represents a LoadZipListRequest.
             * @implements ILoadZipListRequest
             * @constructor
             * @param {lebai.file.ILoadZipListRequest=} [properties] Properties to set
             */
            function LoadZipListRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LoadZipListRequest zip.
             * @member {lebai.file.IFileIndex|null|undefined} zip
             * @memberof lebai.file.LoadZipListRequest
             * @instance
             */
            LoadZipListRequest.prototype.zip = null;

            /**
             * LoadZipListRequest dir.
             * @member {string} dir
             * @memberof lebai.file.LoadZipListRequest
             * @instance
             */
            LoadZipListRequest.prototype.dir = "";

            /**
             * LoadZipListRequest prefix.
             * @member {string} prefix
             * @memberof lebai.file.LoadZipListRequest
             * @instance
             */
            LoadZipListRequest.prototype.prefix = "";

            /**
             * LoadZipListRequest suffix.
             * @member {string} suffix
             * @memberof lebai.file.LoadZipListRequest
             * @instance
             */
            LoadZipListRequest.prototype.suffix = "";

            /**
             * Creates a new LoadZipListRequest instance using the specified properties.
             * @function create
             * @memberof lebai.file.LoadZipListRequest
             * @static
             * @param {lebai.file.ILoadZipListRequest=} [properties] Properties to set
             * @returns {lebai.file.LoadZipListRequest} LoadZipListRequest instance
             */
            LoadZipListRequest.create = function create(properties) {
                return new LoadZipListRequest(properties);
            };

            /**
             * Encodes the specified LoadZipListRequest message. Does not implicitly {@link lebai.file.LoadZipListRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.file.LoadZipListRequest
             * @static
             * @param {lebai.file.ILoadZipListRequest} message LoadZipListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LoadZipListRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.zip != null && Object.hasOwnProperty.call(message, "zip"))
                    $root.lebai.file.FileIndex.encode(message.zip, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.dir != null && Object.hasOwnProperty.call(message, "dir"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.dir);
                if (message.prefix != null && Object.hasOwnProperty.call(message, "prefix"))
                    writer.uint32(/* id 12, wireType 2 =*/98).string(message.prefix);
                if (message.suffix != null && Object.hasOwnProperty.call(message, "suffix"))
                    writer.uint32(/* id 13, wireType 2 =*/106).string(message.suffix);
                return writer;
            };

            /**
             * Encodes the specified LoadZipListRequest message, length delimited. Does not implicitly {@link lebai.file.LoadZipListRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.file.LoadZipListRequest
             * @static
             * @param {lebai.file.ILoadZipListRequest} message LoadZipListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LoadZipListRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LoadZipListRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.file.LoadZipListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.file.LoadZipListRequest} LoadZipListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LoadZipListRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.file.LoadZipListRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.zip = $root.lebai.file.FileIndex.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.dir = reader.string();
                            break;
                        }
                    case 12: {
                            message.prefix = reader.string();
                            break;
                        }
                    case 13: {
                            message.suffix = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LoadZipListRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.file.LoadZipListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.file.LoadZipListRequest} LoadZipListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LoadZipListRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LoadZipListRequest message.
             * @function verify
             * @memberof lebai.file.LoadZipListRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LoadZipListRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.zip != null && message.hasOwnProperty("zip")) {
                    var error = $root.lebai.file.FileIndex.verify(message.zip);
                    if (error)
                        return "zip." + error;
                }
                if (message.dir != null && message.hasOwnProperty("dir"))
                    if (!$util.isString(message.dir))
                        return "dir: string expected";
                if (message.prefix != null && message.hasOwnProperty("prefix"))
                    if (!$util.isString(message.prefix))
                        return "prefix: string expected";
                if (message.suffix != null && message.hasOwnProperty("suffix"))
                    if (!$util.isString(message.suffix))
                        return "suffix: string expected";
                return null;
            };

            /**
             * Creates a LoadZipListRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.file.LoadZipListRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.file.LoadZipListRequest} LoadZipListRequest
             */
            LoadZipListRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.file.LoadZipListRequest)
                    return object;
                var message = new $root.lebai.file.LoadZipListRequest();
                if (object.zip != null) {
                    if (typeof object.zip !== "object")
                        throw TypeError(".lebai.file.LoadZipListRequest.zip: object expected");
                    message.zip = $root.lebai.file.FileIndex.fromObject(object.zip);
                }
                if (object.dir != null)
                    message.dir = String(object.dir);
                if (object.prefix != null)
                    message.prefix = String(object.prefix);
                if (object.suffix != null)
                    message.suffix = String(object.suffix);
                return message;
            };

            /**
             * Creates a plain object from a LoadZipListRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.file.LoadZipListRequest
             * @static
             * @param {lebai.file.LoadZipListRequest} message LoadZipListRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LoadZipListRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.zip = null;
                    object.dir = "";
                    object.prefix = "";
                    object.suffix = "";
                }
                if (message.zip != null && message.hasOwnProperty("zip"))
                    object.zip = $root.lebai.file.FileIndex.toObject(message.zip, options);
                if (message.dir != null && message.hasOwnProperty("dir"))
                    object.dir = message.dir;
                if (message.prefix != null && message.hasOwnProperty("prefix"))
                    object.prefix = message.prefix;
                if (message.suffix != null && message.hasOwnProperty("suffix"))
                    object.suffix = message.suffix;
                return object;
            };

            /**
             * Converts this LoadZipListRequest to JSON.
             * @function toJSON
             * @memberof lebai.file.LoadZipListRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LoadZipListRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for LoadZipListRequest
             * @function getTypeUrl
             * @memberof lebai.file.LoadZipListRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            LoadZipListRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.file.LoadZipListRequest";
            };

            return LoadZipListRequest;
        })();

        file.LoadZipListResponse = (function() {

            /**
             * Properties of a LoadZipListResponse.
             * @memberof lebai.file
             * @interface ILoadZipListResponse
             * @property {Array.<lebai.file.IFileName>|null} [files] LoadZipListResponse files
             */

            /**
             * Constructs a new LoadZipListResponse.
             * @memberof lebai.file
             * @classdesc Represents a LoadZipListResponse.
             * @implements ILoadZipListResponse
             * @constructor
             * @param {lebai.file.ILoadZipListResponse=} [properties] Properties to set
             */
            function LoadZipListResponse(properties) {
                this.files = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LoadZipListResponse files.
             * @member {Array.<lebai.file.IFileName>} files
             * @memberof lebai.file.LoadZipListResponse
             * @instance
             */
            LoadZipListResponse.prototype.files = $util.emptyArray;

            /**
             * Creates a new LoadZipListResponse instance using the specified properties.
             * @function create
             * @memberof lebai.file.LoadZipListResponse
             * @static
             * @param {lebai.file.ILoadZipListResponse=} [properties] Properties to set
             * @returns {lebai.file.LoadZipListResponse} LoadZipListResponse instance
             */
            LoadZipListResponse.create = function create(properties) {
                return new LoadZipListResponse(properties);
            };

            /**
             * Encodes the specified LoadZipListResponse message. Does not implicitly {@link lebai.file.LoadZipListResponse.verify|verify} messages.
             * @function encode
             * @memberof lebai.file.LoadZipListResponse
             * @static
             * @param {lebai.file.ILoadZipListResponse} message LoadZipListResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LoadZipListResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.files != null && message.files.length)
                    for (var i = 0; i < message.files.length; ++i)
                        $root.lebai.file.FileName.encode(message.files[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified LoadZipListResponse message, length delimited. Does not implicitly {@link lebai.file.LoadZipListResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.file.LoadZipListResponse
             * @static
             * @param {lebai.file.ILoadZipListResponse} message LoadZipListResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LoadZipListResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LoadZipListResponse message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.file.LoadZipListResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.file.LoadZipListResponse} LoadZipListResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LoadZipListResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.file.LoadZipListResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.files && message.files.length))
                                message.files = [];
                            message.files.push($root.lebai.file.FileName.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LoadZipListResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.file.LoadZipListResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.file.LoadZipListResponse} LoadZipListResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LoadZipListResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LoadZipListResponse message.
             * @function verify
             * @memberof lebai.file.LoadZipListResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LoadZipListResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.files != null && message.hasOwnProperty("files")) {
                    if (!Array.isArray(message.files))
                        return "files: array expected";
                    for (var i = 0; i < message.files.length; ++i) {
                        var error = $root.lebai.file.FileName.verify(message.files[i]);
                        if (error)
                            return "files." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a LoadZipListResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.file.LoadZipListResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.file.LoadZipListResponse} LoadZipListResponse
             */
            LoadZipListResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.file.LoadZipListResponse)
                    return object;
                var message = new $root.lebai.file.LoadZipListResponse();
                if (object.files) {
                    if (!Array.isArray(object.files))
                        throw TypeError(".lebai.file.LoadZipListResponse.files: array expected");
                    message.files = [];
                    for (var i = 0; i < object.files.length; ++i) {
                        if (typeof object.files[i] !== "object")
                            throw TypeError(".lebai.file.LoadZipListResponse.files: object expected");
                        message.files[i] = $root.lebai.file.FileName.fromObject(object.files[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a LoadZipListResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.file.LoadZipListResponse
             * @static
             * @param {lebai.file.LoadZipListResponse} message LoadZipListResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LoadZipListResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.files = [];
                if (message.files && message.files.length) {
                    object.files = [];
                    for (var j = 0; j < message.files.length; ++j)
                        object.files[j] = $root.lebai.file.FileName.toObject(message.files[j], options);
                }
                return object;
            };

            /**
             * Converts this LoadZipListResponse to JSON.
             * @function toJSON
             * @memberof lebai.file.LoadZipListResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LoadZipListResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for LoadZipListResponse
             * @function getTypeUrl
             * @memberof lebai.file.LoadZipListResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            LoadZipListResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.file.LoadZipListResponse";
            };

            return LoadZipListResponse;
        })();

        file.FileService = (function() {

            /**
             * Constructs a new FileService service.
             * @memberof lebai.file
             * @classdesc Represents a FileService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function FileService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (FileService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = FileService;

            /**
             * Creates new FileService service using the specified rpc implementation.
             * @function create
             * @memberof lebai.file.FileService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {FileService} RPC service. Useful where requests and/or responses are streamed.
             */
            FileService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link lebai.file.FileService#saveFile}.
             * @memberof lebai.file.FileService
             * @typedef SaveFileCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls SaveFile.
             * @function saveFile
             * @memberof lebai.file.FileService
             * @instance
             * @param {lebai.file.ISaveFileRequest} request SaveFileRequest message or plain object
             * @param {lebai.file.FileService.SaveFileCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(FileService.prototype.saveFile = function saveFile(request, callback) {
                return this.rpcCall(saveFile, $root.lebai.file.SaveFileRequest, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "SaveFile" });

            /**
             * Calls SaveFile.
             * @function saveFile
             * @memberof lebai.file.FileService
             * @instance
             * @param {lebai.file.ISaveFileRequest} request SaveFileRequest message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.file.FileService#downloadFile}.
             * @memberof lebai.file.FileService
             * @typedef DownloadFileCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls DownloadFile.
             * @function downloadFile
             * @memberof lebai.file.FileService
             * @instance
             * @param {lebai.file.IDownloadFileRequest} request DownloadFileRequest message or plain object
             * @param {lebai.file.FileService.DownloadFileCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(FileService.prototype.downloadFile = function downloadFile(request, callback) {
                return this.rpcCall(downloadFile, $root.lebai.file.DownloadFileRequest, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "DownloadFile" });

            /**
             * Calls DownloadFile.
             * @function downloadFile
             * @memberof lebai.file.FileService
             * @instance
             * @param {lebai.file.IDownloadFileRequest} request DownloadFileRequest message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.file.FileService#renameFile}.
             * @memberof lebai.file.FileService
             * @typedef RenameFileCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls RenameFile.
             * @function renameFile
             * @memberof lebai.file.FileService
             * @instance
             * @param {lebai.file.IRenameFileRequest} request RenameFileRequest message or plain object
             * @param {lebai.file.FileService.RenameFileCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(FileService.prototype.renameFile = function renameFile(request, callback) {
                return this.rpcCall(renameFile, $root.lebai.file.RenameFileRequest, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "RenameFile" });

            /**
             * Calls RenameFile.
             * @function renameFile
             * @memberof lebai.file.FileService
             * @instance
             * @param {lebai.file.IRenameFileRequest} request RenameFileRequest message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.file.FileService#loadFile}.
             * @memberof lebai.file.FileService
             * @typedef LoadFileCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.file.File} [response] File
             */

            /**
             * Calls LoadFile.
             * @function loadFile
             * @memberof lebai.file.FileService
             * @instance
             * @param {lebai.file.IFileIndex} request FileIndex message or plain object
             * @param {lebai.file.FileService.LoadFileCallback} callback Node-style callback called with the error, if any, and File
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(FileService.prototype.loadFile = function loadFile(request, callback) {
                return this.rpcCall(loadFile, $root.lebai.file.FileIndex, $root.lebai.file.File, request, callback);
            }, "name", { value: "LoadFile" });

            /**
             * Calls LoadFile.
             * @function loadFile
             * @memberof lebai.file.FileService
             * @instance
             * @param {lebai.file.IFileIndex} request FileIndex message or plain object
             * @returns {Promise<lebai.file.File>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.file.FileService#loadFileList}.
             * @memberof lebai.file.FileService
             * @typedef LoadFileListCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.file.LoadFileListResponse} [response] LoadFileListResponse
             */

            /**
             * Calls LoadFileList.
             * @function loadFileList
             * @memberof lebai.file.FileService
             * @instance
             * @param {lebai.file.ILoadFileListRequest} request LoadFileListRequest message or plain object
             * @param {lebai.file.FileService.LoadFileListCallback} callback Node-style callback called with the error, if any, and LoadFileListResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(FileService.prototype.loadFileList = function loadFileList(request, callback) {
                return this.rpcCall(loadFileList, $root.lebai.file.LoadFileListRequest, $root.lebai.file.LoadFileListResponse, request, callback);
            }, "name", { value: "LoadFileList" });

            /**
             * Calls LoadFileList.
             * @function loadFileList
             * @memberof lebai.file.FileService
             * @instance
             * @param {lebai.file.ILoadFileListRequest} request LoadFileListRequest message or plain object
             * @returns {Promise<lebai.file.LoadFileListResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.file.FileService#zip}.
             * @memberof lebai.file.FileService
             * @typedef ZipCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls Zip.
             * @function zip
             * @memberof lebai.file.FileService
             * @instance
             * @param {lebai.file.IZipRequest} request ZipRequest message or plain object
             * @param {lebai.file.FileService.ZipCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(FileService.prototype.zip = function zip(request, callback) {
                return this.rpcCall(zip, $root.lebai.file.ZipRequest, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "Zip" });

            /**
             * Calls Zip.
             * @function zip
             * @memberof lebai.file.FileService
             * @instance
             * @param {lebai.file.IZipRequest} request ZipRequest message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.file.FileService#unzip}.
             * @memberof lebai.file.FileService
             * @typedef UnzipCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls Unzip.
             * @function unzip
             * @memberof lebai.file.FileService
             * @instance
             * @param {lebai.file.IUnzipRequest} request UnzipRequest message or plain object
             * @param {lebai.file.FileService.UnzipCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(FileService.prototype.unzip = function unzip(request, callback) {
                return this.rpcCall(unzip, $root.lebai.file.UnzipRequest, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "Unzip" });

            /**
             * Calls Unzip.
             * @function unzip
             * @memberof lebai.file.FileService
             * @instance
             * @param {lebai.file.IUnzipRequest} request UnzipRequest message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.file.FileService#loadZipList}.
             * @memberof lebai.file.FileService
             * @typedef LoadZipListCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.file.LoadZipListResponse} [response] LoadZipListResponse
             */

            /**
             * Calls LoadZipList.
             * @function loadZipList
             * @memberof lebai.file.FileService
             * @instance
             * @param {lebai.file.ILoadZipListRequest} request LoadZipListRequest message or plain object
             * @param {lebai.file.FileService.LoadZipListCallback} callback Node-style callback called with the error, if any, and LoadZipListResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(FileService.prototype.loadZipList = function loadZipList(request, callback) {
                return this.rpcCall(loadZipList, $root.lebai.file.LoadZipListRequest, $root.lebai.file.LoadZipListResponse, request, callback);
            }, "name", { value: "LoadZipList" });

            /**
             * Calls LoadZipList.
             * @function loadZipList
             * @memberof lebai.file.FileService
             * @instance
             * @param {lebai.file.ILoadZipListRequest} request LoadZipListRequest message or plain object
             * @returns {Promise<lebai.file.LoadZipListResponse>} Promise
             * @variation 2
             */

            return FileService;
        })();

        return file;
    })();

    lebai.io = (function() {

        /**
         * Namespace io.
         * @memberof lebai
         * @namespace
         */
        var io = {};

        /**
         * IoDevice enum.
         * @name lebai.io.IoDevice
         * @enum {number}
         * @property {number} ROBOT=0 ROBOT value
         * @property {number} FLANGE=1 FLANGE value
         * @property {number} EXTRA=2 EXTRA value
         * @property {number} ROBOT_BTN=10 ROBOT_BTN value
         * @property {number} SHOULDER=11 SHOULDER value
         * @property {number} FLANGE_BTN=12 FLANGE_BTN value
         */
        io.IoDevice = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "ROBOT"] = 0;
            values[valuesById[1] = "FLANGE"] = 1;
            values[valuesById[2] = "EXTRA"] = 2;
            values[valuesById[10] = "ROBOT_BTN"] = 10;
            values[valuesById[11] = "SHOULDER"] = 11;
            values[valuesById[12] = "FLANGE_BTN"] = 12;
            return values;
        })();

        /**
         * IoPinKind enum.
         * @name lebai.io.IoPinKind
         * @enum {number}
         * @property {number} DI=0 DI value
         * @property {number} DO=1 DO value
         * @property {number} AI=2 AI value
         * @property {number} AO=3 AO value
         */
        io.IoPinKind = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "DI"] = 0;
            values[valuesById[1] = "DO"] = 1;
            values[valuesById[2] = "AI"] = 2;
            values[valuesById[3] = "AO"] = 3;
            return values;
        })();

        /**
         * DigitalMode enum.
         * @name lebai.io.DigitalMode
         * @enum {number}
         * @property {number} INPUT=0 INPUT value
         * @property {number} OUTPUT=1 OUTPUT value
         */
        io.DigitalMode = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "INPUT"] = 0;
            values[valuesById[1] = "OUTPUT"] = 1;
            return values;
        })();

        /**
         * AnalogMode enum.
         * @name lebai.io.AnalogMode
         * @enum {number}
         * @property {number} VOLTAGE=0 VOLTAGE value
         * @property {number} CURRENT=1 CURRENT value
         */
        io.AnalogMode = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "VOLTAGE"] = 0;
            values[valuesById[1] = "CURRENT"] = 1;
            return values;
        })();

        io.SetDoPinRequest = (function() {

            /**
             * Properties of a SetDoPinRequest.
             * @memberof lebai.io
             * @interface ISetDoPinRequest
             * @property {lebai.io.IoDevice|null} [device] SetDoPinRequest device
             * @property {number|null} [pin] SetDoPinRequest pin
             * @property {number|null} [value] SetDoPinRequest value
             */

            /**
             * Constructs a new SetDoPinRequest.
             * @memberof lebai.io
             * @classdesc Represents a SetDoPinRequest.
             * @implements ISetDoPinRequest
             * @constructor
             * @param {lebai.io.ISetDoPinRequest=} [properties] Properties to set
             */
            function SetDoPinRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SetDoPinRequest device.
             * @member {lebai.io.IoDevice} device
             * @memberof lebai.io.SetDoPinRequest
             * @instance
             */
            SetDoPinRequest.prototype.device = 0;

            /**
             * SetDoPinRequest pin.
             * @member {number} pin
             * @memberof lebai.io.SetDoPinRequest
             * @instance
             */
            SetDoPinRequest.prototype.pin = 0;

            /**
             * SetDoPinRequest value.
             * @member {number} value
             * @memberof lebai.io.SetDoPinRequest
             * @instance
             */
            SetDoPinRequest.prototype.value = 0;

            /**
             * Creates a new SetDoPinRequest instance using the specified properties.
             * @function create
             * @memberof lebai.io.SetDoPinRequest
             * @static
             * @param {lebai.io.ISetDoPinRequest=} [properties] Properties to set
             * @returns {lebai.io.SetDoPinRequest} SetDoPinRequest instance
             */
            SetDoPinRequest.create = function create(properties) {
                return new SetDoPinRequest(properties);
            };

            /**
             * Encodes the specified SetDoPinRequest message. Does not implicitly {@link lebai.io.SetDoPinRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.io.SetDoPinRequest
             * @static
             * @param {lebai.io.ISetDoPinRequest} message SetDoPinRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetDoPinRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.device != null && Object.hasOwnProperty.call(message, "device"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.device);
                if (message.pin != null && Object.hasOwnProperty.call(message, "pin"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.pin);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.value);
                return writer;
            };

            /**
             * Encodes the specified SetDoPinRequest message, length delimited. Does not implicitly {@link lebai.io.SetDoPinRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.io.SetDoPinRequest
             * @static
             * @param {lebai.io.ISetDoPinRequest} message SetDoPinRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetDoPinRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetDoPinRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.io.SetDoPinRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.io.SetDoPinRequest} SetDoPinRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetDoPinRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.io.SetDoPinRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.device = reader.int32();
                            break;
                        }
                    case 2: {
                            message.pin = reader.uint32();
                            break;
                        }
                    case 11: {
                            message.value = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetDoPinRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.io.SetDoPinRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.io.SetDoPinRequest} SetDoPinRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetDoPinRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetDoPinRequest message.
             * @function verify
             * @memberof lebai.io.SetDoPinRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetDoPinRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.device != null && message.hasOwnProperty("device"))
                    switch (message.device) {
                    default:
                        return "device: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 10:
                    case 11:
                    case 12:
                        break;
                    }
                if (message.pin != null && message.hasOwnProperty("pin"))
                    if (!$util.isInteger(message.pin))
                        return "pin: integer expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isInteger(message.value))
                        return "value: integer expected";
                return null;
            };

            /**
             * Creates a SetDoPinRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.io.SetDoPinRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.io.SetDoPinRequest} SetDoPinRequest
             */
            SetDoPinRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.io.SetDoPinRequest)
                    return object;
                var message = new $root.lebai.io.SetDoPinRequest();
                switch (object.device) {
                default:
                    if (typeof object.device === "number") {
                        message.device = object.device;
                        break;
                    }
                    break;
                case "ROBOT":
                case 0:
                    message.device = 0;
                    break;
                case "FLANGE":
                case 1:
                    message.device = 1;
                    break;
                case "EXTRA":
                case 2:
                    message.device = 2;
                    break;
                case "ROBOT_BTN":
                case 10:
                    message.device = 10;
                    break;
                case "SHOULDER":
                case 11:
                    message.device = 11;
                    break;
                case "FLANGE_BTN":
                case 12:
                    message.device = 12;
                    break;
                }
                if (object.pin != null)
                    message.pin = object.pin >>> 0;
                if (object.value != null)
                    message.value = object.value >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a SetDoPinRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.io.SetDoPinRequest
             * @static
             * @param {lebai.io.SetDoPinRequest} message SetDoPinRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetDoPinRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.device = options.enums === String ? "ROBOT" : 0;
                    object.pin = 0;
                    object.value = 0;
                }
                if (message.device != null && message.hasOwnProperty("device"))
                    object.device = options.enums === String ? $root.lebai.io.IoDevice[message.device] === undefined ? message.device : $root.lebai.io.IoDevice[message.device] : message.device;
                if (message.pin != null && message.hasOwnProperty("pin"))
                    object.pin = message.pin;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                return object;
            };

            /**
             * Converts this SetDoPinRequest to JSON.
             * @function toJSON
             * @memberof lebai.io.SetDoPinRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetDoPinRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetDoPinRequest
             * @function getTypeUrl
             * @memberof lebai.io.SetDoPinRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetDoPinRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.io.SetDoPinRequest";
            };

            return SetDoPinRequest;
        })();

        io.SetDoPinsRequest = (function() {

            /**
             * Properties of a SetDoPinsRequest.
             * @memberof lebai.io
             * @interface ISetDoPinsRequest
             * @property {lebai.io.IoDevice|null} [device] SetDoPinsRequest device
             * @property {number|null} [pin] SetDoPinsRequest pin
             * @property {Array.<number>|null} [values] SetDoPinsRequest values
             */

            /**
             * Constructs a new SetDoPinsRequest.
             * @memberof lebai.io
             * @classdesc Represents a SetDoPinsRequest.
             * @implements ISetDoPinsRequest
             * @constructor
             * @param {lebai.io.ISetDoPinsRequest=} [properties] Properties to set
             */
            function SetDoPinsRequest(properties) {
                this.values = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SetDoPinsRequest device.
             * @member {lebai.io.IoDevice} device
             * @memberof lebai.io.SetDoPinsRequest
             * @instance
             */
            SetDoPinsRequest.prototype.device = 0;

            /**
             * SetDoPinsRequest pin.
             * @member {number} pin
             * @memberof lebai.io.SetDoPinsRequest
             * @instance
             */
            SetDoPinsRequest.prototype.pin = 0;

            /**
             * SetDoPinsRequest values.
             * @member {Array.<number>} values
             * @memberof lebai.io.SetDoPinsRequest
             * @instance
             */
            SetDoPinsRequest.prototype.values = $util.emptyArray;

            /**
             * Creates a new SetDoPinsRequest instance using the specified properties.
             * @function create
             * @memberof lebai.io.SetDoPinsRequest
             * @static
             * @param {lebai.io.ISetDoPinsRequest=} [properties] Properties to set
             * @returns {lebai.io.SetDoPinsRequest} SetDoPinsRequest instance
             */
            SetDoPinsRequest.create = function create(properties) {
                return new SetDoPinsRequest(properties);
            };

            /**
             * Encodes the specified SetDoPinsRequest message. Does not implicitly {@link lebai.io.SetDoPinsRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.io.SetDoPinsRequest
             * @static
             * @param {lebai.io.ISetDoPinsRequest} message SetDoPinsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetDoPinsRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.device != null && Object.hasOwnProperty.call(message, "device"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.device);
                if (message.pin != null && Object.hasOwnProperty.call(message, "pin"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.pin);
                if (message.values != null && message.values.length) {
                    writer.uint32(/* id 11, wireType 2 =*/90).fork();
                    for (var i = 0; i < message.values.length; ++i)
                        writer.uint32(message.values[i]);
                    writer.ldelim();
                }
                return writer;
            };

            /**
             * Encodes the specified SetDoPinsRequest message, length delimited. Does not implicitly {@link lebai.io.SetDoPinsRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.io.SetDoPinsRequest
             * @static
             * @param {lebai.io.ISetDoPinsRequest} message SetDoPinsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetDoPinsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetDoPinsRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.io.SetDoPinsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.io.SetDoPinsRequest} SetDoPinsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetDoPinsRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.io.SetDoPinsRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.device = reader.int32();
                            break;
                        }
                    case 2: {
                            message.pin = reader.uint32();
                            break;
                        }
                    case 11: {
                            if (!(message.values && message.values.length))
                                message.values = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.values.push(reader.uint32());
                            } else
                                message.values.push(reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetDoPinsRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.io.SetDoPinsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.io.SetDoPinsRequest} SetDoPinsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetDoPinsRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetDoPinsRequest message.
             * @function verify
             * @memberof lebai.io.SetDoPinsRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetDoPinsRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.device != null && message.hasOwnProperty("device"))
                    switch (message.device) {
                    default:
                        return "device: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 10:
                    case 11:
                    case 12:
                        break;
                    }
                if (message.pin != null && message.hasOwnProperty("pin"))
                    if (!$util.isInteger(message.pin))
                        return "pin: integer expected";
                if (message.values != null && message.hasOwnProperty("values")) {
                    if (!Array.isArray(message.values))
                        return "values: array expected";
                    for (var i = 0; i < message.values.length; ++i)
                        if (!$util.isInteger(message.values[i]))
                            return "values: integer[] expected";
                }
                return null;
            };

            /**
             * Creates a SetDoPinsRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.io.SetDoPinsRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.io.SetDoPinsRequest} SetDoPinsRequest
             */
            SetDoPinsRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.io.SetDoPinsRequest)
                    return object;
                var message = new $root.lebai.io.SetDoPinsRequest();
                switch (object.device) {
                default:
                    if (typeof object.device === "number") {
                        message.device = object.device;
                        break;
                    }
                    break;
                case "ROBOT":
                case 0:
                    message.device = 0;
                    break;
                case "FLANGE":
                case 1:
                    message.device = 1;
                    break;
                case "EXTRA":
                case 2:
                    message.device = 2;
                    break;
                case "ROBOT_BTN":
                case 10:
                    message.device = 10;
                    break;
                case "SHOULDER":
                case 11:
                    message.device = 11;
                    break;
                case "FLANGE_BTN":
                case 12:
                    message.device = 12;
                    break;
                }
                if (object.pin != null)
                    message.pin = object.pin >>> 0;
                if (object.values) {
                    if (!Array.isArray(object.values))
                        throw TypeError(".lebai.io.SetDoPinsRequest.values: array expected");
                    message.values = [];
                    for (var i = 0; i < object.values.length; ++i)
                        message.values[i] = object.values[i] >>> 0;
                }
                return message;
            };

            /**
             * Creates a plain object from a SetDoPinsRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.io.SetDoPinsRequest
             * @static
             * @param {lebai.io.SetDoPinsRequest} message SetDoPinsRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetDoPinsRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.values = [];
                if (options.defaults) {
                    object.device = options.enums === String ? "ROBOT" : 0;
                    object.pin = 0;
                }
                if (message.device != null && message.hasOwnProperty("device"))
                    object.device = options.enums === String ? $root.lebai.io.IoDevice[message.device] === undefined ? message.device : $root.lebai.io.IoDevice[message.device] : message.device;
                if (message.pin != null && message.hasOwnProperty("pin"))
                    object.pin = message.pin;
                if (message.values && message.values.length) {
                    object.values = [];
                    for (var j = 0; j < message.values.length; ++j)
                        object.values[j] = message.values[j];
                }
                return object;
            };

            /**
             * Converts this SetDoPinsRequest to JSON.
             * @function toJSON
             * @memberof lebai.io.SetDoPinsRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetDoPinsRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetDoPinsRequest
             * @function getTypeUrl
             * @memberof lebai.io.SetDoPinsRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetDoPinsRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.io.SetDoPinsRequest";
            };

            return SetDoPinsRequest;
        })();

        io.GetDioPinRequest = (function() {

            /**
             * Properties of a GetDioPinRequest.
             * @memberof lebai.io
             * @interface IGetDioPinRequest
             * @property {lebai.io.IoDevice|null} [device] GetDioPinRequest device
             * @property {number|null} [pin] GetDioPinRequest pin
             */

            /**
             * Constructs a new GetDioPinRequest.
             * @memberof lebai.io
             * @classdesc Represents a GetDioPinRequest.
             * @implements IGetDioPinRequest
             * @constructor
             * @param {lebai.io.IGetDioPinRequest=} [properties] Properties to set
             */
            function GetDioPinRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetDioPinRequest device.
             * @member {lebai.io.IoDevice} device
             * @memberof lebai.io.GetDioPinRequest
             * @instance
             */
            GetDioPinRequest.prototype.device = 0;

            /**
             * GetDioPinRequest pin.
             * @member {number} pin
             * @memberof lebai.io.GetDioPinRequest
             * @instance
             */
            GetDioPinRequest.prototype.pin = 0;

            /**
             * Creates a new GetDioPinRequest instance using the specified properties.
             * @function create
             * @memberof lebai.io.GetDioPinRequest
             * @static
             * @param {lebai.io.IGetDioPinRequest=} [properties] Properties to set
             * @returns {lebai.io.GetDioPinRequest} GetDioPinRequest instance
             */
            GetDioPinRequest.create = function create(properties) {
                return new GetDioPinRequest(properties);
            };

            /**
             * Encodes the specified GetDioPinRequest message. Does not implicitly {@link lebai.io.GetDioPinRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.io.GetDioPinRequest
             * @static
             * @param {lebai.io.IGetDioPinRequest} message GetDioPinRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetDioPinRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.device != null && Object.hasOwnProperty.call(message, "device"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.device);
                if (message.pin != null && Object.hasOwnProperty.call(message, "pin"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.pin);
                return writer;
            };

            /**
             * Encodes the specified GetDioPinRequest message, length delimited. Does not implicitly {@link lebai.io.GetDioPinRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.io.GetDioPinRequest
             * @static
             * @param {lebai.io.IGetDioPinRequest} message GetDioPinRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetDioPinRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetDioPinRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.io.GetDioPinRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.io.GetDioPinRequest} GetDioPinRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetDioPinRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.io.GetDioPinRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.device = reader.int32();
                            break;
                        }
                    case 2: {
                            message.pin = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetDioPinRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.io.GetDioPinRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.io.GetDioPinRequest} GetDioPinRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetDioPinRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetDioPinRequest message.
             * @function verify
             * @memberof lebai.io.GetDioPinRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetDioPinRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.device != null && message.hasOwnProperty("device"))
                    switch (message.device) {
                    default:
                        return "device: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 10:
                    case 11:
                    case 12:
                        break;
                    }
                if (message.pin != null && message.hasOwnProperty("pin"))
                    if (!$util.isInteger(message.pin))
                        return "pin: integer expected";
                return null;
            };

            /**
             * Creates a GetDioPinRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.io.GetDioPinRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.io.GetDioPinRequest} GetDioPinRequest
             */
            GetDioPinRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.io.GetDioPinRequest)
                    return object;
                var message = new $root.lebai.io.GetDioPinRequest();
                switch (object.device) {
                default:
                    if (typeof object.device === "number") {
                        message.device = object.device;
                        break;
                    }
                    break;
                case "ROBOT":
                case 0:
                    message.device = 0;
                    break;
                case "FLANGE":
                case 1:
                    message.device = 1;
                    break;
                case "EXTRA":
                case 2:
                    message.device = 2;
                    break;
                case "ROBOT_BTN":
                case 10:
                    message.device = 10;
                    break;
                case "SHOULDER":
                case 11:
                    message.device = 11;
                    break;
                case "FLANGE_BTN":
                case 12:
                    message.device = 12;
                    break;
                }
                if (object.pin != null)
                    message.pin = object.pin >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a GetDioPinRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.io.GetDioPinRequest
             * @static
             * @param {lebai.io.GetDioPinRequest} message GetDioPinRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetDioPinRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.device = options.enums === String ? "ROBOT" : 0;
                    object.pin = 0;
                }
                if (message.device != null && message.hasOwnProperty("device"))
                    object.device = options.enums === String ? $root.lebai.io.IoDevice[message.device] === undefined ? message.device : $root.lebai.io.IoDevice[message.device] : message.device;
                if (message.pin != null && message.hasOwnProperty("pin"))
                    object.pin = message.pin;
                return object;
            };

            /**
             * Converts this GetDioPinRequest to JSON.
             * @function toJSON
             * @memberof lebai.io.GetDioPinRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetDioPinRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetDioPinRequest
             * @function getTypeUrl
             * @memberof lebai.io.GetDioPinRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetDioPinRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.io.GetDioPinRequest";
            };

            return GetDioPinRequest;
        })();

        io.GetDioPinResponse = (function() {

            /**
             * Properties of a GetDioPinResponse.
             * @memberof lebai.io
             * @interface IGetDioPinResponse
             * @property {number|null} [value] GetDioPinResponse value
             */

            /**
             * Constructs a new GetDioPinResponse.
             * @memberof lebai.io
             * @classdesc Represents a GetDioPinResponse.
             * @implements IGetDioPinResponse
             * @constructor
             * @param {lebai.io.IGetDioPinResponse=} [properties] Properties to set
             */
            function GetDioPinResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetDioPinResponse value.
             * @member {number} value
             * @memberof lebai.io.GetDioPinResponse
             * @instance
             */
            GetDioPinResponse.prototype.value = 0;

            /**
             * Creates a new GetDioPinResponse instance using the specified properties.
             * @function create
             * @memberof lebai.io.GetDioPinResponse
             * @static
             * @param {lebai.io.IGetDioPinResponse=} [properties] Properties to set
             * @returns {lebai.io.GetDioPinResponse} GetDioPinResponse instance
             */
            GetDioPinResponse.create = function create(properties) {
                return new GetDioPinResponse(properties);
            };

            /**
             * Encodes the specified GetDioPinResponse message. Does not implicitly {@link lebai.io.GetDioPinResponse.verify|verify} messages.
             * @function encode
             * @memberof lebai.io.GetDioPinResponse
             * @static
             * @param {lebai.io.IGetDioPinResponse} message GetDioPinResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetDioPinResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.value);
                return writer;
            };

            /**
             * Encodes the specified GetDioPinResponse message, length delimited. Does not implicitly {@link lebai.io.GetDioPinResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.io.GetDioPinResponse
             * @static
             * @param {lebai.io.IGetDioPinResponse} message GetDioPinResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetDioPinResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetDioPinResponse message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.io.GetDioPinResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.io.GetDioPinResponse} GetDioPinResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetDioPinResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.io.GetDioPinResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 11: {
                            message.value = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetDioPinResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.io.GetDioPinResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.io.GetDioPinResponse} GetDioPinResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetDioPinResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetDioPinResponse message.
             * @function verify
             * @memberof lebai.io.GetDioPinResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetDioPinResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isInteger(message.value))
                        return "value: integer expected";
                return null;
            };

            /**
             * Creates a GetDioPinResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.io.GetDioPinResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.io.GetDioPinResponse} GetDioPinResponse
             */
            GetDioPinResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.io.GetDioPinResponse)
                    return object;
                var message = new $root.lebai.io.GetDioPinResponse();
                if (object.value != null)
                    message.value = object.value >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a GetDioPinResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.io.GetDioPinResponse
             * @static
             * @param {lebai.io.GetDioPinResponse} message GetDioPinResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetDioPinResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.value = 0;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                return object;
            };

            /**
             * Converts this GetDioPinResponse to JSON.
             * @function toJSON
             * @memberof lebai.io.GetDioPinResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetDioPinResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetDioPinResponse
             * @function getTypeUrl
             * @memberof lebai.io.GetDioPinResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetDioPinResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.io.GetDioPinResponse";
            };

            return GetDioPinResponse;
        })();

        io.GetDioPinsRequest = (function() {

            /**
             * Properties of a GetDioPinsRequest.
             * @memberof lebai.io
             * @interface IGetDioPinsRequest
             * @property {lebai.io.IoDevice|null} [device] GetDioPinsRequest device
             * @property {number|null} [pin] GetDioPinsRequest pin
             * @property {number|null} [count] GetDioPinsRequest count
             */

            /**
             * Constructs a new GetDioPinsRequest.
             * @memberof lebai.io
             * @classdesc Represents a GetDioPinsRequest.
             * @implements IGetDioPinsRequest
             * @constructor
             * @param {lebai.io.IGetDioPinsRequest=} [properties] Properties to set
             */
            function GetDioPinsRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetDioPinsRequest device.
             * @member {lebai.io.IoDevice} device
             * @memberof lebai.io.GetDioPinsRequest
             * @instance
             */
            GetDioPinsRequest.prototype.device = 0;

            /**
             * GetDioPinsRequest pin.
             * @member {number} pin
             * @memberof lebai.io.GetDioPinsRequest
             * @instance
             */
            GetDioPinsRequest.prototype.pin = 0;

            /**
             * GetDioPinsRequest count.
             * @member {number} count
             * @memberof lebai.io.GetDioPinsRequest
             * @instance
             */
            GetDioPinsRequest.prototype.count = 0;

            /**
             * Creates a new GetDioPinsRequest instance using the specified properties.
             * @function create
             * @memberof lebai.io.GetDioPinsRequest
             * @static
             * @param {lebai.io.IGetDioPinsRequest=} [properties] Properties to set
             * @returns {lebai.io.GetDioPinsRequest} GetDioPinsRequest instance
             */
            GetDioPinsRequest.create = function create(properties) {
                return new GetDioPinsRequest(properties);
            };

            /**
             * Encodes the specified GetDioPinsRequest message. Does not implicitly {@link lebai.io.GetDioPinsRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.io.GetDioPinsRequest
             * @static
             * @param {lebai.io.IGetDioPinsRequest} message GetDioPinsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetDioPinsRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.device != null && Object.hasOwnProperty.call(message, "device"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.device);
                if (message.pin != null && Object.hasOwnProperty.call(message, "pin"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.pin);
                if (message.count != null && Object.hasOwnProperty.call(message, "count"))
                    writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.count);
                return writer;
            };

            /**
             * Encodes the specified GetDioPinsRequest message, length delimited. Does not implicitly {@link lebai.io.GetDioPinsRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.io.GetDioPinsRequest
             * @static
             * @param {lebai.io.IGetDioPinsRequest} message GetDioPinsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetDioPinsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetDioPinsRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.io.GetDioPinsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.io.GetDioPinsRequest} GetDioPinsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetDioPinsRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.io.GetDioPinsRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.device = reader.int32();
                            break;
                        }
                    case 2: {
                            message.pin = reader.uint32();
                            break;
                        }
                    case 11: {
                            message.count = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetDioPinsRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.io.GetDioPinsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.io.GetDioPinsRequest} GetDioPinsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetDioPinsRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetDioPinsRequest message.
             * @function verify
             * @memberof lebai.io.GetDioPinsRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetDioPinsRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.device != null && message.hasOwnProperty("device"))
                    switch (message.device) {
                    default:
                        return "device: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 10:
                    case 11:
                    case 12:
                        break;
                    }
                if (message.pin != null && message.hasOwnProperty("pin"))
                    if (!$util.isInteger(message.pin))
                        return "pin: integer expected";
                if (message.count != null && message.hasOwnProperty("count"))
                    if (!$util.isInteger(message.count))
                        return "count: integer expected";
                return null;
            };

            /**
             * Creates a GetDioPinsRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.io.GetDioPinsRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.io.GetDioPinsRequest} GetDioPinsRequest
             */
            GetDioPinsRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.io.GetDioPinsRequest)
                    return object;
                var message = new $root.lebai.io.GetDioPinsRequest();
                switch (object.device) {
                default:
                    if (typeof object.device === "number") {
                        message.device = object.device;
                        break;
                    }
                    break;
                case "ROBOT":
                case 0:
                    message.device = 0;
                    break;
                case "FLANGE":
                case 1:
                    message.device = 1;
                    break;
                case "EXTRA":
                case 2:
                    message.device = 2;
                    break;
                case "ROBOT_BTN":
                case 10:
                    message.device = 10;
                    break;
                case "SHOULDER":
                case 11:
                    message.device = 11;
                    break;
                case "FLANGE_BTN":
                case 12:
                    message.device = 12;
                    break;
                }
                if (object.pin != null)
                    message.pin = object.pin >>> 0;
                if (object.count != null)
                    message.count = object.count >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a GetDioPinsRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.io.GetDioPinsRequest
             * @static
             * @param {lebai.io.GetDioPinsRequest} message GetDioPinsRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetDioPinsRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.device = options.enums === String ? "ROBOT" : 0;
                    object.pin = 0;
                    object.count = 0;
                }
                if (message.device != null && message.hasOwnProperty("device"))
                    object.device = options.enums === String ? $root.lebai.io.IoDevice[message.device] === undefined ? message.device : $root.lebai.io.IoDevice[message.device] : message.device;
                if (message.pin != null && message.hasOwnProperty("pin"))
                    object.pin = message.pin;
                if (message.count != null && message.hasOwnProperty("count"))
                    object.count = message.count;
                return object;
            };

            /**
             * Converts this GetDioPinsRequest to JSON.
             * @function toJSON
             * @memberof lebai.io.GetDioPinsRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetDioPinsRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetDioPinsRequest
             * @function getTypeUrl
             * @memberof lebai.io.GetDioPinsRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetDioPinsRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.io.GetDioPinsRequest";
            };

            return GetDioPinsRequest;
        })();

        io.GetDioPinsResponse = (function() {

            /**
             * Properties of a GetDioPinsResponse.
             * @memberof lebai.io
             * @interface IGetDioPinsResponse
             * @property {Array.<number>|null} [values] GetDioPinsResponse values
             */

            /**
             * Constructs a new GetDioPinsResponse.
             * @memberof lebai.io
             * @classdesc Represents a GetDioPinsResponse.
             * @implements IGetDioPinsResponse
             * @constructor
             * @param {lebai.io.IGetDioPinsResponse=} [properties] Properties to set
             */
            function GetDioPinsResponse(properties) {
                this.values = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetDioPinsResponse values.
             * @member {Array.<number>} values
             * @memberof lebai.io.GetDioPinsResponse
             * @instance
             */
            GetDioPinsResponse.prototype.values = $util.emptyArray;

            /**
             * Creates a new GetDioPinsResponse instance using the specified properties.
             * @function create
             * @memberof lebai.io.GetDioPinsResponse
             * @static
             * @param {lebai.io.IGetDioPinsResponse=} [properties] Properties to set
             * @returns {lebai.io.GetDioPinsResponse} GetDioPinsResponse instance
             */
            GetDioPinsResponse.create = function create(properties) {
                return new GetDioPinsResponse(properties);
            };

            /**
             * Encodes the specified GetDioPinsResponse message. Does not implicitly {@link lebai.io.GetDioPinsResponse.verify|verify} messages.
             * @function encode
             * @memberof lebai.io.GetDioPinsResponse
             * @static
             * @param {lebai.io.IGetDioPinsResponse} message GetDioPinsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetDioPinsResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.values != null && message.values.length) {
                    writer.uint32(/* id 11, wireType 2 =*/90).fork();
                    for (var i = 0; i < message.values.length; ++i)
                        writer.uint32(message.values[i]);
                    writer.ldelim();
                }
                return writer;
            };

            /**
             * Encodes the specified GetDioPinsResponse message, length delimited. Does not implicitly {@link lebai.io.GetDioPinsResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.io.GetDioPinsResponse
             * @static
             * @param {lebai.io.IGetDioPinsResponse} message GetDioPinsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetDioPinsResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetDioPinsResponse message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.io.GetDioPinsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.io.GetDioPinsResponse} GetDioPinsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetDioPinsResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.io.GetDioPinsResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 11: {
                            if (!(message.values && message.values.length))
                                message.values = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.values.push(reader.uint32());
                            } else
                                message.values.push(reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetDioPinsResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.io.GetDioPinsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.io.GetDioPinsResponse} GetDioPinsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetDioPinsResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetDioPinsResponse message.
             * @function verify
             * @memberof lebai.io.GetDioPinsResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetDioPinsResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.values != null && message.hasOwnProperty("values")) {
                    if (!Array.isArray(message.values))
                        return "values: array expected";
                    for (var i = 0; i < message.values.length; ++i)
                        if (!$util.isInteger(message.values[i]))
                            return "values: integer[] expected";
                }
                return null;
            };

            /**
             * Creates a GetDioPinsResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.io.GetDioPinsResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.io.GetDioPinsResponse} GetDioPinsResponse
             */
            GetDioPinsResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.io.GetDioPinsResponse)
                    return object;
                var message = new $root.lebai.io.GetDioPinsResponse();
                if (object.values) {
                    if (!Array.isArray(object.values))
                        throw TypeError(".lebai.io.GetDioPinsResponse.values: array expected");
                    message.values = [];
                    for (var i = 0; i < object.values.length; ++i)
                        message.values[i] = object.values[i] >>> 0;
                }
                return message;
            };

            /**
             * Creates a plain object from a GetDioPinsResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.io.GetDioPinsResponse
             * @static
             * @param {lebai.io.GetDioPinsResponse} message GetDioPinsResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetDioPinsResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.values = [];
                if (message.values && message.values.length) {
                    object.values = [];
                    for (var j = 0; j < message.values.length; ++j)
                        object.values[j] = message.values[j];
                }
                return object;
            };

            /**
             * Converts this GetDioPinsResponse to JSON.
             * @function toJSON
             * @memberof lebai.io.GetDioPinsResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetDioPinsResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetDioPinsResponse
             * @function getTypeUrl
             * @memberof lebai.io.GetDioPinsResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetDioPinsResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.io.GetDioPinsResponse";
            };

            return GetDioPinsResponse;
        })();

        io.SetAoPinRequest = (function() {

            /**
             * Properties of a SetAoPinRequest.
             * @memberof lebai.io
             * @interface ISetAoPinRequest
             * @property {lebai.io.IoDevice|null} [device] SetAoPinRequest device
             * @property {number|null} [pin] SetAoPinRequest pin
             * @property {number|null} [value] SetAoPinRequest value
             */

            /**
             * Constructs a new SetAoPinRequest.
             * @memberof lebai.io
             * @classdesc Represents a SetAoPinRequest.
             * @implements ISetAoPinRequest
             * @constructor
             * @param {lebai.io.ISetAoPinRequest=} [properties] Properties to set
             */
            function SetAoPinRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SetAoPinRequest device.
             * @member {lebai.io.IoDevice} device
             * @memberof lebai.io.SetAoPinRequest
             * @instance
             */
            SetAoPinRequest.prototype.device = 0;

            /**
             * SetAoPinRequest pin.
             * @member {number} pin
             * @memberof lebai.io.SetAoPinRequest
             * @instance
             */
            SetAoPinRequest.prototype.pin = 0;

            /**
             * SetAoPinRequest value.
             * @member {number} value
             * @memberof lebai.io.SetAoPinRequest
             * @instance
             */
            SetAoPinRequest.prototype.value = 0;

            /**
             * Creates a new SetAoPinRequest instance using the specified properties.
             * @function create
             * @memberof lebai.io.SetAoPinRequest
             * @static
             * @param {lebai.io.ISetAoPinRequest=} [properties] Properties to set
             * @returns {lebai.io.SetAoPinRequest} SetAoPinRequest instance
             */
            SetAoPinRequest.create = function create(properties) {
                return new SetAoPinRequest(properties);
            };

            /**
             * Encodes the specified SetAoPinRequest message. Does not implicitly {@link lebai.io.SetAoPinRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.io.SetAoPinRequest
             * @static
             * @param {lebai.io.ISetAoPinRequest} message SetAoPinRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetAoPinRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.device != null && Object.hasOwnProperty.call(message, "device"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.device);
                if (message.pin != null && Object.hasOwnProperty.call(message, "pin"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.pin);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 11, wireType 1 =*/89).double(message.value);
                return writer;
            };

            /**
             * Encodes the specified SetAoPinRequest message, length delimited. Does not implicitly {@link lebai.io.SetAoPinRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.io.SetAoPinRequest
             * @static
             * @param {lebai.io.ISetAoPinRequest} message SetAoPinRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetAoPinRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetAoPinRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.io.SetAoPinRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.io.SetAoPinRequest} SetAoPinRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetAoPinRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.io.SetAoPinRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.device = reader.int32();
                            break;
                        }
                    case 2: {
                            message.pin = reader.uint32();
                            break;
                        }
                    case 11: {
                            message.value = reader.double();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetAoPinRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.io.SetAoPinRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.io.SetAoPinRequest} SetAoPinRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetAoPinRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetAoPinRequest message.
             * @function verify
             * @memberof lebai.io.SetAoPinRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetAoPinRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.device != null && message.hasOwnProperty("device"))
                    switch (message.device) {
                    default:
                        return "device: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 10:
                    case 11:
                    case 12:
                        break;
                    }
                if (message.pin != null && message.hasOwnProperty("pin"))
                    if (!$util.isInteger(message.pin))
                        return "pin: integer expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (typeof message.value !== "number")
                        return "value: number expected";
                return null;
            };

            /**
             * Creates a SetAoPinRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.io.SetAoPinRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.io.SetAoPinRequest} SetAoPinRequest
             */
            SetAoPinRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.io.SetAoPinRequest)
                    return object;
                var message = new $root.lebai.io.SetAoPinRequest();
                switch (object.device) {
                default:
                    if (typeof object.device === "number") {
                        message.device = object.device;
                        break;
                    }
                    break;
                case "ROBOT":
                case 0:
                    message.device = 0;
                    break;
                case "FLANGE":
                case 1:
                    message.device = 1;
                    break;
                case "EXTRA":
                case 2:
                    message.device = 2;
                    break;
                case "ROBOT_BTN":
                case 10:
                    message.device = 10;
                    break;
                case "SHOULDER":
                case 11:
                    message.device = 11;
                    break;
                case "FLANGE_BTN":
                case 12:
                    message.device = 12;
                    break;
                }
                if (object.pin != null)
                    message.pin = object.pin >>> 0;
                if (object.value != null)
                    message.value = Number(object.value);
                return message;
            };

            /**
             * Creates a plain object from a SetAoPinRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.io.SetAoPinRequest
             * @static
             * @param {lebai.io.SetAoPinRequest} message SetAoPinRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetAoPinRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.device = options.enums === String ? "ROBOT" : 0;
                    object.pin = 0;
                    object.value = 0;
                }
                if (message.device != null && message.hasOwnProperty("device"))
                    object.device = options.enums === String ? $root.lebai.io.IoDevice[message.device] === undefined ? message.device : $root.lebai.io.IoDevice[message.device] : message.device;
                if (message.pin != null && message.hasOwnProperty("pin"))
                    object.pin = message.pin;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
                return object;
            };

            /**
             * Converts this SetAoPinRequest to JSON.
             * @function toJSON
             * @memberof lebai.io.SetAoPinRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetAoPinRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetAoPinRequest
             * @function getTypeUrl
             * @memberof lebai.io.SetAoPinRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetAoPinRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.io.SetAoPinRequest";
            };

            return SetAoPinRequest;
        })();

        io.SetAoPinsRequest = (function() {

            /**
             * Properties of a SetAoPinsRequest.
             * @memberof lebai.io
             * @interface ISetAoPinsRequest
             * @property {lebai.io.IoDevice|null} [device] SetAoPinsRequest device
             * @property {number|null} [pin] SetAoPinsRequest pin
             * @property {Array.<number>|null} [values] SetAoPinsRequest values
             */

            /**
             * Constructs a new SetAoPinsRequest.
             * @memberof lebai.io
             * @classdesc Represents a SetAoPinsRequest.
             * @implements ISetAoPinsRequest
             * @constructor
             * @param {lebai.io.ISetAoPinsRequest=} [properties] Properties to set
             */
            function SetAoPinsRequest(properties) {
                this.values = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SetAoPinsRequest device.
             * @member {lebai.io.IoDevice} device
             * @memberof lebai.io.SetAoPinsRequest
             * @instance
             */
            SetAoPinsRequest.prototype.device = 0;

            /**
             * SetAoPinsRequest pin.
             * @member {number} pin
             * @memberof lebai.io.SetAoPinsRequest
             * @instance
             */
            SetAoPinsRequest.prototype.pin = 0;

            /**
             * SetAoPinsRequest values.
             * @member {Array.<number>} values
             * @memberof lebai.io.SetAoPinsRequest
             * @instance
             */
            SetAoPinsRequest.prototype.values = $util.emptyArray;

            /**
             * Creates a new SetAoPinsRequest instance using the specified properties.
             * @function create
             * @memberof lebai.io.SetAoPinsRequest
             * @static
             * @param {lebai.io.ISetAoPinsRequest=} [properties] Properties to set
             * @returns {lebai.io.SetAoPinsRequest} SetAoPinsRequest instance
             */
            SetAoPinsRequest.create = function create(properties) {
                return new SetAoPinsRequest(properties);
            };

            /**
             * Encodes the specified SetAoPinsRequest message. Does not implicitly {@link lebai.io.SetAoPinsRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.io.SetAoPinsRequest
             * @static
             * @param {lebai.io.ISetAoPinsRequest} message SetAoPinsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetAoPinsRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.device != null && Object.hasOwnProperty.call(message, "device"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.device);
                if (message.pin != null && Object.hasOwnProperty.call(message, "pin"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.pin);
                if (message.values != null && message.values.length) {
                    writer.uint32(/* id 11, wireType 2 =*/90).fork();
                    for (var i = 0; i < message.values.length; ++i)
                        writer.double(message.values[i]);
                    writer.ldelim();
                }
                return writer;
            };

            /**
             * Encodes the specified SetAoPinsRequest message, length delimited. Does not implicitly {@link lebai.io.SetAoPinsRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.io.SetAoPinsRequest
             * @static
             * @param {lebai.io.ISetAoPinsRequest} message SetAoPinsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetAoPinsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetAoPinsRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.io.SetAoPinsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.io.SetAoPinsRequest} SetAoPinsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetAoPinsRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.io.SetAoPinsRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.device = reader.int32();
                            break;
                        }
                    case 2: {
                            message.pin = reader.uint32();
                            break;
                        }
                    case 11: {
                            if (!(message.values && message.values.length))
                                message.values = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.values.push(reader.double());
                            } else
                                message.values.push(reader.double());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetAoPinsRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.io.SetAoPinsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.io.SetAoPinsRequest} SetAoPinsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetAoPinsRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetAoPinsRequest message.
             * @function verify
             * @memberof lebai.io.SetAoPinsRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetAoPinsRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.device != null && message.hasOwnProperty("device"))
                    switch (message.device) {
                    default:
                        return "device: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 10:
                    case 11:
                    case 12:
                        break;
                    }
                if (message.pin != null && message.hasOwnProperty("pin"))
                    if (!$util.isInteger(message.pin))
                        return "pin: integer expected";
                if (message.values != null && message.hasOwnProperty("values")) {
                    if (!Array.isArray(message.values))
                        return "values: array expected";
                    for (var i = 0; i < message.values.length; ++i)
                        if (typeof message.values[i] !== "number")
                            return "values: number[] expected";
                }
                return null;
            };

            /**
             * Creates a SetAoPinsRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.io.SetAoPinsRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.io.SetAoPinsRequest} SetAoPinsRequest
             */
            SetAoPinsRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.io.SetAoPinsRequest)
                    return object;
                var message = new $root.lebai.io.SetAoPinsRequest();
                switch (object.device) {
                default:
                    if (typeof object.device === "number") {
                        message.device = object.device;
                        break;
                    }
                    break;
                case "ROBOT":
                case 0:
                    message.device = 0;
                    break;
                case "FLANGE":
                case 1:
                    message.device = 1;
                    break;
                case "EXTRA":
                case 2:
                    message.device = 2;
                    break;
                case "ROBOT_BTN":
                case 10:
                    message.device = 10;
                    break;
                case "SHOULDER":
                case 11:
                    message.device = 11;
                    break;
                case "FLANGE_BTN":
                case 12:
                    message.device = 12;
                    break;
                }
                if (object.pin != null)
                    message.pin = object.pin >>> 0;
                if (object.values) {
                    if (!Array.isArray(object.values))
                        throw TypeError(".lebai.io.SetAoPinsRequest.values: array expected");
                    message.values = [];
                    for (var i = 0; i < object.values.length; ++i)
                        message.values[i] = Number(object.values[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a SetAoPinsRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.io.SetAoPinsRequest
             * @static
             * @param {lebai.io.SetAoPinsRequest} message SetAoPinsRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetAoPinsRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.values = [];
                if (options.defaults) {
                    object.device = options.enums === String ? "ROBOT" : 0;
                    object.pin = 0;
                }
                if (message.device != null && message.hasOwnProperty("device"))
                    object.device = options.enums === String ? $root.lebai.io.IoDevice[message.device] === undefined ? message.device : $root.lebai.io.IoDevice[message.device] : message.device;
                if (message.pin != null && message.hasOwnProperty("pin"))
                    object.pin = message.pin;
                if (message.values && message.values.length) {
                    object.values = [];
                    for (var j = 0; j < message.values.length; ++j)
                        object.values[j] = options.json && !isFinite(message.values[j]) ? String(message.values[j]) : message.values[j];
                }
                return object;
            };

            /**
             * Converts this SetAoPinsRequest to JSON.
             * @function toJSON
             * @memberof lebai.io.SetAoPinsRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetAoPinsRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetAoPinsRequest
             * @function getTypeUrl
             * @memberof lebai.io.SetAoPinsRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetAoPinsRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.io.SetAoPinsRequest";
            };

            return SetAoPinsRequest;
        })();

        io.GetAioPinRequest = (function() {

            /**
             * Properties of a GetAioPinRequest.
             * @memberof lebai.io
             * @interface IGetAioPinRequest
             * @property {lebai.io.IoDevice|null} [device] GetAioPinRequest device
             * @property {number|null} [pin] GetAioPinRequest pin
             */

            /**
             * Constructs a new GetAioPinRequest.
             * @memberof lebai.io
             * @classdesc Represents a GetAioPinRequest.
             * @implements IGetAioPinRequest
             * @constructor
             * @param {lebai.io.IGetAioPinRequest=} [properties] Properties to set
             */
            function GetAioPinRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetAioPinRequest device.
             * @member {lebai.io.IoDevice} device
             * @memberof lebai.io.GetAioPinRequest
             * @instance
             */
            GetAioPinRequest.prototype.device = 0;

            /**
             * GetAioPinRequest pin.
             * @member {number} pin
             * @memberof lebai.io.GetAioPinRequest
             * @instance
             */
            GetAioPinRequest.prototype.pin = 0;

            /**
             * Creates a new GetAioPinRequest instance using the specified properties.
             * @function create
             * @memberof lebai.io.GetAioPinRequest
             * @static
             * @param {lebai.io.IGetAioPinRequest=} [properties] Properties to set
             * @returns {lebai.io.GetAioPinRequest} GetAioPinRequest instance
             */
            GetAioPinRequest.create = function create(properties) {
                return new GetAioPinRequest(properties);
            };

            /**
             * Encodes the specified GetAioPinRequest message. Does not implicitly {@link lebai.io.GetAioPinRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.io.GetAioPinRequest
             * @static
             * @param {lebai.io.IGetAioPinRequest} message GetAioPinRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetAioPinRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.device != null && Object.hasOwnProperty.call(message, "device"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.device);
                if (message.pin != null && Object.hasOwnProperty.call(message, "pin"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.pin);
                return writer;
            };

            /**
             * Encodes the specified GetAioPinRequest message, length delimited. Does not implicitly {@link lebai.io.GetAioPinRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.io.GetAioPinRequest
             * @static
             * @param {lebai.io.IGetAioPinRequest} message GetAioPinRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetAioPinRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetAioPinRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.io.GetAioPinRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.io.GetAioPinRequest} GetAioPinRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetAioPinRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.io.GetAioPinRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.device = reader.int32();
                            break;
                        }
                    case 2: {
                            message.pin = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetAioPinRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.io.GetAioPinRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.io.GetAioPinRequest} GetAioPinRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetAioPinRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetAioPinRequest message.
             * @function verify
             * @memberof lebai.io.GetAioPinRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetAioPinRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.device != null && message.hasOwnProperty("device"))
                    switch (message.device) {
                    default:
                        return "device: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 10:
                    case 11:
                    case 12:
                        break;
                    }
                if (message.pin != null && message.hasOwnProperty("pin"))
                    if (!$util.isInteger(message.pin))
                        return "pin: integer expected";
                return null;
            };

            /**
             * Creates a GetAioPinRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.io.GetAioPinRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.io.GetAioPinRequest} GetAioPinRequest
             */
            GetAioPinRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.io.GetAioPinRequest)
                    return object;
                var message = new $root.lebai.io.GetAioPinRequest();
                switch (object.device) {
                default:
                    if (typeof object.device === "number") {
                        message.device = object.device;
                        break;
                    }
                    break;
                case "ROBOT":
                case 0:
                    message.device = 0;
                    break;
                case "FLANGE":
                case 1:
                    message.device = 1;
                    break;
                case "EXTRA":
                case 2:
                    message.device = 2;
                    break;
                case "ROBOT_BTN":
                case 10:
                    message.device = 10;
                    break;
                case "SHOULDER":
                case 11:
                    message.device = 11;
                    break;
                case "FLANGE_BTN":
                case 12:
                    message.device = 12;
                    break;
                }
                if (object.pin != null)
                    message.pin = object.pin >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a GetAioPinRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.io.GetAioPinRequest
             * @static
             * @param {lebai.io.GetAioPinRequest} message GetAioPinRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetAioPinRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.device = options.enums === String ? "ROBOT" : 0;
                    object.pin = 0;
                }
                if (message.device != null && message.hasOwnProperty("device"))
                    object.device = options.enums === String ? $root.lebai.io.IoDevice[message.device] === undefined ? message.device : $root.lebai.io.IoDevice[message.device] : message.device;
                if (message.pin != null && message.hasOwnProperty("pin"))
                    object.pin = message.pin;
                return object;
            };

            /**
             * Converts this GetAioPinRequest to JSON.
             * @function toJSON
             * @memberof lebai.io.GetAioPinRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetAioPinRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetAioPinRequest
             * @function getTypeUrl
             * @memberof lebai.io.GetAioPinRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetAioPinRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.io.GetAioPinRequest";
            };

            return GetAioPinRequest;
        })();

        io.GetAioPinResponse = (function() {

            /**
             * Properties of a GetAioPinResponse.
             * @memberof lebai.io
             * @interface IGetAioPinResponse
             * @property {number|null} [value] GetAioPinResponse value
             */

            /**
             * Constructs a new GetAioPinResponse.
             * @memberof lebai.io
             * @classdesc Represents a GetAioPinResponse.
             * @implements IGetAioPinResponse
             * @constructor
             * @param {lebai.io.IGetAioPinResponse=} [properties] Properties to set
             */
            function GetAioPinResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetAioPinResponse value.
             * @member {number} value
             * @memberof lebai.io.GetAioPinResponse
             * @instance
             */
            GetAioPinResponse.prototype.value = 0;

            /**
             * Creates a new GetAioPinResponse instance using the specified properties.
             * @function create
             * @memberof lebai.io.GetAioPinResponse
             * @static
             * @param {lebai.io.IGetAioPinResponse=} [properties] Properties to set
             * @returns {lebai.io.GetAioPinResponse} GetAioPinResponse instance
             */
            GetAioPinResponse.create = function create(properties) {
                return new GetAioPinResponse(properties);
            };

            /**
             * Encodes the specified GetAioPinResponse message. Does not implicitly {@link lebai.io.GetAioPinResponse.verify|verify} messages.
             * @function encode
             * @memberof lebai.io.GetAioPinResponse
             * @static
             * @param {lebai.io.IGetAioPinResponse} message GetAioPinResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetAioPinResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 11, wireType 1 =*/89).double(message.value);
                return writer;
            };

            /**
             * Encodes the specified GetAioPinResponse message, length delimited. Does not implicitly {@link lebai.io.GetAioPinResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.io.GetAioPinResponse
             * @static
             * @param {lebai.io.IGetAioPinResponse} message GetAioPinResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetAioPinResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetAioPinResponse message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.io.GetAioPinResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.io.GetAioPinResponse} GetAioPinResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetAioPinResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.io.GetAioPinResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 11: {
                            message.value = reader.double();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetAioPinResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.io.GetAioPinResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.io.GetAioPinResponse} GetAioPinResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetAioPinResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetAioPinResponse message.
             * @function verify
             * @memberof lebai.io.GetAioPinResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetAioPinResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (typeof message.value !== "number")
                        return "value: number expected";
                return null;
            };

            /**
             * Creates a GetAioPinResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.io.GetAioPinResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.io.GetAioPinResponse} GetAioPinResponse
             */
            GetAioPinResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.io.GetAioPinResponse)
                    return object;
                var message = new $root.lebai.io.GetAioPinResponse();
                if (object.value != null)
                    message.value = Number(object.value);
                return message;
            };

            /**
             * Creates a plain object from a GetAioPinResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.io.GetAioPinResponse
             * @static
             * @param {lebai.io.GetAioPinResponse} message GetAioPinResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetAioPinResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.value = 0;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
                return object;
            };

            /**
             * Converts this GetAioPinResponse to JSON.
             * @function toJSON
             * @memberof lebai.io.GetAioPinResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetAioPinResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetAioPinResponse
             * @function getTypeUrl
             * @memberof lebai.io.GetAioPinResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetAioPinResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.io.GetAioPinResponse";
            };

            return GetAioPinResponse;
        })();

        io.GetAioPinsRequest = (function() {

            /**
             * Properties of a GetAioPinsRequest.
             * @memberof lebai.io
             * @interface IGetAioPinsRequest
             * @property {lebai.io.IoDevice|null} [device] GetAioPinsRequest device
             * @property {number|null} [pin] GetAioPinsRequest pin
             * @property {number|null} [count] GetAioPinsRequest count
             */

            /**
             * Constructs a new GetAioPinsRequest.
             * @memberof lebai.io
             * @classdesc Represents a GetAioPinsRequest.
             * @implements IGetAioPinsRequest
             * @constructor
             * @param {lebai.io.IGetAioPinsRequest=} [properties] Properties to set
             */
            function GetAioPinsRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetAioPinsRequest device.
             * @member {lebai.io.IoDevice} device
             * @memberof lebai.io.GetAioPinsRequest
             * @instance
             */
            GetAioPinsRequest.prototype.device = 0;

            /**
             * GetAioPinsRequest pin.
             * @member {number} pin
             * @memberof lebai.io.GetAioPinsRequest
             * @instance
             */
            GetAioPinsRequest.prototype.pin = 0;

            /**
             * GetAioPinsRequest count.
             * @member {number} count
             * @memberof lebai.io.GetAioPinsRequest
             * @instance
             */
            GetAioPinsRequest.prototype.count = 0;

            /**
             * Creates a new GetAioPinsRequest instance using the specified properties.
             * @function create
             * @memberof lebai.io.GetAioPinsRequest
             * @static
             * @param {lebai.io.IGetAioPinsRequest=} [properties] Properties to set
             * @returns {lebai.io.GetAioPinsRequest} GetAioPinsRequest instance
             */
            GetAioPinsRequest.create = function create(properties) {
                return new GetAioPinsRequest(properties);
            };

            /**
             * Encodes the specified GetAioPinsRequest message. Does not implicitly {@link lebai.io.GetAioPinsRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.io.GetAioPinsRequest
             * @static
             * @param {lebai.io.IGetAioPinsRequest} message GetAioPinsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetAioPinsRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.device != null && Object.hasOwnProperty.call(message, "device"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.device);
                if (message.pin != null && Object.hasOwnProperty.call(message, "pin"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.pin);
                if (message.count != null && Object.hasOwnProperty.call(message, "count"))
                    writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.count);
                return writer;
            };

            /**
             * Encodes the specified GetAioPinsRequest message, length delimited. Does not implicitly {@link lebai.io.GetAioPinsRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.io.GetAioPinsRequest
             * @static
             * @param {lebai.io.IGetAioPinsRequest} message GetAioPinsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetAioPinsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetAioPinsRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.io.GetAioPinsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.io.GetAioPinsRequest} GetAioPinsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetAioPinsRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.io.GetAioPinsRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.device = reader.int32();
                            break;
                        }
                    case 2: {
                            message.pin = reader.uint32();
                            break;
                        }
                    case 11: {
                            message.count = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetAioPinsRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.io.GetAioPinsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.io.GetAioPinsRequest} GetAioPinsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetAioPinsRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetAioPinsRequest message.
             * @function verify
             * @memberof lebai.io.GetAioPinsRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetAioPinsRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.device != null && message.hasOwnProperty("device"))
                    switch (message.device) {
                    default:
                        return "device: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 10:
                    case 11:
                    case 12:
                        break;
                    }
                if (message.pin != null && message.hasOwnProperty("pin"))
                    if (!$util.isInteger(message.pin))
                        return "pin: integer expected";
                if (message.count != null && message.hasOwnProperty("count"))
                    if (!$util.isInteger(message.count))
                        return "count: integer expected";
                return null;
            };

            /**
             * Creates a GetAioPinsRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.io.GetAioPinsRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.io.GetAioPinsRequest} GetAioPinsRequest
             */
            GetAioPinsRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.io.GetAioPinsRequest)
                    return object;
                var message = new $root.lebai.io.GetAioPinsRequest();
                switch (object.device) {
                default:
                    if (typeof object.device === "number") {
                        message.device = object.device;
                        break;
                    }
                    break;
                case "ROBOT":
                case 0:
                    message.device = 0;
                    break;
                case "FLANGE":
                case 1:
                    message.device = 1;
                    break;
                case "EXTRA":
                case 2:
                    message.device = 2;
                    break;
                case "ROBOT_BTN":
                case 10:
                    message.device = 10;
                    break;
                case "SHOULDER":
                case 11:
                    message.device = 11;
                    break;
                case "FLANGE_BTN":
                case 12:
                    message.device = 12;
                    break;
                }
                if (object.pin != null)
                    message.pin = object.pin >>> 0;
                if (object.count != null)
                    message.count = object.count >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a GetAioPinsRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.io.GetAioPinsRequest
             * @static
             * @param {lebai.io.GetAioPinsRequest} message GetAioPinsRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetAioPinsRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.device = options.enums === String ? "ROBOT" : 0;
                    object.pin = 0;
                    object.count = 0;
                }
                if (message.device != null && message.hasOwnProperty("device"))
                    object.device = options.enums === String ? $root.lebai.io.IoDevice[message.device] === undefined ? message.device : $root.lebai.io.IoDevice[message.device] : message.device;
                if (message.pin != null && message.hasOwnProperty("pin"))
                    object.pin = message.pin;
                if (message.count != null && message.hasOwnProperty("count"))
                    object.count = message.count;
                return object;
            };

            /**
             * Converts this GetAioPinsRequest to JSON.
             * @function toJSON
             * @memberof lebai.io.GetAioPinsRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetAioPinsRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetAioPinsRequest
             * @function getTypeUrl
             * @memberof lebai.io.GetAioPinsRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetAioPinsRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.io.GetAioPinsRequest";
            };

            return GetAioPinsRequest;
        })();

        io.GetAioPinsResponse = (function() {

            /**
             * Properties of a GetAioPinsResponse.
             * @memberof lebai.io
             * @interface IGetAioPinsResponse
             * @property {Array.<number>|null} [values] GetAioPinsResponse values
             */

            /**
             * Constructs a new GetAioPinsResponse.
             * @memberof lebai.io
             * @classdesc Represents a GetAioPinsResponse.
             * @implements IGetAioPinsResponse
             * @constructor
             * @param {lebai.io.IGetAioPinsResponse=} [properties] Properties to set
             */
            function GetAioPinsResponse(properties) {
                this.values = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetAioPinsResponse values.
             * @member {Array.<number>} values
             * @memberof lebai.io.GetAioPinsResponse
             * @instance
             */
            GetAioPinsResponse.prototype.values = $util.emptyArray;

            /**
             * Creates a new GetAioPinsResponse instance using the specified properties.
             * @function create
             * @memberof lebai.io.GetAioPinsResponse
             * @static
             * @param {lebai.io.IGetAioPinsResponse=} [properties] Properties to set
             * @returns {lebai.io.GetAioPinsResponse} GetAioPinsResponse instance
             */
            GetAioPinsResponse.create = function create(properties) {
                return new GetAioPinsResponse(properties);
            };

            /**
             * Encodes the specified GetAioPinsResponse message. Does not implicitly {@link lebai.io.GetAioPinsResponse.verify|verify} messages.
             * @function encode
             * @memberof lebai.io.GetAioPinsResponse
             * @static
             * @param {lebai.io.IGetAioPinsResponse} message GetAioPinsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetAioPinsResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.values != null && message.values.length) {
                    writer.uint32(/* id 11, wireType 2 =*/90).fork();
                    for (var i = 0; i < message.values.length; ++i)
                        writer.double(message.values[i]);
                    writer.ldelim();
                }
                return writer;
            };

            /**
             * Encodes the specified GetAioPinsResponse message, length delimited. Does not implicitly {@link lebai.io.GetAioPinsResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.io.GetAioPinsResponse
             * @static
             * @param {lebai.io.IGetAioPinsResponse} message GetAioPinsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetAioPinsResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetAioPinsResponse message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.io.GetAioPinsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.io.GetAioPinsResponse} GetAioPinsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetAioPinsResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.io.GetAioPinsResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 11: {
                            if (!(message.values && message.values.length))
                                message.values = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.values.push(reader.double());
                            } else
                                message.values.push(reader.double());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetAioPinsResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.io.GetAioPinsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.io.GetAioPinsResponse} GetAioPinsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetAioPinsResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetAioPinsResponse message.
             * @function verify
             * @memberof lebai.io.GetAioPinsResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetAioPinsResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.values != null && message.hasOwnProperty("values")) {
                    if (!Array.isArray(message.values))
                        return "values: array expected";
                    for (var i = 0; i < message.values.length; ++i)
                        if (typeof message.values[i] !== "number")
                            return "values: number[] expected";
                }
                return null;
            };

            /**
             * Creates a GetAioPinsResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.io.GetAioPinsResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.io.GetAioPinsResponse} GetAioPinsResponse
             */
            GetAioPinsResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.io.GetAioPinsResponse)
                    return object;
                var message = new $root.lebai.io.GetAioPinsResponse();
                if (object.values) {
                    if (!Array.isArray(object.values))
                        throw TypeError(".lebai.io.GetAioPinsResponse.values: array expected");
                    message.values = [];
                    for (var i = 0; i < object.values.length; ++i)
                        message.values[i] = Number(object.values[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a GetAioPinsResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.io.GetAioPinsResponse
             * @static
             * @param {lebai.io.GetAioPinsResponse} message GetAioPinsResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetAioPinsResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.values = [];
                if (message.values && message.values.length) {
                    object.values = [];
                    for (var j = 0; j < message.values.length; ++j)
                        object.values[j] = options.json && !isFinite(message.values[j]) ? String(message.values[j]) : message.values[j];
                }
                return object;
            };

            /**
             * Converts this GetAioPinsResponse to JSON.
             * @function toJSON
             * @memberof lebai.io.GetAioPinsResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetAioPinsResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetAioPinsResponse
             * @function getTypeUrl
             * @memberof lebai.io.GetAioPinsResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetAioPinsResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.io.GetAioPinsResponse";
            };

            return GetAioPinsResponse;
        })();

        io.ButtonIndex = (function() {

            /**
             * Properties of a ButtonIndex.
             * @memberof lebai.io
             * @interface IButtonIndex
             * @property {lebai.io.IoDevice|null} [device] ButtonIndex device
             * @property {number|null} [pin] ButtonIndex pin
             */

            /**
             * Constructs a new ButtonIndex.
             * @memberof lebai.io
             * @classdesc Represents a ButtonIndex.
             * @implements IButtonIndex
             * @constructor
             * @param {lebai.io.IButtonIndex=} [properties] Properties to set
             */
            function ButtonIndex(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ButtonIndex device.
             * @member {lebai.io.IoDevice} device
             * @memberof lebai.io.ButtonIndex
             * @instance
             */
            ButtonIndex.prototype.device = 0;

            /**
             * ButtonIndex pin.
             * @member {number} pin
             * @memberof lebai.io.ButtonIndex
             * @instance
             */
            ButtonIndex.prototype.pin = 0;

            /**
             * Creates a new ButtonIndex instance using the specified properties.
             * @function create
             * @memberof lebai.io.ButtonIndex
             * @static
             * @param {lebai.io.IButtonIndex=} [properties] Properties to set
             * @returns {lebai.io.ButtonIndex} ButtonIndex instance
             */
            ButtonIndex.create = function create(properties) {
                return new ButtonIndex(properties);
            };

            /**
             * Encodes the specified ButtonIndex message. Does not implicitly {@link lebai.io.ButtonIndex.verify|verify} messages.
             * @function encode
             * @memberof lebai.io.ButtonIndex
             * @static
             * @param {lebai.io.IButtonIndex} message ButtonIndex message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ButtonIndex.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.device != null && Object.hasOwnProperty.call(message, "device"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.device);
                if (message.pin != null && Object.hasOwnProperty.call(message, "pin"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.pin);
                return writer;
            };

            /**
             * Encodes the specified ButtonIndex message, length delimited. Does not implicitly {@link lebai.io.ButtonIndex.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.io.ButtonIndex
             * @static
             * @param {lebai.io.IButtonIndex} message ButtonIndex message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ButtonIndex.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ButtonIndex message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.io.ButtonIndex
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.io.ButtonIndex} ButtonIndex
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ButtonIndex.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.io.ButtonIndex();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.device = reader.int32();
                            break;
                        }
                    case 2: {
                            message.pin = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ButtonIndex message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.io.ButtonIndex
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.io.ButtonIndex} ButtonIndex
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ButtonIndex.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ButtonIndex message.
             * @function verify
             * @memberof lebai.io.ButtonIndex
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ButtonIndex.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.device != null && message.hasOwnProperty("device"))
                    switch (message.device) {
                    default:
                        return "device: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 10:
                    case 11:
                    case 12:
                        break;
                    }
                if (message.pin != null && message.hasOwnProperty("pin"))
                    if (!$util.isInteger(message.pin))
                        return "pin: integer expected";
                return null;
            };

            /**
             * Creates a ButtonIndex message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.io.ButtonIndex
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.io.ButtonIndex} ButtonIndex
             */
            ButtonIndex.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.io.ButtonIndex)
                    return object;
                var message = new $root.lebai.io.ButtonIndex();
                switch (object.device) {
                default:
                    if (typeof object.device === "number") {
                        message.device = object.device;
                        break;
                    }
                    break;
                case "ROBOT":
                case 0:
                    message.device = 0;
                    break;
                case "FLANGE":
                case 1:
                    message.device = 1;
                    break;
                case "EXTRA":
                case 2:
                    message.device = 2;
                    break;
                case "ROBOT_BTN":
                case 10:
                    message.device = 10;
                    break;
                case "SHOULDER":
                case 11:
                    message.device = 11;
                    break;
                case "FLANGE_BTN":
                case 12:
                    message.device = 12;
                    break;
                }
                if (object.pin != null)
                    message.pin = object.pin >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a ButtonIndex message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.io.ButtonIndex
             * @static
             * @param {lebai.io.ButtonIndex} message ButtonIndex
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ButtonIndex.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.device = options.enums === String ? "ROBOT" : 0;
                    object.pin = 0;
                }
                if (message.device != null && message.hasOwnProperty("device"))
                    object.device = options.enums === String ? $root.lebai.io.IoDevice[message.device] === undefined ? message.device : $root.lebai.io.IoDevice[message.device] : message.device;
                if (message.pin != null && message.hasOwnProperty("pin"))
                    object.pin = message.pin;
                return object;
            };

            /**
             * Converts this ButtonIndex to JSON.
             * @function toJSON
             * @memberof lebai.io.ButtonIndex
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ButtonIndex.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ButtonIndex
             * @function getTypeUrl
             * @memberof lebai.io.ButtonIndex
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ButtonIndex.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.io.ButtonIndex";
            };

            return ButtonIndex;
        })();

        /**
         * ButtonState enum.
         * @name lebai.io.ButtonState
         * @enum {number}
         * @property {number} EMPTY=0 EMPTY value
         * @property {number} UP=1 UP value
         * @property {number} LONG_DOWN=2 LONG_DOWN value
         * @property {number} CLICK=3 CLICK value
         */
        io.ButtonState = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "EMPTY"] = 0;
            values[valuesById[1] = "UP"] = 1;
            values[valuesById[2] = "LONG_DOWN"] = 2;
            values[valuesById[3] = "CLICK"] = 3;
            return values;
        })();

        io.ButtonStatus = (function() {

            /**
             * Properties of a ButtonStatus.
             * @memberof lebai.io
             * @interface IButtonStatus
             * @property {lebai.io.ButtonState|null} [state] ButtonStatus state
             * @property {number|null} [time] ButtonStatus time
             */

            /**
             * Constructs a new ButtonStatus.
             * @memberof lebai.io
             * @classdesc Represents a ButtonStatus.
             * @implements IButtonStatus
             * @constructor
             * @param {lebai.io.IButtonStatus=} [properties] Properties to set
             */
            function ButtonStatus(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ButtonStatus state.
             * @member {lebai.io.ButtonState} state
             * @memberof lebai.io.ButtonStatus
             * @instance
             */
            ButtonStatus.prototype.state = 0;

            /**
             * ButtonStatus time.
             * @member {number} time
             * @memberof lebai.io.ButtonStatus
             * @instance
             */
            ButtonStatus.prototype.time = 0;

            /**
             * Creates a new ButtonStatus instance using the specified properties.
             * @function create
             * @memberof lebai.io.ButtonStatus
             * @static
             * @param {lebai.io.IButtonStatus=} [properties] Properties to set
             * @returns {lebai.io.ButtonStatus} ButtonStatus instance
             */
            ButtonStatus.create = function create(properties) {
                return new ButtonStatus(properties);
            };

            /**
             * Encodes the specified ButtonStatus message. Does not implicitly {@link lebai.io.ButtonStatus.verify|verify} messages.
             * @function encode
             * @memberof lebai.io.ButtonStatus
             * @static
             * @param {lebai.io.IButtonStatus} message ButtonStatus message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ButtonStatus.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.state != null && Object.hasOwnProperty.call(message, "state"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.state);
                if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.time);
                return writer;
            };

            /**
             * Encodes the specified ButtonStatus message, length delimited. Does not implicitly {@link lebai.io.ButtonStatus.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.io.ButtonStatus
             * @static
             * @param {lebai.io.IButtonStatus} message ButtonStatus message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ButtonStatus.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ButtonStatus message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.io.ButtonStatus
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.io.ButtonStatus} ButtonStatus
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ButtonStatus.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.io.ButtonStatus();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.state = reader.int32();
                            break;
                        }
                    case 2: {
                            message.time = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ButtonStatus message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.io.ButtonStatus
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.io.ButtonStatus} ButtonStatus
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ButtonStatus.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ButtonStatus message.
             * @function verify
             * @memberof lebai.io.ButtonStatus
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ButtonStatus.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.state != null && message.hasOwnProperty("state"))
                    switch (message.state) {
                    default:
                        return "state: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.time != null && message.hasOwnProperty("time"))
                    if (!$util.isInteger(message.time))
                        return "time: integer expected";
                return null;
            };

            /**
             * Creates a ButtonStatus message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.io.ButtonStatus
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.io.ButtonStatus} ButtonStatus
             */
            ButtonStatus.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.io.ButtonStatus)
                    return object;
                var message = new $root.lebai.io.ButtonStatus();
                switch (object.state) {
                default:
                    if (typeof object.state === "number") {
                        message.state = object.state;
                        break;
                    }
                    break;
                case "EMPTY":
                case 0:
                    message.state = 0;
                    break;
                case "UP":
                case 1:
                    message.state = 1;
                    break;
                case "LONG_DOWN":
                case 2:
                    message.state = 2;
                    break;
                case "CLICK":
                case 3:
                    message.state = 3;
                    break;
                }
                if (object.time != null)
                    message.time = object.time >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a ButtonStatus message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.io.ButtonStatus
             * @static
             * @param {lebai.io.ButtonStatus} message ButtonStatus
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ButtonStatus.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.state = options.enums === String ? "EMPTY" : 0;
                    object.time = 0;
                }
                if (message.state != null && message.hasOwnProperty("state"))
                    object.state = options.enums === String ? $root.lebai.io.ButtonState[message.state] === undefined ? message.state : $root.lebai.io.ButtonState[message.state] : message.state;
                if (message.time != null && message.hasOwnProperty("time"))
                    object.time = message.time;
                return object;
            };

            /**
             * Converts this ButtonStatus to JSON.
             * @function toJSON
             * @memberof lebai.io.ButtonStatus
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ButtonStatus.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ButtonStatus
             * @function getTypeUrl
             * @memberof lebai.io.ButtonStatus
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ButtonStatus.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.io.ButtonStatus";
            };

            return ButtonStatus;
        })();

        io.ButtonsStatus = (function() {

            /**
             * Properties of a ButtonsStatus.
             * @memberof lebai.io
             * @interface IButtonsStatus
             * @property {lebai.io.IButtonIndex|null} [button] ButtonsStatus button
             * @property {lebai.io.IButtonStatus|null} [status] ButtonsStatus status
             */

            /**
             * Constructs a new ButtonsStatus.
             * @memberof lebai.io
             * @classdesc Represents a ButtonsStatus.
             * @implements IButtonsStatus
             * @constructor
             * @param {lebai.io.IButtonsStatus=} [properties] Properties to set
             */
            function ButtonsStatus(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ButtonsStatus button.
             * @member {lebai.io.IButtonIndex|null|undefined} button
             * @memberof lebai.io.ButtonsStatus
             * @instance
             */
            ButtonsStatus.prototype.button = null;

            /**
             * ButtonsStatus status.
             * @member {lebai.io.IButtonStatus|null|undefined} status
             * @memberof lebai.io.ButtonsStatus
             * @instance
             */
            ButtonsStatus.prototype.status = null;

            /**
             * Creates a new ButtonsStatus instance using the specified properties.
             * @function create
             * @memberof lebai.io.ButtonsStatus
             * @static
             * @param {lebai.io.IButtonsStatus=} [properties] Properties to set
             * @returns {lebai.io.ButtonsStatus} ButtonsStatus instance
             */
            ButtonsStatus.create = function create(properties) {
                return new ButtonsStatus(properties);
            };

            /**
             * Encodes the specified ButtonsStatus message. Does not implicitly {@link lebai.io.ButtonsStatus.verify|verify} messages.
             * @function encode
             * @memberof lebai.io.ButtonsStatus
             * @static
             * @param {lebai.io.IButtonsStatus} message ButtonsStatus message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ButtonsStatus.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.button != null && Object.hasOwnProperty.call(message, "button"))
                    $root.lebai.io.ButtonIndex.encode(message.button, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                    $root.lebai.io.ButtonStatus.encode(message.status, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ButtonsStatus message, length delimited. Does not implicitly {@link lebai.io.ButtonsStatus.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.io.ButtonsStatus
             * @static
             * @param {lebai.io.IButtonsStatus} message ButtonsStatus message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ButtonsStatus.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ButtonsStatus message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.io.ButtonsStatus
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.io.ButtonsStatus} ButtonsStatus
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ButtonsStatus.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.io.ButtonsStatus();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.button = $root.lebai.io.ButtonIndex.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.status = $root.lebai.io.ButtonStatus.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ButtonsStatus message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.io.ButtonsStatus
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.io.ButtonsStatus} ButtonsStatus
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ButtonsStatus.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ButtonsStatus message.
             * @function verify
             * @memberof lebai.io.ButtonsStatus
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ButtonsStatus.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.button != null && message.hasOwnProperty("button")) {
                    var error = $root.lebai.io.ButtonIndex.verify(message.button);
                    if (error)
                        return "button." + error;
                }
                if (message.status != null && message.hasOwnProperty("status")) {
                    var error = $root.lebai.io.ButtonStatus.verify(message.status);
                    if (error)
                        return "status." + error;
                }
                return null;
            };

            /**
             * Creates a ButtonsStatus message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.io.ButtonsStatus
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.io.ButtonsStatus} ButtonsStatus
             */
            ButtonsStatus.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.io.ButtonsStatus)
                    return object;
                var message = new $root.lebai.io.ButtonsStatus();
                if (object.button != null) {
                    if (typeof object.button !== "object")
                        throw TypeError(".lebai.io.ButtonsStatus.button: object expected");
                    message.button = $root.lebai.io.ButtonIndex.fromObject(object.button);
                }
                if (object.status != null) {
                    if (typeof object.status !== "object")
                        throw TypeError(".lebai.io.ButtonsStatus.status: object expected");
                    message.status = $root.lebai.io.ButtonStatus.fromObject(object.status);
                }
                return message;
            };

            /**
             * Creates a plain object from a ButtonsStatus message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.io.ButtonsStatus
             * @static
             * @param {lebai.io.ButtonsStatus} message ButtonsStatus
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ButtonsStatus.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.button = null;
                    object.status = null;
                }
                if (message.button != null && message.hasOwnProperty("button"))
                    object.button = $root.lebai.io.ButtonIndex.toObject(message.button, options);
                if (message.status != null && message.hasOwnProperty("status"))
                    object.status = $root.lebai.io.ButtonStatus.toObject(message.status, options);
                return object;
            };

            /**
             * Converts this ButtonsStatus to JSON.
             * @function toJSON
             * @memberof lebai.io.ButtonsStatus
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ButtonsStatus.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ButtonsStatus
             * @function getTypeUrl
             * @memberof lebai.io.ButtonsStatus
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ButtonsStatus.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.io.ButtonsStatus";
            };

            return ButtonsStatus;
        })();

        io.SetDioModeRequest = (function() {

            /**
             * Properties of a SetDioModeRequest.
             * @memberof lebai.io
             * @interface ISetDioModeRequest
             * @property {lebai.io.IoDevice|null} [device] SetDioModeRequest device
             * @property {number|null} [pin] SetDioModeRequest pin
             * @property {lebai.io.DigitalMode|null} [mode] SetDioModeRequest mode
             */

            /**
             * Constructs a new SetDioModeRequest.
             * @memberof lebai.io
             * @classdesc Represents a SetDioModeRequest.
             * @implements ISetDioModeRequest
             * @constructor
             * @param {lebai.io.ISetDioModeRequest=} [properties] Properties to set
             */
            function SetDioModeRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SetDioModeRequest device.
             * @member {lebai.io.IoDevice} device
             * @memberof lebai.io.SetDioModeRequest
             * @instance
             */
            SetDioModeRequest.prototype.device = 0;

            /**
             * SetDioModeRequest pin.
             * @member {number} pin
             * @memberof lebai.io.SetDioModeRequest
             * @instance
             */
            SetDioModeRequest.prototype.pin = 0;

            /**
             * SetDioModeRequest mode.
             * @member {lebai.io.DigitalMode} mode
             * @memberof lebai.io.SetDioModeRequest
             * @instance
             */
            SetDioModeRequest.prototype.mode = 0;

            /**
             * Creates a new SetDioModeRequest instance using the specified properties.
             * @function create
             * @memberof lebai.io.SetDioModeRequest
             * @static
             * @param {lebai.io.ISetDioModeRequest=} [properties] Properties to set
             * @returns {lebai.io.SetDioModeRequest} SetDioModeRequest instance
             */
            SetDioModeRequest.create = function create(properties) {
                return new SetDioModeRequest(properties);
            };

            /**
             * Encodes the specified SetDioModeRequest message. Does not implicitly {@link lebai.io.SetDioModeRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.io.SetDioModeRequest
             * @static
             * @param {lebai.io.ISetDioModeRequest} message SetDioModeRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetDioModeRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.device != null && Object.hasOwnProperty.call(message, "device"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.device);
                if (message.pin != null && Object.hasOwnProperty.call(message, "pin"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.pin);
                if (message.mode != null && Object.hasOwnProperty.call(message, "mode"))
                    writer.uint32(/* id 11, wireType 0 =*/88).int32(message.mode);
                return writer;
            };

            /**
             * Encodes the specified SetDioModeRequest message, length delimited. Does not implicitly {@link lebai.io.SetDioModeRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.io.SetDioModeRequest
             * @static
             * @param {lebai.io.ISetDioModeRequest} message SetDioModeRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetDioModeRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetDioModeRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.io.SetDioModeRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.io.SetDioModeRequest} SetDioModeRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetDioModeRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.io.SetDioModeRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.device = reader.int32();
                            break;
                        }
                    case 2: {
                            message.pin = reader.uint32();
                            break;
                        }
                    case 11: {
                            message.mode = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetDioModeRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.io.SetDioModeRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.io.SetDioModeRequest} SetDioModeRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetDioModeRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetDioModeRequest message.
             * @function verify
             * @memberof lebai.io.SetDioModeRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetDioModeRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.device != null && message.hasOwnProperty("device"))
                    switch (message.device) {
                    default:
                        return "device: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 10:
                    case 11:
                    case 12:
                        break;
                    }
                if (message.pin != null && message.hasOwnProperty("pin"))
                    if (!$util.isInteger(message.pin))
                        return "pin: integer expected";
                if (message.mode != null && message.hasOwnProperty("mode"))
                    switch (message.mode) {
                    default:
                        return "mode: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                return null;
            };

            /**
             * Creates a SetDioModeRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.io.SetDioModeRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.io.SetDioModeRequest} SetDioModeRequest
             */
            SetDioModeRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.io.SetDioModeRequest)
                    return object;
                var message = new $root.lebai.io.SetDioModeRequest();
                switch (object.device) {
                default:
                    if (typeof object.device === "number") {
                        message.device = object.device;
                        break;
                    }
                    break;
                case "ROBOT":
                case 0:
                    message.device = 0;
                    break;
                case "FLANGE":
                case 1:
                    message.device = 1;
                    break;
                case "EXTRA":
                case 2:
                    message.device = 2;
                    break;
                case "ROBOT_BTN":
                case 10:
                    message.device = 10;
                    break;
                case "SHOULDER":
                case 11:
                    message.device = 11;
                    break;
                case "FLANGE_BTN":
                case 12:
                    message.device = 12;
                    break;
                }
                if (object.pin != null)
                    message.pin = object.pin >>> 0;
                switch (object.mode) {
                default:
                    if (typeof object.mode === "number") {
                        message.mode = object.mode;
                        break;
                    }
                    break;
                case "INPUT":
                case 0:
                    message.mode = 0;
                    break;
                case "OUTPUT":
                case 1:
                    message.mode = 1;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a SetDioModeRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.io.SetDioModeRequest
             * @static
             * @param {lebai.io.SetDioModeRequest} message SetDioModeRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetDioModeRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.device = options.enums === String ? "ROBOT" : 0;
                    object.pin = 0;
                    object.mode = options.enums === String ? "INPUT" : 0;
                }
                if (message.device != null && message.hasOwnProperty("device"))
                    object.device = options.enums === String ? $root.lebai.io.IoDevice[message.device] === undefined ? message.device : $root.lebai.io.IoDevice[message.device] : message.device;
                if (message.pin != null && message.hasOwnProperty("pin"))
                    object.pin = message.pin;
                if (message.mode != null && message.hasOwnProperty("mode"))
                    object.mode = options.enums === String ? $root.lebai.io.DigitalMode[message.mode] === undefined ? message.mode : $root.lebai.io.DigitalMode[message.mode] : message.mode;
                return object;
            };

            /**
             * Converts this SetDioModeRequest to JSON.
             * @function toJSON
             * @memberof lebai.io.SetDioModeRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetDioModeRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetDioModeRequest
             * @function getTypeUrl
             * @memberof lebai.io.SetDioModeRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetDioModeRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.io.SetDioModeRequest";
            };

            return SetDioModeRequest;
        })();

        io.GetDioModeRequest = (function() {

            /**
             * Properties of a GetDioModeRequest.
             * @memberof lebai.io
             * @interface IGetDioModeRequest
             * @property {lebai.io.IoDevice|null} [device] GetDioModeRequest device
             * @property {number|null} [pin] GetDioModeRequest pin
             * @property {number|null} [count] GetDioModeRequest count
             */

            /**
             * Constructs a new GetDioModeRequest.
             * @memberof lebai.io
             * @classdesc Represents a GetDioModeRequest.
             * @implements IGetDioModeRequest
             * @constructor
             * @param {lebai.io.IGetDioModeRequest=} [properties] Properties to set
             */
            function GetDioModeRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetDioModeRequest device.
             * @member {lebai.io.IoDevice} device
             * @memberof lebai.io.GetDioModeRequest
             * @instance
             */
            GetDioModeRequest.prototype.device = 0;

            /**
             * GetDioModeRequest pin.
             * @member {number} pin
             * @memberof lebai.io.GetDioModeRequest
             * @instance
             */
            GetDioModeRequest.prototype.pin = 0;

            /**
             * GetDioModeRequest count.
             * @member {number} count
             * @memberof lebai.io.GetDioModeRequest
             * @instance
             */
            GetDioModeRequest.prototype.count = 0;

            /**
             * Creates a new GetDioModeRequest instance using the specified properties.
             * @function create
             * @memberof lebai.io.GetDioModeRequest
             * @static
             * @param {lebai.io.IGetDioModeRequest=} [properties] Properties to set
             * @returns {lebai.io.GetDioModeRequest} GetDioModeRequest instance
             */
            GetDioModeRequest.create = function create(properties) {
                return new GetDioModeRequest(properties);
            };

            /**
             * Encodes the specified GetDioModeRequest message. Does not implicitly {@link lebai.io.GetDioModeRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.io.GetDioModeRequest
             * @static
             * @param {lebai.io.IGetDioModeRequest} message GetDioModeRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetDioModeRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.device != null && Object.hasOwnProperty.call(message, "device"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.device);
                if (message.pin != null && Object.hasOwnProperty.call(message, "pin"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.pin);
                if (message.count != null && Object.hasOwnProperty.call(message, "count"))
                    writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.count);
                return writer;
            };

            /**
             * Encodes the specified GetDioModeRequest message, length delimited. Does not implicitly {@link lebai.io.GetDioModeRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.io.GetDioModeRequest
             * @static
             * @param {lebai.io.IGetDioModeRequest} message GetDioModeRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetDioModeRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetDioModeRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.io.GetDioModeRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.io.GetDioModeRequest} GetDioModeRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetDioModeRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.io.GetDioModeRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.device = reader.int32();
                            break;
                        }
                    case 2: {
                            message.pin = reader.uint32();
                            break;
                        }
                    case 11: {
                            message.count = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetDioModeRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.io.GetDioModeRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.io.GetDioModeRequest} GetDioModeRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetDioModeRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetDioModeRequest message.
             * @function verify
             * @memberof lebai.io.GetDioModeRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetDioModeRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.device != null && message.hasOwnProperty("device"))
                    switch (message.device) {
                    default:
                        return "device: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 10:
                    case 11:
                    case 12:
                        break;
                    }
                if (message.pin != null && message.hasOwnProperty("pin"))
                    if (!$util.isInteger(message.pin))
                        return "pin: integer expected";
                if (message.count != null && message.hasOwnProperty("count"))
                    if (!$util.isInteger(message.count))
                        return "count: integer expected";
                return null;
            };

            /**
             * Creates a GetDioModeRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.io.GetDioModeRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.io.GetDioModeRequest} GetDioModeRequest
             */
            GetDioModeRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.io.GetDioModeRequest)
                    return object;
                var message = new $root.lebai.io.GetDioModeRequest();
                switch (object.device) {
                default:
                    if (typeof object.device === "number") {
                        message.device = object.device;
                        break;
                    }
                    break;
                case "ROBOT":
                case 0:
                    message.device = 0;
                    break;
                case "FLANGE":
                case 1:
                    message.device = 1;
                    break;
                case "EXTRA":
                case 2:
                    message.device = 2;
                    break;
                case "ROBOT_BTN":
                case 10:
                    message.device = 10;
                    break;
                case "SHOULDER":
                case 11:
                    message.device = 11;
                    break;
                case "FLANGE_BTN":
                case 12:
                    message.device = 12;
                    break;
                }
                if (object.pin != null)
                    message.pin = object.pin >>> 0;
                if (object.count != null)
                    message.count = object.count >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a GetDioModeRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.io.GetDioModeRequest
             * @static
             * @param {lebai.io.GetDioModeRequest} message GetDioModeRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetDioModeRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.device = options.enums === String ? "ROBOT" : 0;
                    object.pin = 0;
                    object.count = 0;
                }
                if (message.device != null && message.hasOwnProperty("device"))
                    object.device = options.enums === String ? $root.lebai.io.IoDevice[message.device] === undefined ? message.device : $root.lebai.io.IoDevice[message.device] : message.device;
                if (message.pin != null && message.hasOwnProperty("pin"))
                    object.pin = message.pin;
                if (message.count != null && message.hasOwnProperty("count"))
                    object.count = message.count;
                return object;
            };

            /**
             * Converts this GetDioModeRequest to JSON.
             * @function toJSON
             * @memberof lebai.io.GetDioModeRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetDioModeRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetDioModeRequest
             * @function getTypeUrl
             * @memberof lebai.io.GetDioModeRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetDioModeRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.io.GetDioModeRequest";
            };

            return GetDioModeRequest;
        })();

        io.GetDioModeResponse = (function() {

            /**
             * Properties of a GetDioModeResponse.
             * @memberof lebai.io
             * @interface IGetDioModeResponse
             * @property {lebai.io.DigitalMode|null} [mode] GetDioModeResponse mode
             */

            /**
             * Constructs a new GetDioModeResponse.
             * @memberof lebai.io
             * @classdesc Represents a GetDioModeResponse.
             * @implements IGetDioModeResponse
             * @constructor
             * @param {lebai.io.IGetDioModeResponse=} [properties] Properties to set
             */
            function GetDioModeResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetDioModeResponse mode.
             * @member {lebai.io.DigitalMode} mode
             * @memberof lebai.io.GetDioModeResponse
             * @instance
             */
            GetDioModeResponse.prototype.mode = 0;

            /**
             * Creates a new GetDioModeResponse instance using the specified properties.
             * @function create
             * @memberof lebai.io.GetDioModeResponse
             * @static
             * @param {lebai.io.IGetDioModeResponse=} [properties] Properties to set
             * @returns {lebai.io.GetDioModeResponse} GetDioModeResponse instance
             */
            GetDioModeResponse.create = function create(properties) {
                return new GetDioModeResponse(properties);
            };

            /**
             * Encodes the specified GetDioModeResponse message. Does not implicitly {@link lebai.io.GetDioModeResponse.verify|verify} messages.
             * @function encode
             * @memberof lebai.io.GetDioModeResponse
             * @static
             * @param {lebai.io.IGetDioModeResponse} message GetDioModeResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetDioModeResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.mode != null && Object.hasOwnProperty.call(message, "mode"))
                    writer.uint32(/* id 11, wireType 0 =*/88).int32(message.mode);
                return writer;
            };

            /**
             * Encodes the specified GetDioModeResponse message, length delimited. Does not implicitly {@link lebai.io.GetDioModeResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.io.GetDioModeResponse
             * @static
             * @param {lebai.io.IGetDioModeResponse} message GetDioModeResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetDioModeResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetDioModeResponse message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.io.GetDioModeResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.io.GetDioModeResponse} GetDioModeResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetDioModeResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.io.GetDioModeResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 11: {
                            message.mode = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetDioModeResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.io.GetDioModeResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.io.GetDioModeResponse} GetDioModeResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetDioModeResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetDioModeResponse message.
             * @function verify
             * @memberof lebai.io.GetDioModeResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetDioModeResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.mode != null && message.hasOwnProperty("mode"))
                    switch (message.mode) {
                    default:
                        return "mode: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                return null;
            };

            /**
             * Creates a GetDioModeResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.io.GetDioModeResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.io.GetDioModeResponse} GetDioModeResponse
             */
            GetDioModeResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.io.GetDioModeResponse)
                    return object;
                var message = new $root.lebai.io.GetDioModeResponse();
                switch (object.mode) {
                default:
                    if (typeof object.mode === "number") {
                        message.mode = object.mode;
                        break;
                    }
                    break;
                case "INPUT":
                case 0:
                    message.mode = 0;
                    break;
                case "OUTPUT":
                case 1:
                    message.mode = 1;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a GetDioModeResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.io.GetDioModeResponse
             * @static
             * @param {lebai.io.GetDioModeResponse} message GetDioModeResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetDioModeResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.mode = options.enums === String ? "INPUT" : 0;
                if (message.mode != null && message.hasOwnProperty("mode"))
                    object.mode = options.enums === String ? $root.lebai.io.DigitalMode[message.mode] === undefined ? message.mode : $root.lebai.io.DigitalMode[message.mode] : message.mode;
                return object;
            };

            /**
             * Converts this GetDioModeResponse to JSON.
             * @function toJSON
             * @memberof lebai.io.GetDioModeResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetDioModeResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetDioModeResponse
             * @function getTypeUrl
             * @memberof lebai.io.GetDioModeResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetDioModeResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.io.GetDioModeResponse";
            };

            return GetDioModeResponse;
        })();

        io.GetDiosModeRequest = (function() {

            /**
             * Properties of a GetDiosModeRequest.
             * @memberof lebai.io
             * @interface IGetDiosModeRequest
             * @property {lebai.io.IoDevice|null} [device] GetDiosModeRequest device
             * @property {number|null} [pin] GetDiosModeRequest pin
             * @property {number|null} [count] GetDiosModeRequest count
             */

            /**
             * Constructs a new GetDiosModeRequest.
             * @memberof lebai.io
             * @classdesc Represents a GetDiosModeRequest.
             * @implements IGetDiosModeRequest
             * @constructor
             * @param {lebai.io.IGetDiosModeRequest=} [properties] Properties to set
             */
            function GetDiosModeRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetDiosModeRequest device.
             * @member {lebai.io.IoDevice} device
             * @memberof lebai.io.GetDiosModeRequest
             * @instance
             */
            GetDiosModeRequest.prototype.device = 0;

            /**
             * GetDiosModeRequest pin.
             * @member {number} pin
             * @memberof lebai.io.GetDiosModeRequest
             * @instance
             */
            GetDiosModeRequest.prototype.pin = 0;

            /**
             * GetDiosModeRequest count.
             * @member {number} count
             * @memberof lebai.io.GetDiosModeRequest
             * @instance
             */
            GetDiosModeRequest.prototype.count = 0;

            /**
             * Creates a new GetDiosModeRequest instance using the specified properties.
             * @function create
             * @memberof lebai.io.GetDiosModeRequest
             * @static
             * @param {lebai.io.IGetDiosModeRequest=} [properties] Properties to set
             * @returns {lebai.io.GetDiosModeRequest} GetDiosModeRequest instance
             */
            GetDiosModeRequest.create = function create(properties) {
                return new GetDiosModeRequest(properties);
            };

            /**
             * Encodes the specified GetDiosModeRequest message. Does not implicitly {@link lebai.io.GetDiosModeRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.io.GetDiosModeRequest
             * @static
             * @param {lebai.io.IGetDiosModeRequest} message GetDiosModeRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetDiosModeRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.device != null && Object.hasOwnProperty.call(message, "device"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.device);
                if (message.pin != null && Object.hasOwnProperty.call(message, "pin"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.pin);
                if (message.count != null && Object.hasOwnProperty.call(message, "count"))
                    writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.count);
                return writer;
            };

            /**
             * Encodes the specified GetDiosModeRequest message, length delimited. Does not implicitly {@link lebai.io.GetDiosModeRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.io.GetDiosModeRequest
             * @static
             * @param {lebai.io.IGetDiosModeRequest} message GetDiosModeRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetDiosModeRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetDiosModeRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.io.GetDiosModeRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.io.GetDiosModeRequest} GetDiosModeRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetDiosModeRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.io.GetDiosModeRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.device = reader.int32();
                            break;
                        }
                    case 2: {
                            message.pin = reader.uint32();
                            break;
                        }
                    case 11: {
                            message.count = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetDiosModeRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.io.GetDiosModeRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.io.GetDiosModeRequest} GetDiosModeRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetDiosModeRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetDiosModeRequest message.
             * @function verify
             * @memberof lebai.io.GetDiosModeRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetDiosModeRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.device != null && message.hasOwnProperty("device"))
                    switch (message.device) {
                    default:
                        return "device: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 10:
                    case 11:
                    case 12:
                        break;
                    }
                if (message.pin != null && message.hasOwnProperty("pin"))
                    if (!$util.isInteger(message.pin))
                        return "pin: integer expected";
                if (message.count != null && message.hasOwnProperty("count"))
                    if (!$util.isInteger(message.count))
                        return "count: integer expected";
                return null;
            };

            /**
             * Creates a GetDiosModeRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.io.GetDiosModeRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.io.GetDiosModeRequest} GetDiosModeRequest
             */
            GetDiosModeRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.io.GetDiosModeRequest)
                    return object;
                var message = new $root.lebai.io.GetDiosModeRequest();
                switch (object.device) {
                default:
                    if (typeof object.device === "number") {
                        message.device = object.device;
                        break;
                    }
                    break;
                case "ROBOT":
                case 0:
                    message.device = 0;
                    break;
                case "FLANGE":
                case 1:
                    message.device = 1;
                    break;
                case "EXTRA":
                case 2:
                    message.device = 2;
                    break;
                case "ROBOT_BTN":
                case 10:
                    message.device = 10;
                    break;
                case "SHOULDER":
                case 11:
                    message.device = 11;
                    break;
                case "FLANGE_BTN":
                case 12:
                    message.device = 12;
                    break;
                }
                if (object.pin != null)
                    message.pin = object.pin >>> 0;
                if (object.count != null)
                    message.count = object.count >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a GetDiosModeRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.io.GetDiosModeRequest
             * @static
             * @param {lebai.io.GetDiosModeRequest} message GetDiosModeRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetDiosModeRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.device = options.enums === String ? "ROBOT" : 0;
                    object.pin = 0;
                    object.count = 0;
                }
                if (message.device != null && message.hasOwnProperty("device"))
                    object.device = options.enums === String ? $root.lebai.io.IoDevice[message.device] === undefined ? message.device : $root.lebai.io.IoDevice[message.device] : message.device;
                if (message.pin != null && message.hasOwnProperty("pin"))
                    object.pin = message.pin;
                if (message.count != null && message.hasOwnProperty("count"))
                    object.count = message.count;
                return object;
            };

            /**
             * Converts this GetDiosModeRequest to JSON.
             * @function toJSON
             * @memberof lebai.io.GetDiosModeRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetDiosModeRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetDiosModeRequest
             * @function getTypeUrl
             * @memberof lebai.io.GetDiosModeRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetDiosModeRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.io.GetDiosModeRequest";
            };

            return GetDiosModeRequest;
        })();

        io.GetDiosModeResponse = (function() {

            /**
             * Properties of a GetDiosModeResponse.
             * @memberof lebai.io
             * @interface IGetDiosModeResponse
             * @property {Array.<lebai.io.DigitalMode>|null} [modes] GetDiosModeResponse modes
             */

            /**
             * Constructs a new GetDiosModeResponse.
             * @memberof lebai.io
             * @classdesc Represents a GetDiosModeResponse.
             * @implements IGetDiosModeResponse
             * @constructor
             * @param {lebai.io.IGetDiosModeResponse=} [properties] Properties to set
             */
            function GetDiosModeResponse(properties) {
                this.modes = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetDiosModeResponse modes.
             * @member {Array.<lebai.io.DigitalMode>} modes
             * @memberof lebai.io.GetDiosModeResponse
             * @instance
             */
            GetDiosModeResponse.prototype.modes = $util.emptyArray;

            /**
             * Creates a new GetDiosModeResponse instance using the specified properties.
             * @function create
             * @memberof lebai.io.GetDiosModeResponse
             * @static
             * @param {lebai.io.IGetDiosModeResponse=} [properties] Properties to set
             * @returns {lebai.io.GetDiosModeResponse} GetDiosModeResponse instance
             */
            GetDiosModeResponse.create = function create(properties) {
                return new GetDiosModeResponse(properties);
            };

            /**
             * Encodes the specified GetDiosModeResponse message. Does not implicitly {@link lebai.io.GetDiosModeResponse.verify|verify} messages.
             * @function encode
             * @memberof lebai.io.GetDiosModeResponse
             * @static
             * @param {lebai.io.IGetDiosModeResponse} message GetDiosModeResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetDiosModeResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.modes != null && message.modes.length) {
                    writer.uint32(/* id 11, wireType 2 =*/90).fork();
                    for (var i = 0; i < message.modes.length; ++i)
                        writer.int32(message.modes[i]);
                    writer.ldelim();
                }
                return writer;
            };

            /**
             * Encodes the specified GetDiosModeResponse message, length delimited. Does not implicitly {@link lebai.io.GetDiosModeResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.io.GetDiosModeResponse
             * @static
             * @param {lebai.io.IGetDiosModeResponse} message GetDiosModeResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetDiosModeResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetDiosModeResponse message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.io.GetDiosModeResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.io.GetDiosModeResponse} GetDiosModeResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetDiosModeResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.io.GetDiosModeResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 11: {
                            if (!(message.modes && message.modes.length))
                                message.modes = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.modes.push(reader.int32());
                            } else
                                message.modes.push(reader.int32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetDiosModeResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.io.GetDiosModeResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.io.GetDiosModeResponse} GetDiosModeResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetDiosModeResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetDiosModeResponse message.
             * @function verify
             * @memberof lebai.io.GetDiosModeResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetDiosModeResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.modes != null && message.hasOwnProperty("modes")) {
                    if (!Array.isArray(message.modes))
                        return "modes: array expected";
                    for (var i = 0; i < message.modes.length; ++i)
                        switch (message.modes[i]) {
                        default:
                            return "modes: enum value[] expected";
                        case 0:
                        case 1:
                            break;
                        }
                }
                return null;
            };

            /**
             * Creates a GetDiosModeResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.io.GetDiosModeResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.io.GetDiosModeResponse} GetDiosModeResponse
             */
            GetDiosModeResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.io.GetDiosModeResponse)
                    return object;
                var message = new $root.lebai.io.GetDiosModeResponse();
                if (object.modes) {
                    if (!Array.isArray(object.modes))
                        throw TypeError(".lebai.io.GetDiosModeResponse.modes: array expected");
                    message.modes = [];
                    for (var i = 0; i < object.modes.length; ++i)
                        switch (object.modes[i]) {
                        default:
                            if (typeof object.modes[i] === "number") {
                                message.modes[i] = object.modes[i];
                                break;
                            }
                        case "INPUT":
                        case 0:
                            message.modes[i] = 0;
                            break;
                        case "OUTPUT":
                        case 1:
                            message.modes[i] = 1;
                            break;
                        }
                }
                return message;
            };

            /**
             * Creates a plain object from a GetDiosModeResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.io.GetDiosModeResponse
             * @static
             * @param {lebai.io.GetDiosModeResponse} message GetDiosModeResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetDiosModeResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.modes = [];
                if (message.modes && message.modes.length) {
                    object.modes = [];
                    for (var j = 0; j < message.modes.length; ++j)
                        object.modes[j] = options.enums === String ? $root.lebai.io.DigitalMode[message.modes[j]] === undefined ? message.modes[j] : $root.lebai.io.DigitalMode[message.modes[j]] : message.modes[j];
                }
                return object;
            };

            /**
             * Converts this GetDiosModeResponse to JSON.
             * @function toJSON
             * @memberof lebai.io.GetDiosModeResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetDiosModeResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetDiosModeResponse
             * @function getTypeUrl
             * @memberof lebai.io.GetDiosModeResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetDiosModeResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.io.GetDiosModeResponse";
            };

            return GetDiosModeResponse;
        })();

        io.IoService = (function() {

            /**
             * Constructs a new IoService service.
             * @memberof lebai.io
             * @classdesc Represents an IoService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function IoService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (IoService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = IoService;

            /**
             * Creates new IoService service using the specified rpc implementation.
             * @function create
             * @memberof lebai.io.IoService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {IoService} RPC service. Useful where requests and/or responses are streamed.
             */
            IoService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link lebai.io.IoService#getDi}.
             * @memberof lebai.io.IoService
             * @typedef GetDiCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.io.GetDioPinResponse} [response] GetDioPinResponse
             */

            /**
             * Calls GetDi.
             * @function getDi
             * @memberof lebai.io.IoService
             * @instance
             * @param {lebai.io.IGetDioPinRequest} request GetDioPinRequest message or plain object
             * @param {lebai.io.IoService.GetDiCallback} callback Node-style callback called with the error, if any, and GetDioPinResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(IoService.prototype.getDi = function getDi(request, callback) {
                return this.rpcCall(getDi, $root.lebai.io.GetDioPinRequest, $root.lebai.io.GetDioPinResponse, request, callback);
            }, "name", { value: "GetDi" });

            /**
             * Calls GetDi.
             * @function getDi
             * @memberof lebai.io.IoService
             * @instance
             * @param {lebai.io.IGetDioPinRequest} request GetDioPinRequest message or plain object
             * @returns {Promise<lebai.io.GetDioPinResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.io.IoService#getDis}.
             * @memberof lebai.io.IoService
             * @typedef GetDisCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.io.GetDioPinsResponse} [response] GetDioPinsResponse
             */

            /**
             * Calls GetDis.
             * @function getDis
             * @memberof lebai.io.IoService
             * @instance
             * @param {lebai.io.IGetDioPinsRequest} request GetDioPinsRequest message or plain object
             * @param {lebai.io.IoService.GetDisCallback} callback Node-style callback called with the error, if any, and GetDioPinsResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(IoService.prototype.getDis = function getDis(request, callback) {
                return this.rpcCall(getDis, $root.lebai.io.GetDioPinsRequest, $root.lebai.io.GetDioPinsResponse, request, callback);
            }, "name", { value: "GetDis" });

            /**
             * Calls GetDis.
             * @function getDis
             * @memberof lebai.io.IoService
             * @instance
             * @param {lebai.io.IGetDioPinsRequest} request GetDioPinsRequest message or plain object
             * @returns {Promise<lebai.io.GetDioPinsResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.io.IoService#getDo}.
             * @memberof lebai.io.IoService
             * @typedef GetDoCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.io.GetDioPinResponse} [response] GetDioPinResponse
             */

            /**
             * Calls GetDo.
             * @function getDo
             * @memberof lebai.io.IoService
             * @instance
             * @param {lebai.io.IGetDioPinRequest} request GetDioPinRequest message or plain object
             * @param {lebai.io.IoService.GetDoCallback} callback Node-style callback called with the error, if any, and GetDioPinResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(IoService.prototype.getDo = function getDo(request, callback) {
                return this.rpcCall(getDo, $root.lebai.io.GetDioPinRequest, $root.lebai.io.GetDioPinResponse, request, callback);
            }, "name", { value: "GetDo" });

            /**
             * Calls GetDo.
             * @function getDo
             * @memberof lebai.io.IoService
             * @instance
             * @param {lebai.io.IGetDioPinRequest} request GetDioPinRequest message or plain object
             * @returns {Promise<lebai.io.GetDioPinResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.io.IoService#getDos}.
             * @memberof lebai.io.IoService
             * @typedef GetDosCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.io.GetDioPinsResponse} [response] GetDioPinsResponse
             */

            /**
             * Calls GetDos.
             * @function getDos
             * @memberof lebai.io.IoService
             * @instance
             * @param {lebai.io.IGetDioPinsRequest} request GetDioPinsRequest message or plain object
             * @param {lebai.io.IoService.GetDosCallback} callback Node-style callback called with the error, if any, and GetDioPinsResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(IoService.prototype.getDos = function getDos(request, callback) {
                return this.rpcCall(getDos, $root.lebai.io.GetDioPinsRequest, $root.lebai.io.GetDioPinsResponse, request, callback);
            }, "name", { value: "GetDos" });

            /**
             * Calls GetDos.
             * @function getDos
             * @memberof lebai.io.IoService
             * @instance
             * @param {lebai.io.IGetDioPinsRequest} request GetDioPinsRequest message or plain object
             * @returns {Promise<lebai.io.GetDioPinsResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.io.IoService#setDo}.
             * @memberof lebai.io.IoService
             * @typedef SetDoCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls SetDo.
             * @function setDo
             * @memberof lebai.io.IoService
             * @instance
             * @param {lebai.io.ISetDoPinRequest} request SetDoPinRequest message or plain object
             * @param {lebai.io.IoService.SetDoCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(IoService.prototype.setDo = function setDo(request, callback) {
                return this.rpcCall(setDo, $root.lebai.io.SetDoPinRequest, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "SetDo" });

            /**
             * Calls SetDo.
             * @function setDo
             * @memberof lebai.io.IoService
             * @instance
             * @param {lebai.io.ISetDoPinRequest} request SetDoPinRequest message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.io.IoService#setDos}.
             * @memberof lebai.io.IoService
             * @typedef SetDosCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls SetDos.
             * @function setDos
             * @memberof lebai.io.IoService
             * @instance
             * @param {lebai.io.ISetDoPinsRequest} request SetDoPinsRequest message or plain object
             * @param {lebai.io.IoService.SetDosCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(IoService.prototype.setDos = function setDos(request, callback) {
                return this.rpcCall(setDos, $root.lebai.io.SetDoPinsRequest, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "SetDos" });

            /**
             * Calls SetDos.
             * @function setDos
             * @memberof lebai.io.IoService
             * @instance
             * @param {lebai.io.ISetDoPinsRequest} request SetDoPinsRequest message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.io.IoService#getAi}.
             * @memberof lebai.io.IoService
             * @typedef GetAiCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.io.GetAioPinResponse} [response] GetAioPinResponse
             */

            /**
             * Calls GetAi.
             * @function getAi
             * @memberof lebai.io.IoService
             * @instance
             * @param {lebai.io.IGetAioPinRequest} request GetAioPinRequest message or plain object
             * @param {lebai.io.IoService.GetAiCallback} callback Node-style callback called with the error, if any, and GetAioPinResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(IoService.prototype.getAi = function getAi(request, callback) {
                return this.rpcCall(getAi, $root.lebai.io.GetAioPinRequest, $root.lebai.io.GetAioPinResponse, request, callback);
            }, "name", { value: "GetAi" });

            /**
             * Calls GetAi.
             * @function getAi
             * @memberof lebai.io.IoService
             * @instance
             * @param {lebai.io.IGetAioPinRequest} request GetAioPinRequest message or plain object
             * @returns {Promise<lebai.io.GetAioPinResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.io.IoService#getAis}.
             * @memberof lebai.io.IoService
             * @typedef GetAisCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.io.GetAioPinsResponse} [response] GetAioPinsResponse
             */

            /**
             * Calls GetAis.
             * @function getAis
             * @memberof lebai.io.IoService
             * @instance
             * @param {lebai.io.IGetAioPinsRequest} request GetAioPinsRequest message or plain object
             * @param {lebai.io.IoService.GetAisCallback} callback Node-style callback called with the error, if any, and GetAioPinsResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(IoService.prototype.getAis = function getAis(request, callback) {
                return this.rpcCall(getAis, $root.lebai.io.GetAioPinsRequest, $root.lebai.io.GetAioPinsResponse, request, callback);
            }, "name", { value: "GetAis" });

            /**
             * Calls GetAis.
             * @function getAis
             * @memberof lebai.io.IoService
             * @instance
             * @param {lebai.io.IGetAioPinsRequest} request GetAioPinsRequest message or plain object
             * @returns {Promise<lebai.io.GetAioPinsResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.io.IoService#getAo}.
             * @memberof lebai.io.IoService
             * @typedef GetAoCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.io.GetAioPinResponse} [response] GetAioPinResponse
             */

            /**
             * Calls GetAo.
             * @function getAo
             * @memberof lebai.io.IoService
             * @instance
             * @param {lebai.io.IGetAioPinRequest} request GetAioPinRequest message or plain object
             * @param {lebai.io.IoService.GetAoCallback} callback Node-style callback called with the error, if any, and GetAioPinResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(IoService.prototype.getAo = function getAo(request, callback) {
                return this.rpcCall(getAo, $root.lebai.io.GetAioPinRequest, $root.lebai.io.GetAioPinResponse, request, callback);
            }, "name", { value: "GetAo" });

            /**
             * Calls GetAo.
             * @function getAo
             * @memberof lebai.io.IoService
             * @instance
             * @param {lebai.io.IGetAioPinRequest} request GetAioPinRequest message or plain object
             * @returns {Promise<lebai.io.GetAioPinResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.io.IoService#getAos}.
             * @memberof lebai.io.IoService
             * @typedef GetAosCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.io.GetAioPinsResponse} [response] GetAioPinsResponse
             */

            /**
             * Calls GetAos.
             * @function getAos
             * @memberof lebai.io.IoService
             * @instance
             * @param {lebai.io.IGetAioPinsRequest} request GetAioPinsRequest message or plain object
             * @param {lebai.io.IoService.GetAosCallback} callback Node-style callback called with the error, if any, and GetAioPinsResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(IoService.prototype.getAos = function getAos(request, callback) {
                return this.rpcCall(getAos, $root.lebai.io.GetAioPinsRequest, $root.lebai.io.GetAioPinsResponse, request, callback);
            }, "name", { value: "GetAos" });

            /**
             * Calls GetAos.
             * @function getAos
             * @memberof lebai.io.IoService
             * @instance
             * @param {lebai.io.IGetAioPinsRequest} request GetAioPinsRequest message or plain object
             * @returns {Promise<lebai.io.GetAioPinsResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.io.IoService#setAo}.
             * @memberof lebai.io.IoService
             * @typedef SetAoCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls SetAo.
             * @function setAo
             * @memberof lebai.io.IoService
             * @instance
             * @param {lebai.io.ISetAoPinRequest} request SetAoPinRequest message or plain object
             * @param {lebai.io.IoService.SetAoCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(IoService.prototype.setAo = function setAo(request, callback) {
                return this.rpcCall(setAo, $root.lebai.io.SetAoPinRequest, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "SetAo" });

            /**
             * Calls SetAo.
             * @function setAo
             * @memberof lebai.io.IoService
             * @instance
             * @param {lebai.io.ISetAoPinRequest} request SetAoPinRequest message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.io.IoService#setAos}.
             * @memberof lebai.io.IoService
             * @typedef SetAosCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls SetAos.
             * @function setAos
             * @memberof lebai.io.IoService
             * @instance
             * @param {lebai.io.ISetAoPinsRequest} request SetAoPinsRequest message or plain object
             * @param {lebai.io.IoService.SetAosCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(IoService.prototype.setAos = function setAos(request, callback) {
                return this.rpcCall(setAos, $root.lebai.io.SetAoPinsRequest, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "SetAos" });

            /**
             * Calls SetAos.
             * @function setAos
             * @memberof lebai.io.IoService
             * @instance
             * @param {lebai.io.ISetAoPinsRequest} request SetAoPinsRequest message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.io.IoService#enableButton}.
             * @memberof lebai.io.IoService
             * @typedef EnableButtonCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls EnableButton.
             * @function enableButton
             * @memberof lebai.io.IoService
             * @instance
             * @param {lebai.io.IButtonIndex} request ButtonIndex message or plain object
             * @param {lebai.io.IoService.EnableButtonCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(IoService.prototype.enableButton = function enableButton(request, callback) {
                return this.rpcCall(enableButton, $root.lebai.io.ButtonIndex, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "EnableButton" });

            /**
             * Calls EnableButton.
             * @function enableButton
             * @memberof lebai.io.IoService
             * @instance
             * @param {lebai.io.IButtonIndex} request ButtonIndex message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.io.IoService#disableButton}.
             * @memberof lebai.io.IoService
             * @typedef DisableButtonCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls DisableButton.
             * @function disableButton
             * @memberof lebai.io.IoService
             * @instance
             * @param {lebai.io.IButtonIndex} request ButtonIndex message or plain object
             * @param {lebai.io.IoService.DisableButtonCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(IoService.prototype.disableButton = function disableButton(request, callback) {
                return this.rpcCall(disableButton, $root.lebai.io.ButtonIndex, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "DisableButton" });

            /**
             * Calls DisableButton.
             * @function disableButton
             * @memberof lebai.io.IoService
             * @instance
             * @param {lebai.io.IButtonIndex} request ButtonIndex message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.io.IoService#subButtonsStatus}.
             * @memberof lebai.io.IoService
             * @typedef SubButtonsStatusCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.io.ButtonsStatus} [response] ButtonsStatus
             */

            /**
             * Calls SubButtonsStatus.
             * @function subButtonsStatus
             * @memberof lebai.io.IoService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {lebai.io.IoService.SubButtonsStatusCallback} callback Node-style callback called with the error, if any, and ButtonsStatus
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(IoService.prototype.subButtonsStatus = function subButtonsStatus(request, callback) {
                return this.rpcCall(subButtonsStatus, $root.google.protobuf.Empty, $root.lebai.io.ButtonsStatus, request, callback);
            }, "name", { value: "SubButtonsStatus" });

            /**
             * Calls SubButtonsStatus.
             * @function subButtonsStatus
             * @memberof lebai.io.IoService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<lebai.io.ButtonsStatus>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.io.IoService#setDioMode}.
             * @memberof lebai.io.IoService
             * @typedef SetDioModeCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls SetDioMode.
             * @function setDioMode
             * @memberof lebai.io.IoService
             * @instance
             * @param {lebai.io.ISetDioModeRequest} request SetDioModeRequest message or plain object
             * @param {lebai.io.IoService.SetDioModeCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(IoService.prototype.setDioMode = function setDioMode(request, callback) {
                return this.rpcCall(setDioMode, $root.lebai.io.SetDioModeRequest, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "SetDioMode" });

            /**
             * Calls SetDioMode.
             * @function setDioMode
             * @memberof lebai.io.IoService
             * @instance
             * @param {lebai.io.ISetDioModeRequest} request SetDioModeRequest message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.io.IoService#getDioMode}.
             * @memberof lebai.io.IoService
             * @typedef GetDioModeCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.io.GetDioModeResponse} [response] GetDioModeResponse
             */

            /**
             * Calls GetDioMode.
             * @function getDioMode
             * @memberof lebai.io.IoService
             * @instance
             * @param {lebai.io.IGetDioModeRequest} request GetDioModeRequest message or plain object
             * @param {lebai.io.IoService.GetDioModeCallback} callback Node-style callback called with the error, if any, and GetDioModeResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(IoService.prototype.getDioMode = function getDioMode(request, callback) {
                return this.rpcCall(getDioMode, $root.lebai.io.GetDioModeRequest, $root.lebai.io.GetDioModeResponse, request, callback);
            }, "name", { value: "GetDioMode" });

            /**
             * Calls GetDioMode.
             * @function getDioMode
             * @memberof lebai.io.IoService
             * @instance
             * @param {lebai.io.IGetDioModeRequest} request GetDioModeRequest message or plain object
             * @returns {Promise<lebai.io.GetDioModeResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.io.IoService#getDiosMode}.
             * @memberof lebai.io.IoService
             * @typedef GetDiosModeCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.io.GetDiosModeResponse} [response] GetDiosModeResponse
             */

            /**
             * Calls GetDiosMode.
             * @function getDiosMode
             * @memberof lebai.io.IoService
             * @instance
             * @param {lebai.io.IGetDiosModeRequest} request GetDiosModeRequest message or plain object
             * @param {lebai.io.IoService.GetDiosModeCallback} callback Node-style callback called with the error, if any, and GetDiosModeResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(IoService.prototype.getDiosMode = function getDiosMode(request, callback) {
                return this.rpcCall(getDiosMode, $root.lebai.io.GetDiosModeRequest, $root.lebai.io.GetDiosModeResponse, request, callback);
            }, "name", { value: "GetDiosMode" });

            /**
             * Calls GetDiosMode.
             * @function getDiosMode
             * @memberof lebai.io.IoService
             * @instance
             * @param {lebai.io.IGetDiosModeRequest} request GetDiosModeRequest message or plain object
             * @returns {Promise<lebai.io.GetDiosModeResponse>} Promise
             * @variation 2
             */

            return IoService;
        })();

        return io;
    })();

    lebai.kinematic = (function() {

        /**
         * Namespace kinematic.
         * @memberof lebai
         * @namespace
         */
        var kinematic = {};

        kinematic.DhParam = (function() {

            /**
             * Properties of a DhParam.
             * @memberof lebai.kinematic
             * @interface IDhParam
             * @property {number|null} [a] DhParam a
             * @property {number|null} [alpha] DhParam alpha
             * @property {number|null} [d] DhParam d
             * @property {number|null} [theta] DhParam theta
             */

            /**
             * Constructs a new DhParam.
             * @memberof lebai.kinematic
             * @classdesc Represents a DhParam.
             * @implements IDhParam
             * @constructor
             * @param {lebai.kinematic.IDhParam=} [properties] Properties to set
             */
            function DhParam(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DhParam a.
             * @member {number} a
             * @memberof lebai.kinematic.DhParam
             * @instance
             */
            DhParam.prototype.a = 0;

            /**
             * DhParam alpha.
             * @member {number} alpha
             * @memberof lebai.kinematic.DhParam
             * @instance
             */
            DhParam.prototype.alpha = 0;

            /**
             * DhParam d.
             * @member {number} d
             * @memberof lebai.kinematic.DhParam
             * @instance
             */
            DhParam.prototype.d = 0;

            /**
             * DhParam theta.
             * @member {number} theta
             * @memberof lebai.kinematic.DhParam
             * @instance
             */
            DhParam.prototype.theta = 0;

            /**
             * Creates a new DhParam instance using the specified properties.
             * @function create
             * @memberof lebai.kinematic.DhParam
             * @static
             * @param {lebai.kinematic.IDhParam=} [properties] Properties to set
             * @returns {lebai.kinematic.DhParam} DhParam instance
             */
            DhParam.create = function create(properties) {
                return new DhParam(properties);
            };

            /**
             * Encodes the specified DhParam message. Does not implicitly {@link lebai.kinematic.DhParam.verify|verify} messages.
             * @function encode
             * @memberof lebai.kinematic.DhParam
             * @static
             * @param {lebai.kinematic.IDhParam} message DhParam message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DhParam.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.a != null && Object.hasOwnProperty.call(message, "a"))
                    writer.uint32(/* id 1, wireType 1 =*/9).double(message.a);
                if (message.alpha != null && Object.hasOwnProperty.call(message, "alpha"))
                    writer.uint32(/* id 2, wireType 1 =*/17).double(message.alpha);
                if (message.d != null && Object.hasOwnProperty.call(message, "d"))
                    writer.uint32(/* id 3, wireType 1 =*/25).double(message.d);
                if (message.theta != null && Object.hasOwnProperty.call(message, "theta"))
                    writer.uint32(/* id 4, wireType 1 =*/33).double(message.theta);
                return writer;
            };

            /**
             * Encodes the specified DhParam message, length delimited. Does not implicitly {@link lebai.kinematic.DhParam.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.kinematic.DhParam
             * @static
             * @param {lebai.kinematic.IDhParam} message DhParam message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DhParam.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DhParam message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.kinematic.DhParam
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.kinematic.DhParam} DhParam
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DhParam.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.kinematic.DhParam();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.a = reader.double();
                            break;
                        }
                    case 2: {
                            message.alpha = reader.double();
                            break;
                        }
                    case 3: {
                            message.d = reader.double();
                            break;
                        }
                    case 4: {
                            message.theta = reader.double();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DhParam message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.kinematic.DhParam
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.kinematic.DhParam} DhParam
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DhParam.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DhParam message.
             * @function verify
             * @memberof lebai.kinematic.DhParam
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DhParam.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.a != null && message.hasOwnProperty("a"))
                    if (typeof message.a !== "number")
                        return "a: number expected";
                if (message.alpha != null && message.hasOwnProperty("alpha"))
                    if (typeof message.alpha !== "number")
                        return "alpha: number expected";
                if (message.d != null && message.hasOwnProperty("d"))
                    if (typeof message.d !== "number")
                        return "d: number expected";
                if (message.theta != null && message.hasOwnProperty("theta"))
                    if (typeof message.theta !== "number")
                        return "theta: number expected";
                return null;
            };

            /**
             * Creates a DhParam message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.kinematic.DhParam
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.kinematic.DhParam} DhParam
             */
            DhParam.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.kinematic.DhParam)
                    return object;
                var message = new $root.lebai.kinematic.DhParam();
                if (object.a != null)
                    message.a = Number(object.a);
                if (object.alpha != null)
                    message.alpha = Number(object.alpha);
                if (object.d != null)
                    message.d = Number(object.d);
                if (object.theta != null)
                    message.theta = Number(object.theta);
                return message;
            };

            /**
             * Creates a plain object from a DhParam message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.kinematic.DhParam
             * @static
             * @param {lebai.kinematic.DhParam} message DhParam
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DhParam.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.a = 0;
                    object.alpha = 0;
                    object.d = 0;
                    object.theta = 0;
                }
                if (message.a != null && message.hasOwnProperty("a"))
                    object.a = options.json && !isFinite(message.a) ? String(message.a) : message.a;
                if (message.alpha != null && message.hasOwnProperty("alpha"))
                    object.alpha = options.json && !isFinite(message.alpha) ? String(message.alpha) : message.alpha;
                if (message.d != null && message.hasOwnProperty("d"))
                    object.d = options.json && !isFinite(message.d) ? String(message.d) : message.d;
                if (message.theta != null && message.hasOwnProperty("theta"))
                    object.theta = options.json && !isFinite(message.theta) ? String(message.theta) : message.theta;
                return object;
            };

            /**
             * Converts this DhParam to JSON.
             * @function toJSON
             * @memberof lebai.kinematic.DhParam
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DhParam.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DhParam
             * @function getTypeUrl
             * @memberof lebai.kinematic.DhParam
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DhParam.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.kinematic.DhParam";
            };

            return DhParam;
        })();

        kinematic.DhParams = (function() {

            /**
             * Properties of a DhParams.
             * @memberof lebai.kinematic
             * @interface IDhParams
             * @property {Array.<lebai.kinematic.IDhParam>|null} [params] DhParams params
             */

            /**
             * Constructs a new DhParams.
             * @memberof lebai.kinematic
             * @classdesc Represents a DhParams.
             * @implements IDhParams
             * @constructor
             * @param {lebai.kinematic.IDhParams=} [properties] Properties to set
             */
            function DhParams(properties) {
                this.params = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DhParams params.
             * @member {Array.<lebai.kinematic.IDhParam>} params
             * @memberof lebai.kinematic.DhParams
             * @instance
             */
            DhParams.prototype.params = $util.emptyArray;

            /**
             * Creates a new DhParams instance using the specified properties.
             * @function create
             * @memberof lebai.kinematic.DhParams
             * @static
             * @param {lebai.kinematic.IDhParams=} [properties] Properties to set
             * @returns {lebai.kinematic.DhParams} DhParams instance
             */
            DhParams.create = function create(properties) {
                return new DhParams(properties);
            };

            /**
             * Encodes the specified DhParams message. Does not implicitly {@link lebai.kinematic.DhParams.verify|verify} messages.
             * @function encode
             * @memberof lebai.kinematic.DhParams
             * @static
             * @param {lebai.kinematic.IDhParams} message DhParams message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DhParams.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.params != null && message.params.length)
                    for (var i = 0; i < message.params.length; ++i)
                        $root.lebai.kinematic.DhParam.encode(message.params[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DhParams message, length delimited. Does not implicitly {@link lebai.kinematic.DhParams.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.kinematic.DhParams
             * @static
             * @param {lebai.kinematic.IDhParams} message DhParams message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DhParams.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DhParams message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.kinematic.DhParams
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.kinematic.DhParams} DhParams
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DhParams.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.kinematic.DhParams();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.params && message.params.length))
                                message.params = [];
                            message.params.push($root.lebai.kinematic.DhParam.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DhParams message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.kinematic.DhParams
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.kinematic.DhParams} DhParams
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DhParams.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DhParams message.
             * @function verify
             * @memberof lebai.kinematic.DhParams
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DhParams.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.params != null && message.hasOwnProperty("params")) {
                    if (!Array.isArray(message.params))
                        return "params: array expected";
                    for (var i = 0; i < message.params.length; ++i) {
                        var error = $root.lebai.kinematic.DhParam.verify(message.params[i]);
                        if (error)
                            return "params." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a DhParams message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.kinematic.DhParams
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.kinematic.DhParams} DhParams
             */
            DhParams.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.kinematic.DhParams)
                    return object;
                var message = new $root.lebai.kinematic.DhParams();
                if (object.params) {
                    if (!Array.isArray(object.params))
                        throw TypeError(".lebai.kinematic.DhParams.params: array expected");
                    message.params = [];
                    for (var i = 0; i < object.params.length; ++i) {
                        if (typeof object.params[i] !== "object")
                            throw TypeError(".lebai.kinematic.DhParams.params: object expected");
                        message.params[i] = $root.lebai.kinematic.DhParam.fromObject(object.params[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a DhParams message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.kinematic.DhParams
             * @static
             * @param {lebai.kinematic.DhParams} message DhParams
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DhParams.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.params = [];
                if (message.params && message.params.length) {
                    object.params = [];
                    for (var j = 0; j < message.params.length; ++j)
                        object.params[j] = $root.lebai.kinematic.DhParam.toObject(message.params[j], options);
                }
                return object;
            };

            /**
             * Converts this DhParams to JSON.
             * @function toJSON
             * @memberof lebai.kinematic.DhParams
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DhParams.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DhParams
             * @function getTypeUrl
             * @memberof lebai.kinematic.DhParams
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DhParams.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.kinematic.DhParams";
            };

            return DhParams;
        })();

        kinematic.KinFactor = (function() {

            /**
             * Properties of a KinFactor.
             * @memberof lebai.kinematic
             * @interface IKinFactor
             * @property {number|null} [speedFactor] KinFactor speedFactor
             */

            /**
             * Constructs a new KinFactor.
             * @memberof lebai.kinematic
             * @classdesc Represents a KinFactor.
             * @implements IKinFactor
             * @constructor
             * @param {lebai.kinematic.IKinFactor=} [properties] Properties to set
             */
            function KinFactor(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KinFactor speedFactor.
             * @member {number} speedFactor
             * @memberof lebai.kinematic.KinFactor
             * @instance
             */
            KinFactor.prototype.speedFactor = 0;

            /**
             * Creates a new KinFactor instance using the specified properties.
             * @function create
             * @memberof lebai.kinematic.KinFactor
             * @static
             * @param {lebai.kinematic.IKinFactor=} [properties] Properties to set
             * @returns {lebai.kinematic.KinFactor} KinFactor instance
             */
            KinFactor.create = function create(properties) {
                return new KinFactor(properties);
            };

            /**
             * Encodes the specified KinFactor message. Does not implicitly {@link lebai.kinematic.KinFactor.verify|verify} messages.
             * @function encode
             * @memberof lebai.kinematic.KinFactor
             * @static
             * @param {lebai.kinematic.IKinFactor} message KinFactor message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KinFactor.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.speedFactor != null && Object.hasOwnProperty.call(message, "speedFactor"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.speedFactor);
                return writer;
            };

            /**
             * Encodes the specified KinFactor message, length delimited. Does not implicitly {@link lebai.kinematic.KinFactor.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.kinematic.KinFactor
             * @static
             * @param {lebai.kinematic.IKinFactor} message KinFactor message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KinFactor.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KinFactor message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.kinematic.KinFactor
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.kinematic.KinFactor} KinFactor
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KinFactor.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.kinematic.KinFactor();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.speedFactor = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KinFactor message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.kinematic.KinFactor
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.kinematic.KinFactor} KinFactor
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KinFactor.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KinFactor message.
             * @function verify
             * @memberof lebai.kinematic.KinFactor
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KinFactor.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.speedFactor != null && message.hasOwnProperty("speedFactor"))
                    if (!$util.isInteger(message.speedFactor))
                        return "speedFactor: integer expected";
                return null;
            };

            /**
             * Creates a KinFactor message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.kinematic.KinFactor
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.kinematic.KinFactor} KinFactor
             */
            KinFactor.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.kinematic.KinFactor)
                    return object;
                var message = new $root.lebai.kinematic.KinFactor();
                if (object.speedFactor != null)
                    message.speedFactor = object.speedFactor | 0;
                return message;
            };

            /**
             * Creates a plain object from a KinFactor message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.kinematic.KinFactor
             * @static
             * @param {lebai.kinematic.KinFactor} message KinFactor
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KinFactor.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.speedFactor = 0;
                if (message.speedFactor != null && message.hasOwnProperty("speedFactor"))
                    object.speedFactor = message.speedFactor;
                return object;
            };

            /**
             * Converts this KinFactor to JSON.
             * @function toJSON
             * @memberof lebai.kinematic.KinFactor
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KinFactor.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for KinFactor
             * @function getTypeUrl
             * @memberof lebai.kinematic.KinFactor
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            KinFactor.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.kinematic.KinFactor";
            };

            return KinFactor;
        })();

        kinematic.KinData = (function() {

            /**
             * Properties of a KinData.
             * @memberof lebai.kinematic
             * @interface IKinData
             * @property {Array.<number>|null} [actualJointPose] KinData actualJointPose
             * @property {Array.<number>|null} [actualJointSpeed] KinData actualJointSpeed
             * @property {Array.<number>|null} [actualJointAcc] KinData actualJointAcc
             * @property {Array.<number>|null} [actualJointTorque] KinData actualJointTorque
             * @property {Array.<number>|null} [targetJointPose] KinData targetJointPose
             * @property {Array.<number>|null} [targetJointSpeed] KinData targetJointSpeed
             * @property {Array.<number>|null} [targetJointAcc] KinData targetJointAcc
             * @property {Array.<number>|null} [targetJointTorque] KinData targetJointTorque
             * @property {lebai.posture.ICartesianPose|null} [actualTcpPose] KinData actualTcpPose
             * @property {lebai.posture.ICartesianPose|null} [targetTcpPose] KinData targetTcpPose
             * @property {lebai.posture.ICartesianPose|null} [actualFlangePose] KinData actualFlangePose
             */

            /**
             * Constructs a new KinData.
             * @memberof lebai.kinematic
             * @classdesc Represents a KinData.
             * @implements IKinData
             * @constructor
             * @param {lebai.kinematic.IKinData=} [properties] Properties to set
             */
            function KinData(properties) {
                this.actualJointPose = [];
                this.actualJointSpeed = [];
                this.actualJointAcc = [];
                this.actualJointTorque = [];
                this.targetJointPose = [];
                this.targetJointSpeed = [];
                this.targetJointAcc = [];
                this.targetJointTorque = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KinData actualJointPose.
             * @member {Array.<number>} actualJointPose
             * @memberof lebai.kinematic.KinData
             * @instance
             */
            KinData.prototype.actualJointPose = $util.emptyArray;

            /**
             * KinData actualJointSpeed.
             * @member {Array.<number>} actualJointSpeed
             * @memberof lebai.kinematic.KinData
             * @instance
             */
            KinData.prototype.actualJointSpeed = $util.emptyArray;

            /**
             * KinData actualJointAcc.
             * @member {Array.<number>} actualJointAcc
             * @memberof lebai.kinematic.KinData
             * @instance
             */
            KinData.prototype.actualJointAcc = $util.emptyArray;

            /**
             * KinData actualJointTorque.
             * @member {Array.<number>} actualJointTorque
             * @memberof lebai.kinematic.KinData
             * @instance
             */
            KinData.prototype.actualJointTorque = $util.emptyArray;

            /**
             * KinData targetJointPose.
             * @member {Array.<number>} targetJointPose
             * @memberof lebai.kinematic.KinData
             * @instance
             */
            KinData.prototype.targetJointPose = $util.emptyArray;

            /**
             * KinData targetJointSpeed.
             * @member {Array.<number>} targetJointSpeed
             * @memberof lebai.kinematic.KinData
             * @instance
             */
            KinData.prototype.targetJointSpeed = $util.emptyArray;

            /**
             * KinData targetJointAcc.
             * @member {Array.<number>} targetJointAcc
             * @memberof lebai.kinematic.KinData
             * @instance
             */
            KinData.prototype.targetJointAcc = $util.emptyArray;

            /**
             * KinData targetJointTorque.
             * @member {Array.<number>} targetJointTorque
             * @memberof lebai.kinematic.KinData
             * @instance
             */
            KinData.prototype.targetJointTorque = $util.emptyArray;

            /**
             * KinData actualTcpPose.
             * @member {lebai.posture.ICartesianPose|null|undefined} actualTcpPose
             * @memberof lebai.kinematic.KinData
             * @instance
             */
            KinData.prototype.actualTcpPose = null;

            /**
             * KinData targetTcpPose.
             * @member {lebai.posture.ICartesianPose|null|undefined} targetTcpPose
             * @memberof lebai.kinematic.KinData
             * @instance
             */
            KinData.prototype.targetTcpPose = null;

            /**
             * KinData actualFlangePose.
             * @member {lebai.posture.ICartesianPose|null|undefined} actualFlangePose
             * @memberof lebai.kinematic.KinData
             * @instance
             */
            KinData.prototype.actualFlangePose = null;

            /**
             * Creates a new KinData instance using the specified properties.
             * @function create
             * @memberof lebai.kinematic.KinData
             * @static
             * @param {lebai.kinematic.IKinData=} [properties] Properties to set
             * @returns {lebai.kinematic.KinData} KinData instance
             */
            KinData.create = function create(properties) {
                return new KinData(properties);
            };

            /**
             * Encodes the specified KinData message. Does not implicitly {@link lebai.kinematic.KinData.verify|verify} messages.
             * @function encode
             * @memberof lebai.kinematic.KinData
             * @static
             * @param {lebai.kinematic.IKinData} message KinData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KinData.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.actualJointPose != null && message.actualJointPose.length) {
                    writer.uint32(/* id 1, wireType 2 =*/10).fork();
                    for (var i = 0; i < message.actualJointPose.length; ++i)
                        writer.double(message.actualJointPose[i]);
                    writer.ldelim();
                }
                if (message.actualJointSpeed != null && message.actualJointSpeed.length) {
                    writer.uint32(/* id 2, wireType 2 =*/18).fork();
                    for (var i = 0; i < message.actualJointSpeed.length; ++i)
                        writer.double(message.actualJointSpeed[i]);
                    writer.ldelim();
                }
                if (message.actualJointAcc != null && message.actualJointAcc.length) {
                    writer.uint32(/* id 3, wireType 2 =*/26).fork();
                    for (var i = 0; i < message.actualJointAcc.length; ++i)
                        writer.double(message.actualJointAcc[i]);
                    writer.ldelim();
                }
                if (message.actualJointTorque != null && message.actualJointTorque.length) {
                    writer.uint32(/* id 4, wireType 2 =*/34).fork();
                    for (var i = 0; i < message.actualJointTorque.length; ++i)
                        writer.double(message.actualJointTorque[i]);
                    writer.ldelim();
                }
                if (message.targetJointPose != null && message.targetJointPose.length) {
                    writer.uint32(/* id 11, wireType 2 =*/90).fork();
                    for (var i = 0; i < message.targetJointPose.length; ++i)
                        writer.double(message.targetJointPose[i]);
                    writer.ldelim();
                }
                if (message.targetJointSpeed != null && message.targetJointSpeed.length) {
                    writer.uint32(/* id 12, wireType 2 =*/98).fork();
                    for (var i = 0; i < message.targetJointSpeed.length; ++i)
                        writer.double(message.targetJointSpeed[i]);
                    writer.ldelim();
                }
                if (message.targetJointAcc != null && message.targetJointAcc.length) {
                    writer.uint32(/* id 13, wireType 2 =*/106).fork();
                    for (var i = 0; i < message.targetJointAcc.length; ++i)
                        writer.double(message.targetJointAcc[i]);
                    writer.ldelim();
                }
                if (message.targetJointTorque != null && message.targetJointTorque.length) {
                    writer.uint32(/* id 14, wireType 2 =*/114).fork();
                    for (var i = 0; i < message.targetJointTorque.length; ++i)
                        writer.double(message.targetJointTorque[i]);
                    writer.ldelim();
                }
                if (message.actualTcpPose != null && Object.hasOwnProperty.call(message, "actualTcpPose"))
                    $root.lebai.posture.CartesianPose.encode(message.actualTcpPose, writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
                if (message.targetTcpPose != null && Object.hasOwnProperty.call(message, "targetTcpPose"))
                    $root.lebai.posture.CartesianPose.encode(message.targetTcpPose, writer.uint32(/* id 31, wireType 2 =*/250).fork()).ldelim();
                if (message.actualFlangePose != null && Object.hasOwnProperty.call(message, "actualFlangePose"))
                    $root.lebai.posture.CartesianPose.encode(message.actualFlangePose, writer.uint32(/* id 41, wireType 2 =*/330).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified KinData message, length delimited. Does not implicitly {@link lebai.kinematic.KinData.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.kinematic.KinData
             * @static
             * @param {lebai.kinematic.IKinData} message KinData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KinData.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KinData message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.kinematic.KinData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.kinematic.KinData} KinData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KinData.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.kinematic.KinData();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.actualJointPose && message.actualJointPose.length))
                                message.actualJointPose = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.actualJointPose.push(reader.double());
                            } else
                                message.actualJointPose.push(reader.double());
                            break;
                        }
                    case 2: {
                            if (!(message.actualJointSpeed && message.actualJointSpeed.length))
                                message.actualJointSpeed = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.actualJointSpeed.push(reader.double());
                            } else
                                message.actualJointSpeed.push(reader.double());
                            break;
                        }
                    case 3: {
                            if (!(message.actualJointAcc && message.actualJointAcc.length))
                                message.actualJointAcc = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.actualJointAcc.push(reader.double());
                            } else
                                message.actualJointAcc.push(reader.double());
                            break;
                        }
                    case 4: {
                            if (!(message.actualJointTorque && message.actualJointTorque.length))
                                message.actualJointTorque = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.actualJointTorque.push(reader.double());
                            } else
                                message.actualJointTorque.push(reader.double());
                            break;
                        }
                    case 11: {
                            if (!(message.targetJointPose && message.targetJointPose.length))
                                message.targetJointPose = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.targetJointPose.push(reader.double());
                            } else
                                message.targetJointPose.push(reader.double());
                            break;
                        }
                    case 12: {
                            if (!(message.targetJointSpeed && message.targetJointSpeed.length))
                                message.targetJointSpeed = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.targetJointSpeed.push(reader.double());
                            } else
                                message.targetJointSpeed.push(reader.double());
                            break;
                        }
                    case 13: {
                            if (!(message.targetJointAcc && message.targetJointAcc.length))
                                message.targetJointAcc = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.targetJointAcc.push(reader.double());
                            } else
                                message.targetJointAcc.push(reader.double());
                            break;
                        }
                    case 14: {
                            if (!(message.targetJointTorque && message.targetJointTorque.length))
                                message.targetJointTorque = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.targetJointTorque.push(reader.double());
                            } else
                                message.targetJointTorque.push(reader.double());
                            break;
                        }
                    case 21: {
                            message.actualTcpPose = $root.lebai.posture.CartesianPose.decode(reader, reader.uint32());
                            break;
                        }
                    case 31: {
                            message.targetTcpPose = $root.lebai.posture.CartesianPose.decode(reader, reader.uint32());
                            break;
                        }
                    case 41: {
                            message.actualFlangePose = $root.lebai.posture.CartesianPose.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KinData message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.kinematic.KinData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.kinematic.KinData} KinData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KinData.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KinData message.
             * @function verify
             * @memberof lebai.kinematic.KinData
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KinData.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.actualJointPose != null && message.hasOwnProperty("actualJointPose")) {
                    if (!Array.isArray(message.actualJointPose))
                        return "actualJointPose: array expected";
                    for (var i = 0; i < message.actualJointPose.length; ++i)
                        if (typeof message.actualJointPose[i] !== "number")
                            return "actualJointPose: number[] expected";
                }
                if (message.actualJointSpeed != null && message.hasOwnProperty("actualJointSpeed")) {
                    if (!Array.isArray(message.actualJointSpeed))
                        return "actualJointSpeed: array expected";
                    for (var i = 0; i < message.actualJointSpeed.length; ++i)
                        if (typeof message.actualJointSpeed[i] !== "number")
                            return "actualJointSpeed: number[] expected";
                }
                if (message.actualJointAcc != null && message.hasOwnProperty("actualJointAcc")) {
                    if (!Array.isArray(message.actualJointAcc))
                        return "actualJointAcc: array expected";
                    for (var i = 0; i < message.actualJointAcc.length; ++i)
                        if (typeof message.actualJointAcc[i] !== "number")
                            return "actualJointAcc: number[] expected";
                }
                if (message.actualJointTorque != null && message.hasOwnProperty("actualJointTorque")) {
                    if (!Array.isArray(message.actualJointTorque))
                        return "actualJointTorque: array expected";
                    for (var i = 0; i < message.actualJointTorque.length; ++i)
                        if (typeof message.actualJointTorque[i] !== "number")
                            return "actualJointTorque: number[] expected";
                }
                if (message.targetJointPose != null && message.hasOwnProperty("targetJointPose")) {
                    if (!Array.isArray(message.targetJointPose))
                        return "targetJointPose: array expected";
                    for (var i = 0; i < message.targetJointPose.length; ++i)
                        if (typeof message.targetJointPose[i] !== "number")
                            return "targetJointPose: number[] expected";
                }
                if (message.targetJointSpeed != null && message.hasOwnProperty("targetJointSpeed")) {
                    if (!Array.isArray(message.targetJointSpeed))
                        return "targetJointSpeed: array expected";
                    for (var i = 0; i < message.targetJointSpeed.length; ++i)
                        if (typeof message.targetJointSpeed[i] !== "number")
                            return "targetJointSpeed: number[] expected";
                }
                if (message.targetJointAcc != null && message.hasOwnProperty("targetJointAcc")) {
                    if (!Array.isArray(message.targetJointAcc))
                        return "targetJointAcc: array expected";
                    for (var i = 0; i < message.targetJointAcc.length; ++i)
                        if (typeof message.targetJointAcc[i] !== "number")
                            return "targetJointAcc: number[] expected";
                }
                if (message.targetJointTorque != null && message.hasOwnProperty("targetJointTorque")) {
                    if (!Array.isArray(message.targetJointTorque))
                        return "targetJointTorque: array expected";
                    for (var i = 0; i < message.targetJointTorque.length; ++i)
                        if (typeof message.targetJointTorque[i] !== "number")
                            return "targetJointTorque: number[] expected";
                }
                if (message.actualTcpPose != null && message.hasOwnProperty("actualTcpPose")) {
                    var error = $root.lebai.posture.CartesianPose.verify(message.actualTcpPose);
                    if (error)
                        return "actualTcpPose." + error;
                }
                if (message.targetTcpPose != null && message.hasOwnProperty("targetTcpPose")) {
                    var error = $root.lebai.posture.CartesianPose.verify(message.targetTcpPose);
                    if (error)
                        return "targetTcpPose." + error;
                }
                if (message.actualFlangePose != null && message.hasOwnProperty("actualFlangePose")) {
                    var error = $root.lebai.posture.CartesianPose.verify(message.actualFlangePose);
                    if (error)
                        return "actualFlangePose." + error;
                }
                return null;
            };

            /**
             * Creates a KinData message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.kinematic.KinData
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.kinematic.KinData} KinData
             */
            KinData.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.kinematic.KinData)
                    return object;
                var message = new $root.lebai.kinematic.KinData();
                if (object.actualJointPose) {
                    if (!Array.isArray(object.actualJointPose))
                        throw TypeError(".lebai.kinematic.KinData.actualJointPose: array expected");
                    message.actualJointPose = [];
                    for (var i = 0; i < object.actualJointPose.length; ++i)
                        message.actualJointPose[i] = Number(object.actualJointPose[i]);
                }
                if (object.actualJointSpeed) {
                    if (!Array.isArray(object.actualJointSpeed))
                        throw TypeError(".lebai.kinematic.KinData.actualJointSpeed: array expected");
                    message.actualJointSpeed = [];
                    for (var i = 0; i < object.actualJointSpeed.length; ++i)
                        message.actualJointSpeed[i] = Number(object.actualJointSpeed[i]);
                }
                if (object.actualJointAcc) {
                    if (!Array.isArray(object.actualJointAcc))
                        throw TypeError(".lebai.kinematic.KinData.actualJointAcc: array expected");
                    message.actualJointAcc = [];
                    for (var i = 0; i < object.actualJointAcc.length; ++i)
                        message.actualJointAcc[i] = Number(object.actualJointAcc[i]);
                }
                if (object.actualJointTorque) {
                    if (!Array.isArray(object.actualJointTorque))
                        throw TypeError(".lebai.kinematic.KinData.actualJointTorque: array expected");
                    message.actualJointTorque = [];
                    for (var i = 0; i < object.actualJointTorque.length; ++i)
                        message.actualJointTorque[i] = Number(object.actualJointTorque[i]);
                }
                if (object.targetJointPose) {
                    if (!Array.isArray(object.targetJointPose))
                        throw TypeError(".lebai.kinematic.KinData.targetJointPose: array expected");
                    message.targetJointPose = [];
                    for (var i = 0; i < object.targetJointPose.length; ++i)
                        message.targetJointPose[i] = Number(object.targetJointPose[i]);
                }
                if (object.targetJointSpeed) {
                    if (!Array.isArray(object.targetJointSpeed))
                        throw TypeError(".lebai.kinematic.KinData.targetJointSpeed: array expected");
                    message.targetJointSpeed = [];
                    for (var i = 0; i < object.targetJointSpeed.length; ++i)
                        message.targetJointSpeed[i] = Number(object.targetJointSpeed[i]);
                }
                if (object.targetJointAcc) {
                    if (!Array.isArray(object.targetJointAcc))
                        throw TypeError(".lebai.kinematic.KinData.targetJointAcc: array expected");
                    message.targetJointAcc = [];
                    for (var i = 0; i < object.targetJointAcc.length; ++i)
                        message.targetJointAcc[i] = Number(object.targetJointAcc[i]);
                }
                if (object.targetJointTorque) {
                    if (!Array.isArray(object.targetJointTorque))
                        throw TypeError(".lebai.kinematic.KinData.targetJointTorque: array expected");
                    message.targetJointTorque = [];
                    for (var i = 0; i < object.targetJointTorque.length; ++i)
                        message.targetJointTorque[i] = Number(object.targetJointTorque[i]);
                }
                if (object.actualTcpPose != null) {
                    if (typeof object.actualTcpPose !== "object")
                        throw TypeError(".lebai.kinematic.KinData.actualTcpPose: object expected");
                    message.actualTcpPose = $root.lebai.posture.CartesianPose.fromObject(object.actualTcpPose);
                }
                if (object.targetTcpPose != null) {
                    if (typeof object.targetTcpPose !== "object")
                        throw TypeError(".lebai.kinematic.KinData.targetTcpPose: object expected");
                    message.targetTcpPose = $root.lebai.posture.CartesianPose.fromObject(object.targetTcpPose);
                }
                if (object.actualFlangePose != null) {
                    if (typeof object.actualFlangePose !== "object")
                        throw TypeError(".lebai.kinematic.KinData.actualFlangePose: object expected");
                    message.actualFlangePose = $root.lebai.posture.CartesianPose.fromObject(object.actualFlangePose);
                }
                return message;
            };

            /**
             * Creates a plain object from a KinData message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.kinematic.KinData
             * @static
             * @param {lebai.kinematic.KinData} message KinData
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KinData.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.actualJointPose = [];
                    object.actualJointSpeed = [];
                    object.actualJointAcc = [];
                    object.actualJointTorque = [];
                    object.targetJointPose = [];
                    object.targetJointSpeed = [];
                    object.targetJointAcc = [];
                    object.targetJointTorque = [];
                }
                if (options.defaults) {
                    object.actualTcpPose = null;
                    object.targetTcpPose = null;
                    object.actualFlangePose = null;
                }
                if (message.actualJointPose && message.actualJointPose.length) {
                    object.actualJointPose = [];
                    for (var j = 0; j < message.actualJointPose.length; ++j)
                        object.actualJointPose[j] = options.json && !isFinite(message.actualJointPose[j]) ? String(message.actualJointPose[j]) : message.actualJointPose[j];
                }
                if (message.actualJointSpeed && message.actualJointSpeed.length) {
                    object.actualJointSpeed = [];
                    for (var j = 0; j < message.actualJointSpeed.length; ++j)
                        object.actualJointSpeed[j] = options.json && !isFinite(message.actualJointSpeed[j]) ? String(message.actualJointSpeed[j]) : message.actualJointSpeed[j];
                }
                if (message.actualJointAcc && message.actualJointAcc.length) {
                    object.actualJointAcc = [];
                    for (var j = 0; j < message.actualJointAcc.length; ++j)
                        object.actualJointAcc[j] = options.json && !isFinite(message.actualJointAcc[j]) ? String(message.actualJointAcc[j]) : message.actualJointAcc[j];
                }
                if (message.actualJointTorque && message.actualJointTorque.length) {
                    object.actualJointTorque = [];
                    for (var j = 0; j < message.actualJointTorque.length; ++j)
                        object.actualJointTorque[j] = options.json && !isFinite(message.actualJointTorque[j]) ? String(message.actualJointTorque[j]) : message.actualJointTorque[j];
                }
                if (message.targetJointPose && message.targetJointPose.length) {
                    object.targetJointPose = [];
                    for (var j = 0; j < message.targetJointPose.length; ++j)
                        object.targetJointPose[j] = options.json && !isFinite(message.targetJointPose[j]) ? String(message.targetJointPose[j]) : message.targetJointPose[j];
                }
                if (message.targetJointSpeed && message.targetJointSpeed.length) {
                    object.targetJointSpeed = [];
                    for (var j = 0; j < message.targetJointSpeed.length; ++j)
                        object.targetJointSpeed[j] = options.json && !isFinite(message.targetJointSpeed[j]) ? String(message.targetJointSpeed[j]) : message.targetJointSpeed[j];
                }
                if (message.targetJointAcc && message.targetJointAcc.length) {
                    object.targetJointAcc = [];
                    for (var j = 0; j < message.targetJointAcc.length; ++j)
                        object.targetJointAcc[j] = options.json && !isFinite(message.targetJointAcc[j]) ? String(message.targetJointAcc[j]) : message.targetJointAcc[j];
                }
                if (message.targetJointTorque && message.targetJointTorque.length) {
                    object.targetJointTorque = [];
                    for (var j = 0; j < message.targetJointTorque.length; ++j)
                        object.targetJointTorque[j] = options.json && !isFinite(message.targetJointTorque[j]) ? String(message.targetJointTorque[j]) : message.targetJointTorque[j];
                }
                if (message.actualTcpPose != null && message.hasOwnProperty("actualTcpPose"))
                    object.actualTcpPose = $root.lebai.posture.CartesianPose.toObject(message.actualTcpPose, options);
                if (message.targetTcpPose != null && message.hasOwnProperty("targetTcpPose"))
                    object.targetTcpPose = $root.lebai.posture.CartesianPose.toObject(message.targetTcpPose, options);
                if (message.actualFlangePose != null && message.hasOwnProperty("actualFlangePose"))
                    object.actualFlangePose = $root.lebai.posture.CartesianPose.toObject(message.actualFlangePose, options);
                return object;
            };

            /**
             * Converts this KinData to JSON.
             * @function toJSON
             * @memberof lebai.kinematic.KinData
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KinData.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for KinData
             * @function getTypeUrl
             * @memberof lebai.kinematic.KinData
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            KinData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.kinematic.KinData";
            };

            return KinData;
        })();

        kinematic.SaveTcpRequest = (function() {

            /**
             * Properties of a SaveTcpRequest.
             * @memberof lebai.kinematic
             * @interface ISaveTcpRequest
             * @property {string|null} [name] SaveTcpRequest name
             * @property {lebai.posture.ICartesianPose|null} [data] SaveTcpRequest data
             * @property {string|null} [dir] SaveTcpRequest dir
             */

            /**
             * Constructs a new SaveTcpRequest.
             * @memberof lebai.kinematic
             * @classdesc Represents a SaveTcpRequest.
             * @implements ISaveTcpRequest
             * @constructor
             * @param {lebai.kinematic.ISaveTcpRequest=} [properties] Properties to set
             */
            function SaveTcpRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SaveTcpRequest name.
             * @member {string} name
             * @memberof lebai.kinematic.SaveTcpRequest
             * @instance
             */
            SaveTcpRequest.prototype.name = "";

            /**
             * SaveTcpRequest data.
             * @member {lebai.posture.ICartesianPose|null|undefined} data
             * @memberof lebai.kinematic.SaveTcpRequest
             * @instance
             */
            SaveTcpRequest.prototype.data = null;

            /**
             * SaveTcpRequest dir.
             * @member {string} dir
             * @memberof lebai.kinematic.SaveTcpRequest
             * @instance
             */
            SaveTcpRequest.prototype.dir = "";

            /**
             * Creates a new SaveTcpRequest instance using the specified properties.
             * @function create
             * @memberof lebai.kinematic.SaveTcpRequest
             * @static
             * @param {lebai.kinematic.ISaveTcpRequest=} [properties] Properties to set
             * @returns {lebai.kinematic.SaveTcpRequest} SaveTcpRequest instance
             */
            SaveTcpRequest.create = function create(properties) {
                return new SaveTcpRequest(properties);
            };

            /**
             * Encodes the specified SaveTcpRequest message. Does not implicitly {@link lebai.kinematic.SaveTcpRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.kinematic.SaveTcpRequest
             * @static
             * @param {lebai.kinematic.ISaveTcpRequest} message SaveTcpRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SaveTcpRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    $root.lebai.posture.CartesianPose.encode(message.data, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.dir != null && Object.hasOwnProperty.call(message, "dir"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.dir);
                return writer;
            };

            /**
             * Encodes the specified SaveTcpRequest message, length delimited. Does not implicitly {@link lebai.kinematic.SaveTcpRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.kinematic.SaveTcpRequest
             * @static
             * @param {lebai.kinematic.ISaveTcpRequest} message SaveTcpRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SaveTcpRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SaveTcpRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.kinematic.SaveTcpRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.kinematic.SaveTcpRequest} SaveTcpRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SaveTcpRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.kinematic.SaveTcpRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.name = reader.string();
                            break;
                        }
                    case 2: {
                            message.data = $root.lebai.posture.CartesianPose.decode(reader, reader.uint32());
                            break;
                        }
                    case 11: {
                            message.dir = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SaveTcpRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.kinematic.SaveTcpRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.kinematic.SaveTcpRequest} SaveTcpRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SaveTcpRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SaveTcpRequest message.
             * @function verify
             * @memberof lebai.kinematic.SaveTcpRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SaveTcpRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.data != null && message.hasOwnProperty("data")) {
                    var error = $root.lebai.posture.CartesianPose.verify(message.data);
                    if (error)
                        return "data." + error;
                }
                if (message.dir != null && message.hasOwnProperty("dir"))
                    if (!$util.isString(message.dir))
                        return "dir: string expected";
                return null;
            };

            /**
             * Creates a SaveTcpRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.kinematic.SaveTcpRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.kinematic.SaveTcpRequest} SaveTcpRequest
             */
            SaveTcpRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.kinematic.SaveTcpRequest)
                    return object;
                var message = new $root.lebai.kinematic.SaveTcpRequest();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.data != null) {
                    if (typeof object.data !== "object")
                        throw TypeError(".lebai.kinematic.SaveTcpRequest.data: object expected");
                    message.data = $root.lebai.posture.CartesianPose.fromObject(object.data);
                }
                if (object.dir != null)
                    message.dir = String(object.dir);
                return message;
            };

            /**
             * Creates a plain object from a SaveTcpRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.kinematic.SaveTcpRequest
             * @static
             * @param {lebai.kinematic.SaveTcpRequest} message SaveTcpRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SaveTcpRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.data = null;
                    object.dir = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.data != null && message.hasOwnProperty("data"))
                    object.data = $root.lebai.posture.CartesianPose.toObject(message.data, options);
                if (message.dir != null && message.hasOwnProperty("dir"))
                    object.dir = message.dir;
                return object;
            };

            /**
             * Converts this SaveTcpRequest to JSON.
             * @function toJSON
             * @memberof lebai.kinematic.SaveTcpRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SaveTcpRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SaveTcpRequest
             * @function getTypeUrl
             * @memberof lebai.kinematic.SaveTcpRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SaveTcpRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.kinematic.SaveTcpRequest";
            };

            return SaveTcpRequest;
        })();

        kinematic.CalcFrameRequest = (function() {

            /**
             * Properties of a CalcFrameRequest.
             * @memberof lebai.kinematic
             * @interface ICalcFrameRequest
             * @property {lebai.posture.ICartesianPose|null} [o] CalcFrameRequest o
             * @property {lebai.posture.ICartesianPose|null} [x] CalcFrameRequest x
             * @property {lebai.posture.ICartesianPose|null} [xy] CalcFrameRequest xy
             */

            /**
             * Constructs a new CalcFrameRequest.
             * @memberof lebai.kinematic
             * @classdesc Represents a CalcFrameRequest.
             * @implements ICalcFrameRequest
             * @constructor
             * @param {lebai.kinematic.ICalcFrameRequest=} [properties] Properties to set
             */
            function CalcFrameRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CalcFrameRequest o.
             * @member {lebai.posture.ICartesianPose|null|undefined} o
             * @memberof lebai.kinematic.CalcFrameRequest
             * @instance
             */
            CalcFrameRequest.prototype.o = null;

            /**
             * CalcFrameRequest x.
             * @member {lebai.posture.ICartesianPose|null|undefined} x
             * @memberof lebai.kinematic.CalcFrameRequest
             * @instance
             */
            CalcFrameRequest.prototype.x = null;

            /**
             * CalcFrameRequest xy.
             * @member {lebai.posture.ICartesianPose|null|undefined} xy
             * @memberof lebai.kinematic.CalcFrameRequest
             * @instance
             */
            CalcFrameRequest.prototype.xy = null;

            /**
             * Creates a new CalcFrameRequest instance using the specified properties.
             * @function create
             * @memberof lebai.kinematic.CalcFrameRequest
             * @static
             * @param {lebai.kinematic.ICalcFrameRequest=} [properties] Properties to set
             * @returns {lebai.kinematic.CalcFrameRequest} CalcFrameRequest instance
             */
            CalcFrameRequest.create = function create(properties) {
                return new CalcFrameRequest(properties);
            };

            /**
             * Encodes the specified CalcFrameRequest message. Does not implicitly {@link lebai.kinematic.CalcFrameRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.kinematic.CalcFrameRequest
             * @static
             * @param {lebai.kinematic.ICalcFrameRequest} message CalcFrameRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CalcFrameRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.o != null && Object.hasOwnProperty.call(message, "o"))
                    $root.lebai.posture.CartesianPose.encode(message.o, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                    $root.lebai.posture.CartesianPose.encode(message.x, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.xy != null && Object.hasOwnProperty.call(message, "xy"))
                    $root.lebai.posture.CartesianPose.encode(message.xy, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified CalcFrameRequest message, length delimited. Does not implicitly {@link lebai.kinematic.CalcFrameRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.kinematic.CalcFrameRequest
             * @static
             * @param {lebai.kinematic.ICalcFrameRequest} message CalcFrameRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CalcFrameRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CalcFrameRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.kinematic.CalcFrameRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.kinematic.CalcFrameRequest} CalcFrameRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CalcFrameRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.kinematic.CalcFrameRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.o = $root.lebai.posture.CartesianPose.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.x = $root.lebai.posture.CartesianPose.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            message.xy = $root.lebai.posture.CartesianPose.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CalcFrameRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.kinematic.CalcFrameRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.kinematic.CalcFrameRequest} CalcFrameRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CalcFrameRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CalcFrameRequest message.
             * @function verify
             * @memberof lebai.kinematic.CalcFrameRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CalcFrameRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.o != null && message.hasOwnProperty("o")) {
                    var error = $root.lebai.posture.CartesianPose.verify(message.o);
                    if (error)
                        return "o." + error;
                }
                if (message.x != null && message.hasOwnProperty("x")) {
                    var error = $root.lebai.posture.CartesianPose.verify(message.x);
                    if (error)
                        return "x." + error;
                }
                if (message.xy != null && message.hasOwnProperty("xy")) {
                    var error = $root.lebai.posture.CartesianPose.verify(message.xy);
                    if (error)
                        return "xy." + error;
                }
                return null;
            };

            /**
             * Creates a CalcFrameRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.kinematic.CalcFrameRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.kinematic.CalcFrameRequest} CalcFrameRequest
             */
            CalcFrameRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.kinematic.CalcFrameRequest)
                    return object;
                var message = new $root.lebai.kinematic.CalcFrameRequest();
                if (object.o != null) {
                    if (typeof object.o !== "object")
                        throw TypeError(".lebai.kinematic.CalcFrameRequest.o: object expected");
                    message.o = $root.lebai.posture.CartesianPose.fromObject(object.o);
                }
                if (object.x != null) {
                    if (typeof object.x !== "object")
                        throw TypeError(".lebai.kinematic.CalcFrameRequest.x: object expected");
                    message.x = $root.lebai.posture.CartesianPose.fromObject(object.x);
                }
                if (object.xy != null) {
                    if (typeof object.xy !== "object")
                        throw TypeError(".lebai.kinematic.CalcFrameRequest.xy: object expected");
                    message.xy = $root.lebai.posture.CartesianPose.fromObject(object.xy);
                }
                return message;
            };

            /**
             * Creates a plain object from a CalcFrameRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.kinematic.CalcFrameRequest
             * @static
             * @param {lebai.kinematic.CalcFrameRequest} message CalcFrameRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CalcFrameRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.o = null;
                    object.x = null;
                    object.xy = null;
                }
                if (message.o != null && message.hasOwnProperty("o"))
                    object.o = $root.lebai.posture.CartesianPose.toObject(message.o, options);
                if (message.x != null && message.hasOwnProperty("x"))
                    object.x = $root.lebai.posture.CartesianPose.toObject(message.x, options);
                if (message.xy != null && message.hasOwnProperty("xy"))
                    object.xy = $root.lebai.posture.CartesianPose.toObject(message.xy, options);
                return object;
            };

            /**
             * Converts this CalcFrameRequest to JSON.
             * @function toJSON
             * @memberof lebai.kinematic.CalcFrameRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CalcFrameRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for CalcFrameRequest
             * @function getTypeUrl
             * @memberof lebai.kinematic.CalcFrameRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            CalcFrameRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.kinematic.CalcFrameRequest";
            };

            return CalcFrameRequest;
        })();

        kinematic.CalcTcpRequest = (function() {

            /**
             * Properties of a CalcTcpRequest.
             * @memberof lebai.kinematic
             * @interface ICalcTcpRequest
             * @property {Array.<lebai.posture.ICartesianPose>|null} [poses] CalcTcpRequest poses
             */

            /**
             * Constructs a new CalcTcpRequest.
             * @memberof lebai.kinematic
             * @classdesc Represents a CalcTcpRequest.
             * @implements ICalcTcpRequest
             * @constructor
             * @param {lebai.kinematic.ICalcTcpRequest=} [properties] Properties to set
             */
            function CalcTcpRequest(properties) {
                this.poses = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CalcTcpRequest poses.
             * @member {Array.<lebai.posture.ICartesianPose>} poses
             * @memberof lebai.kinematic.CalcTcpRequest
             * @instance
             */
            CalcTcpRequest.prototype.poses = $util.emptyArray;

            /**
             * Creates a new CalcTcpRequest instance using the specified properties.
             * @function create
             * @memberof lebai.kinematic.CalcTcpRequest
             * @static
             * @param {lebai.kinematic.ICalcTcpRequest=} [properties] Properties to set
             * @returns {lebai.kinematic.CalcTcpRequest} CalcTcpRequest instance
             */
            CalcTcpRequest.create = function create(properties) {
                return new CalcTcpRequest(properties);
            };

            /**
             * Encodes the specified CalcTcpRequest message. Does not implicitly {@link lebai.kinematic.CalcTcpRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.kinematic.CalcTcpRequest
             * @static
             * @param {lebai.kinematic.ICalcTcpRequest} message CalcTcpRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CalcTcpRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.poses != null && message.poses.length)
                    for (var i = 0; i < message.poses.length; ++i)
                        $root.lebai.posture.CartesianPose.encode(message.poses[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified CalcTcpRequest message, length delimited. Does not implicitly {@link lebai.kinematic.CalcTcpRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.kinematic.CalcTcpRequest
             * @static
             * @param {lebai.kinematic.ICalcTcpRequest} message CalcTcpRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CalcTcpRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CalcTcpRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.kinematic.CalcTcpRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.kinematic.CalcTcpRequest} CalcTcpRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CalcTcpRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.kinematic.CalcTcpRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.poses && message.poses.length))
                                message.poses = [];
                            message.poses.push($root.lebai.posture.CartesianPose.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CalcTcpRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.kinematic.CalcTcpRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.kinematic.CalcTcpRequest} CalcTcpRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CalcTcpRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CalcTcpRequest message.
             * @function verify
             * @memberof lebai.kinematic.CalcTcpRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CalcTcpRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.poses != null && message.hasOwnProperty("poses")) {
                    if (!Array.isArray(message.poses))
                        return "poses: array expected";
                    for (var i = 0; i < message.poses.length; ++i) {
                        var error = $root.lebai.posture.CartesianPose.verify(message.poses[i]);
                        if (error)
                            return "poses." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a CalcTcpRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.kinematic.CalcTcpRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.kinematic.CalcTcpRequest} CalcTcpRequest
             */
            CalcTcpRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.kinematic.CalcTcpRequest)
                    return object;
                var message = new $root.lebai.kinematic.CalcTcpRequest();
                if (object.poses) {
                    if (!Array.isArray(object.poses))
                        throw TypeError(".lebai.kinematic.CalcTcpRequest.poses: array expected");
                    message.poses = [];
                    for (var i = 0; i < object.poses.length; ++i) {
                        if (typeof object.poses[i] !== "object")
                            throw TypeError(".lebai.kinematic.CalcTcpRequest.poses: object expected");
                        message.poses[i] = $root.lebai.posture.CartesianPose.fromObject(object.poses[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a CalcTcpRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.kinematic.CalcTcpRequest
             * @static
             * @param {lebai.kinematic.CalcTcpRequest} message CalcTcpRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CalcTcpRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.poses = [];
                if (message.poses && message.poses.length) {
                    object.poses = [];
                    for (var j = 0; j < message.poses.length; ++j)
                        object.poses[j] = $root.lebai.posture.CartesianPose.toObject(message.poses[j], options);
                }
                return object;
            };

            /**
             * Converts this CalcTcpRequest to JSON.
             * @function toJSON
             * @memberof lebai.kinematic.CalcTcpRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CalcTcpRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for CalcTcpRequest
             * @function getTypeUrl
             * @memberof lebai.kinematic.CalcTcpRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            CalcTcpRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.kinematic.CalcTcpRequest";
            };

            return CalcTcpRequest;
        })();

        kinematic.KinematicService = (function() {

            /**
             * Constructs a new KinematicService service.
             * @memberof lebai.kinematic
             * @classdesc Represents a KinematicService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function KinematicService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (KinematicService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = KinematicService;

            /**
             * Creates new KinematicService service using the specified rpc implementation.
             * @function create
             * @memberof lebai.kinematic.KinematicService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {KinematicService} RPC service. Useful where requests and/or responses are streamed.
             */
            KinematicService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link lebai.kinematic.KinematicService#saveTcp}.
             * @memberof lebai.kinematic.KinematicService
             * @typedef SaveTcpCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls SaveTcp.
             * @function saveTcp
             * @memberof lebai.kinematic.KinematicService
             * @instance
             * @param {lebai.kinematic.ISaveTcpRequest} request SaveTcpRequest message or plain object
             * @param {lebai.kinematic.KinematicService.SaveTcpCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(KinematicService.prototype.saveTcp = function saveTcp(request, callback) {
                return this.rpcCall(saveTcp, $root.lebai.kinematic.SaveTcpRequest, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "SaveTcp" });

            /**
             * Calls SaveTcp.
             * @function saveTcp
             * @memberof lebai.kinematic.KinematicService
             * @instance
             * @param {lebai.kinematic.ISaveTcpRequest} request SaveTcpRequest message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.kinematic.KinematicService#loadTcp}.
             * @memberof lebai.kinematic.KinematicService
             * @typedef LoadTcpCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.posture.CartesianPose} [response] CartesianPose
             */

            /**
             * Calls LoadTcp.
             * @function loadTcp
             * @memberof lebai.kinematic.KinematicService
             * @instance
             * @param {lebai.db.ILoadRequest} request LoadRequest message or plain object
             * @param {lebai.kinematic.KinematicService.LoadTcpCallback} callback Node-style callback called with the error, if any, and CartesianPose
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(KinematicService.prototype.loadTcp = function loadTcp(request, callback) {
                return this.rpcCall(loadTcp, $root.lebai.db.LoadRequest, $root.lebai.posture.CartesianPose, request, callback);
            }, "name", { value: "LoadTcp" });

            /**
             * Calls LoadTcp.
             * @function loadTcp
             * @memberof lebai.kinematic.KinematicService
             * @instance
             * @param {lebai.db.ILoadRequest} request LoadRequest message or plain object
             * @returns {Promise<lebai.posture.CartesianPose>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.kinematic.KinematicService#loadTcpList}.
             * @memberof lebai.kinematic.KinematicService
             * @typedef LoadTcpListCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.db.LoadListResponse} [response] LoadListResponse
             */

            /**
             * Calls LoadTcpList.
             * @function loadTcpList
             * @memberof lebai.kinematic.KinematicService
             * @instance
             * @param {lebai.db.ILoadListRequest} request LoadListRequest message or plain object
             * @param {lebai.kinematic.KinematicService.LoadTcpListCallback} callback Node-style callback called with the error, if any, and LoadListResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(KinematicService.prototype.loadTcpList = function loadTcpList(request, callback) {
                return this.rpcCall(loadTcpList, $root.lebai.db.LoadListRequest, $root.lebai.db.LoadListResponse, request, callback);
            }, "name", { value: "LoadTcpList" });

            /**
             * Calls LoadTcpList.
             * @function loadTcpList
             * @memberof lebai.kinematic.KinematicService
             * @instance
             * @param {lebai.db.ILoadListRequest} request LoadListRequest message or plain object
             * @returns {Promise<lebai.db.LoadListResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.kinematic.KinematicService#setDh}.
             * @memberof lebai.kinematic.KinematicService
             * @typedef SetDhCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls SetDh.
             * @function setDh
             * @memberof lebai.kinematic.KinematicService
             * @instance
             * @param {lebai.kinematic.IDhParams} request DhParams message or plain object
             * @param {lebai.kinematic.KinematicService.SetDhCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(KinematicService.prototype.setDh = function setDh(request, callback) {
                return this.rpcCall(setDh, $root.lebai.kinematic.DhParams, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "SetDh" });

            /**
             * Calls SetDh.
             * @function setDh
             * @memberof lebai.kinematic.KinematicService
             * @instance
             * @param {lebai.kinematic.IDhParams} request DhParams message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.kinematic.KinematicService#getDh}.
             * @memberof lebai.kinematic.KinematicService
             * @typedef GetDhCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.kinematic.DhParams} [response] DhParams
             */

            /**
             * Calls GetDh.
             * @function getDh
             * @memberof lebai.kinematic.KinematicService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {lebai.kinematic.KinematicService.GetDhCallback} callback Node-style callback called with the error, if any, and DhParams
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(KinematicService.prototype.getDh = function getDh(request, callback) {
                return this.rpcCall(getDh, $root.google.protobuf.Empty, $root.lebai.kinematic.DhParams, request, callback);
            }, "name", { value: "GetDh" });

            /**
             * Calls GetDh.
             * @function getDh
             * @memberof lebai.kinematic.KinematicService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<lebai.kinematic.DhParams>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.kinematic.KinematicService#setKinFactor}.
             * @memberof lebai.kinematic.KinematicService
             * @typedef SetKinFactorCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls SetKinFactor.
             * @function setKinFactor
             * @memberof lebai.kinematic.KinematicService
             * @instance
             * @param {lebai.kinematic.IKinFactor} request KinFactor message or plain object
             * @param {lebai.kinematic.KinematicService.SetKinFactorCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(KinematicService.prototype.setKinFactor = function setKinFactor(request, callback) {
                return this.rpcCall(setKinFactor, $root.lebai.kinematic.KinFactor, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "SetKinFactor" });

            /**
             * Calls SetKinFactor.
             * @function setKinFactor
             * @memberof lebai.kinematic.KinematicService
             * @instance
             * @param {lebai.kinematic.IKinFactor} request KinFactor message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.kinematic.KinematicService#getKinFactor}.
             * @memberof lebai.kinematic.KinematicService
             * @typedef GetKinFactorCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.kinematic.KinFactor} [response] KinFactor
             */

            /**
             * Calls GetKinFactor.
             * @function getKinFactor
             * @memberof lebai.kinematic.KinematicService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {lebai.kinematic.KinematicService.GetKinFactorCallback} callback Node-style callback called with the error, if any, and KinFactor
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(KinematicService.prototype.getKinFactor = function getKinFactor(request, callback) {
                return this.rpcCall(getKinFactor, $root.google.protobuf.Empty, $root.lebai.kinematic.KinFactor, request, callback);
            }, "name", { value: "GetKinFactor" });

            /**
             * Calls GetKinFactor.
             * @function getKinFactor
             * @memberof lebai.kinematic.KinematicService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<lebai.kinematic.KinFactor>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.kinematic.KinematicService#getKinData}.
             * @memberof lebai.kinematic.KinematicService
             * @typedef GetKinDataCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.kinematic.KinData} [response] KinData
             */

            /**
             * Calls GetKinData.
             * @function getKinData
             * @memberof lebai.kinematic.KinematicService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {lebai.kinematic.KinematicService.GetKinDataCallback} callback Node-style callback called with the error, if any, and KinData
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(KinematicService.prototype.getKinData = function getKinData(request, callback) {
                return this.rpcCall(getKinData, $root.google.protobuf.Empty, $root.lebai.kinematic.KinData, request, callback);
            }, "name", { value: "GetKinData" });

            /**
             * Calls GetKinData.
             * @function getKinData
             * @memberof lebai.kinematic.KinematicService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<lebai.kinematic.KinData>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.kinematic.KinematicService#subKinData}.
             * @memberof lebai.kinematic.KinematicService
             * @typedef SubKinDataCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.kinematic.KinData} [response] KinData
             */

            /**
             * Calls SubKinData.
             * @function subKinData
             * @memberof lebai.kinematic.KinematicService
             * @instance
             * @param {lebai.ISubscribeRequest} request SubscribeRequest message or plain object
             * @param {lebai.kinematic.KinematicService.SubKinDataCallback} callback Node-style callback called with the error, if any, and KinData
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(KinematicService.prototype.subKinData = function subKinData(request, callback) {
                return this.rpcCall(subKinData, $root.lebai.SubscribeRequest, $root.lebai.kinematic.KinData, request, callback);
            }, "name", { value: "SubKinData" });

            /**
             * Calls SubKinData.
             * @function subKinData
             * @memberof lebai.kinematic.KinematicService
             * @instance
             * @param {lebai.ISubscribeRequest} request SubscribeRequest message or plain object
             * @returns {Promise<lebai.kinematic.KinData>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.kinematic.KinematicService#calcFrame}.
             * @memberof lebai.kinematic.KinematicService
             * @typedef CalcFrameCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.posture.CartesianPose} [response] CartesianPose
             */

            /**
             * Calls CalcFrame.
             * @function calcFrame
             * @memberof lebai.kinematic.KinematicService
             * @instance
             * @param {lebai.kinematic.ICalcFrameRequest} request CalcFrameRequest message or plain object
             * @param {lebai.kinematic.KinematicService.CalcFrameCallback} callback Node-style callback called with the error, if any, and CartesianPose
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(KinematicService.prototype.calcFrame = function calcFrame(request, callback) {
                return this.rpcCall(calcFrame, $root.lebai.kinematic.CalcFrameRequest, $root.lebai.posture.CartesianPose, request, callback);
            }, "name", { value: "CalcFrame" });

            /**
             * Calls CalcFrame.
             * @function calcFrame
             * @memberof lebai.kinematic.KinematicService
             * @instance
             * @param {lebai.kinematic.ICalcFrameRequest} request CalcFrameRequest message or plain object
             * @returns {Promise<lebai.posture.CartesianPose>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.kinematic.KinematicService#calcTcp}.
             * @memberof lebai.kinematic.KinematicService
             * @typedef CalcTcpCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.posture.CartesianPose} [response] CartesianPose
             */

            /**
             * Calls CalcTcp.
             * @function calcTcp
             * @memberof lebai.kinematic.KinematicService
             * @instance
             * @param {lebai.kinematic.ICalcTcpRequest} request CalcTcpRequest message or plain object
             * @param {lebai.kinematic.KinematicService.CalcTcpCallback} callback Node-style callback called with the error, if any, and CartesianPose
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(KinematicService.prototype.calcTcp = function calcTcp(request, callback) {
                return this.rpcCall(calcTcp, $root.lebai.kinematic.CalcTcpRequest, $root.lebai.posture.CartesianPose, request, callback);
            }, "name", { value: "CalcTcp" });

            /**
             * Calls CalcTcp.
             * @function calcTcp
             * @memberof lebai.kinematic.KinematicService
             * @instance
             * @param {lebai.kinematic.ICalcTcpRequest} request CalcTcpRequest message or plain object
             * @returns {Promise<lebai.posture.CartesianPose>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.kinematic.KinematicService#setTcp}.
             * @memberof lebai.kinematic.KinematicService
             * @typedef SetTcpCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls SetTcp.
             * @function setTcp
             * @memberof lebai.kinematic.KinematicService
             * @instance
             * @param {lebai.posture.ICartesianPose} request CartesianPose message or plain object
             * @param {lebai.kinematic.KinematicService.SetTcpCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(KinematicService.prototype.setTcp = function setTcp(request, callback) {
                return this.rpcCall(setTcp, $root.lebai.posture.CartesianPose, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "SetTcp" });

            /**
             * Calls SetTcp.
             * @function setTcp
             * @memberof lebai.kinematic.KinematicService
             * @instance
             * @param {lebai.posture.ICartesianPose} request CartesianPose message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.kinematic.KinematicService#getTcp}.
             * @memberof lebai.kinematic.KinematicService
             * @typedef GetTcpCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.posture.CartesianPose} [response] CartesianPose
             */

            /**
             * Calls GetTcp.
             * @function getTcp
             * @memberof lebai.kinematic.KinematicService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {lebai.kinematic.KinematicService.GetTcpCallback} callback Node-style callback called with the error, if any, and CartesianPose
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(KinematicService.prototype.getTcp = function getTcp(request, callback) {
                return this.rpcCall(getTcp, $root.google.protobuf.Empty, $root.lebai.posture.CartesianPose, request, callback);
            }, "name", { value: "GetTcp" });

            /**
             * Calls GetTcp.
             * @function getTcp
             * @memberof lebai.kinematic.KinematicService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<lebai.posture.CartesianPose>} Promise
             * @variation 2
             */

            return KinematicService;
        })();

        return kinematic;
    })();

    lebai.led = (function() {

        /**
         * Namespace led.
         * @memberof lebai
         * @namespace
         */
        var led = {};

        /**
         * LedMode enum.
         * @name lebai.led.LedMode
         * @enum {number}
         * @property {number} HOLD_LED=0 HOLD_LED value
         * @property {number} CLOSE_LED=1 CLOSE_LED value
         * @property {number} OPEN_LED=2 OPEN_LED value
         * @property {number} BREATH=3 BREATH value
         * @property {number} FOUR=4 FOUR value
         * @property {number} WATER=5 WATER value
         * @property {number} BLINK=6 BLINK value
         */
        led.LedMode = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "HOLD_LED"] = 0;
            values[valuesById[1] = "CLOSE_LED"] = 1;
            values[valuesById[2] = "OPEN_LED"] = 2;
            values[valuesById[3] = "BREATH"] = 3;
            values[valuesById[4] = "FOUR"] = 4;
            values[valuesById[5] = "WATER"] = 5;
            values[valuesById[6] = "BLINK"] = 6;
            return values;
        })();

        /**
         * LedSpeed enum.
         * @name lebai.led.LedSpeed
         * @enum {number}
         * @property {number} HOLD_LED_SPEED=0 HOLD_LED_SPEED value
         * @property {number} FAST=1 FAST value
         * @property {number} NORMAL=2 NORMAL value
         * @property {number} SLOW=3 SLOW value
         */
        led.LedSpeed = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "HOLD_LED_SPEED"] = 0;
            values[valuesById[1] = "FAST"] = 1;
            values[valuesById[2] = "NORMAL"] = 2;
            values[valuesById[3] = "SLOW"] = 3;
            return values;
        })();

        /**
         * LedColor enum.
         * @name lebai.led.LedColor
         * @enum {number}
         * @property {number} RED=0 RED value
         * @property {number} GREEN=1 GREEN value
         * @property {number} BLUE=2 BLUE value
         * @property {number} PINK=3 PINK value
         * @property {number} YELLOW=4 YELLOW value
         * @property {number} CYAN=5 CYAN value
         * @property {number} GRAY=6 GRAY value
         * @property {number} BROWN=7 BROWN value
         * @property {number} ORANGE=8 ORANGE value
         * @property {number} GOLD=9 GOLD value
         * @property {number} INDIGO=10 INDIGO value
         * @property {number} LIGHT_SKY_BLUE=11 LIGHT_SKY_BLUE value
         * @property {number} DARK_VIOLET=12 DARK_VIOLET value
         * @property {number} CHOCOLATE=13 CHOCOLATE value
         * @property {number} LIGHT_RED=14 LIGHT_RED value
         * @property {number} WHITE=15 WHITE value
         */
        led.LedColor = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "RED"] = 0;
            values[valuesById[1] = "GREEN"] = 1;
            values[valuesById[2] = "BLUE"] = 2;
            values[valuesById[3] = "PINK"] = 3;
            values[valuesById[4] = "YELLOW"] = 4;
            values[valuesById[5] = "CYAN"] = 5;
            values[valuesById[6] = "GRAY"] = 6;
            values[valuesById[7] = "BROWN"] = 7;
            values[valuesById[8] = "ORANGE"] = 8;
            values[valuesById[9] = "GOLD"] = 9;
            values[valuesById[10] = "INDIGO"] = 10;
            values[valuesById[11] = "LIGHT_SKY_BLUE"] = 11;
            values[valuesById[12] = "DARK_VIOLET"] = 12;
            values[valuesById[13] = "CHOCOLATE"] = 13;
            values[valuesById[14] = "LIGHT_RED"] = 14;
            values[valuesById[15] = "WHITE"] = 15;
            return values;
        })();

        led.LedData = (function() {

            /**
             * Properties of a LedData.
             * @memberof lebai.led
             * @interface ILedData
             * @property {lebai.led.LedMode|null} [mode] LedData mode
             * @property {lebai.led.LedSpeed|null} [speed] LedData speed
             * @property {Array.<lebai.led.LedColor>|null} [colors] LedData colors
             */

            /**
             * Constructs a new LedData.
             * @memberof lebai.led
             * @classdesc Represents a LedData.
             * @implements ILedData
             * @constructor
             * @param {lebai.led.ILedData=} [properties] Properties to set
             */
            function LedData(properties) {
                this.colors = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LedData mode.
             * @member {lebai.led.LedMode} mode
             * @memberof lebai.led.LedData
             * @instance
             */
            LedData.prototype.mode = 0;

            /**
             * LedData speed.
             * @member {lebai.led.LedSpeed} speed
             * @memberof lebai.led.LedData
             * @instance
             */
            LedData.prototype.speed = 0;

            /**
             * LedData colors.
             * @member {Array.<lebai.led.LedColor>} colors
             * @memberof lebai.led.LedData
             * @instance
             */
            LedData.prototype.colors = $util.emptyArray;

            /**
             * Creates a new LedData instance using the specified properties.
             * @function create
             * @memberof lebai.led.LedData
             * @static
             * @param {lebai.led.ILedData=} [properties] Properties to set
             * @returns {lebai.led.LedData} LedData instance
             */
            LedData.create = function create(properties) {
                return new LedData(properties);
            };

            /**
             * Encodes the specified LedData message. Does not implicitly {@link lebai.led.LedData.verify|verify} messages.
             * @function encode
             * @memberof lebai.led.LedData
             * @static
             * @param {lebai.led.ILedData} message LedData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LedData.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.mode != null && Object.hasOwnProperty.call(message, "mode"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.mode);
                if (message.speed != null && Object.hasOwnProperty.call(message, "speed"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.speed);
                if (message.colors != null && message.colors.length) {
                    writer.uint32(/* id 3, wireType 2 =*/26).fork();
                    for (var i = 0; i < message.colors.length; ++i)
                        writer.int32(message.colors[i]);
                    writer.ldelim();
                }
                return writer;
            };

            /**
             * Encodes the specified LedData message, length delimited. Does not implicitly {@link lebai.led.LedData.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.led.LedData
             * @static
             * @param {lebai.led.ILedData} message LedData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LedData.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LedData message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.led.LedData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.led.LedData} LedData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LedData.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.led.LedData();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.mode = reader.int32();
                            break;
                        }
                    case 2: {
                            message.speed = reader.int32();
                            break;
                        }
                    case 3: {
                            if (!(message.colors && message.colors.length))
                                message.colors = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.colors.push(reader.int32());
                            } else
                                message.colors.push(reader.int32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LedData message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.led.LedData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.led.LedData} LedData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LedData.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LedData message.
             * @function verify
             * @memberof lebai.led.LedData
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LedData.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.mode != null && message.hasOwnProperty("mode"))
                    switch (message.mode) {
                    default:
                        return "mode: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                        break;
                    }
                if (message.speed != null && message.hasOwnProperty("speed"))
                    switch (message.speed) {
                    default:
                        return "speed: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.colors != null && message.hasOwnProperty("colors")) {
                    if (!Array.isArray(message.colors))
                        return "colors: array expected";
                    for (var i = 0; i < message.colors.length; ++i)
                        switch (message.colors[i]) {
                        default:
                            return "colors: enum value[] expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                        case 9:
                        case 10:
                        case 11:
                        case 12:
                        case 13:
                        case 14:
                        case 15:
                            break;
                        }
                }
                return null;
            };

            /**
             * Creates a LedData message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.led.LedData
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.led.LedData} LedData
             */
            LedData.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.led.LedData)
                    return object;
                var message = new $root.lebai.led.LedData();
                switch (object.mode) {
                default:
                    if (typeof object.mode === "number") {
                        message.mode = object.mode;
                        break;
                    }
                    break;
                case "HOLD_LED":
                case 0:
                    message.mode = 0;
                    break;
                case "CLOSE_LED":
                case 1:
                    message.mode = 1;
                    break;
                case "OPEN_LED":
                case 2:
                    message.mode = 2;
                    break;
                case "BREATH":
                case 3:
                    message.mode = 3;
                    break;
                case "FOUR":
                case 4:
                    message.mode = 4;
                    break;
                case "WATER":
                case 5:
                    message.mode = 5;
                    break;
                case "BLINK":
                case 6:
                    message.mode = 6;
                    break;
                }
                switch (object.speed) {
                default:
                    if (typeof object.speed === "number") {
                        message.speed = object.speed;
                        break;
                    }
                    break;
                case "HOLD_LED_SPEED":
                case 0:
                    message.speed = 0;
                    break;
                case "FAST":
                case 1:
                    message.speed = 1;
                    break;
                case "NORMAL":
                case 2:
                    message.speed = 2;
                    break;
                case "SLOW":
                case 3:
                    message.speed = 3;
                    break;
                }
                if (object.colors) {
                    if (!Array.isArray(object.colors))
                        throw TypeError(".lebai.led.LedData.colors: array expected");
                    message.colors = [];
                    for (var i = 0; i < object.colors.length; ++i)
                        switch (object.colors[i]) {
                        default:
                            if (typeof object.colors[i] === "number") {
                                message.colors[i] = object.colors[i];
                                break;
                            }
                        case "RED":
                        case 0:
                            message.colors[i] = 0;
                            break;
                        case "GREEN":
                        case 1:
                            message.colors[i] = 1;
                            break;
                        case "BLUE":
                        case 2:
                            message.colors[i] = 2;
                            break;
                        case "PINK":
                        case 3:
                            message.colors[i] = 3;
                            break;
                        case "YELLOW":
                        case 4:
                            message.colors[i] = 4;
                            break;
                        case "CYAN":
                        case 5:
                            message.colors[i] = 5;
                            break;
                        case "GRAY":
                        case 6:
                            message.colors[i] = 6;
                            break;
                        case "BROWN":
                        case 7:
                            message.colors[i] = 7;
                            break;
                        case "ORANGE":
                        case 8:
                            message.colors[i] = 8;
                            break;
                        case "GOLD":
                        case 9:
                            message.colors[i] = 9;
                            break;
                        case "INDIGO":
                        case 10:
                            message.colors[i] = 10;
                            break;
                        case "LIGHT_SKY_BLUE":
                        case 11:
                            message.colors[i] = 11;
                            break;
                        case "DARK_VIOLET":
                        case 12:
                            message.colors[i] = 12;
                            break;
                        case "CHOCOLATE":
                        case 13:
                            message.colors[i] = 13;
                            break;
                        case "LIGHT_RED":
                        case 14:
                            message.colors[i] = 14;
                            break;
                        case "WHITE":
                        case 15:
                            message.colors[i] = 15;
                            break;
                        }
                }
                return message;
            };

            /**
             * Creates a plain object from a LedData message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.led.LedData
             * @static
             * @param {lebai.led.LedData} message LedData
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LedData.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.colors = [];
                if (options.defaults) {
                    object.mode = options.enums === String ? "HOLD_LED" : 0;
                    object.speed = options.enums === String ? "HOLD_LED_SPEED" : 0;
                }
                if (message.mode != null && message.hasOwnProperty("mode"))
                    object.mode = options.enums === String ? $root.lebai.led.LedMode[message.mode] === undefined ? message.mode : $root.lebai.led.LedMode[message.mode] : message.mode;
                if (message.speed != null && message.hasOwnProperty("speed"))
                    object.speed = options.enums === String ? $root.lebai.led.LedSpeed[message.speed] === undefined ? message.speed : $root.lebai.led.LedSpeed[message.speed] : message.speed;
                if (message.colors && message.colors.length) {
                    object.colors = [];
                    for (var j = 0; j < message.colors.length; ++j)
                        object.colors[j] = options.enums === String ? $root.lebai.led.LedColor[message.colors[j]] === undefined ? message.colors[j] : $root.lebai.led.LedColor[message.colors[j]] : message.colors[j];
                }
                return object;
            };

            /**
             * Converts this LedData to JSON.
             * @function toJSON
             * @memberof lebai.led.LedData
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LedData.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for LedData
             * @function getTypeUrl
             * @memberof lebai.led.LedData
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            LedData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.led.LedData";
            };

            return LedData;
        })();

        /**
         * FanMode enum.
         * @name lebai.led.FanMode
         * @enum {number}
         * @property {number} HOLD_FAN=0 HOLD_FAN value
         * @property {number} CLOSE_FAN=1 CLOSE_FAN value
         * @property {number} OPEN_FAN=2 OPEN_FAN value
         */
        led.FanMode = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "HOLD_FAN"] = 0;
            values[valuesById[1] = "CLOSE_FAN"] = 1;
            values[valuesById[2] = "OPEN_FAN"] = 2;
            return values;
        })();

        led.FanData = (function() {

            /**
             * Properties of a FanData.
             * @memberof lebai.led
             * @interface IFanData
             * @property {lebai.led.FanMode|null} [mode] FanData mode
             */

            /**
             * Constructs a new FanData.
             * @memberof lebai.led
             * @classdesc Represents a FanData.
             * @implements IFanData
             * @constructor
             * @param {lebai.led.IFanData=} [properties] Properties to set
             */
            function FanData(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FanData mode.
             * @member {lebai.led.FanMode} mode
             * @memberof lebai.led.FanData
             * @instance
             */
            FanData.prototype.mode = 0;

            /**
             * Creates a new FanData instance using the specified properties.
             * @function create
             * @memberof lebai.led.FanData
             * @static
             * @param {lebai.led.IFanData=} [properties] Properties to set
             * @returns {lebai.led.FanData} FanData instance
             */
            FanData.create = function create(properties) {
                return new FanData(properties);
            };

            /**
             * Encodes the specified FanData message. Does not implicitly {@link lebai.led.FanData.verify|verify} messages.
             * @function encode
             * @memberof lebai.led.FanData
             * @static
             * @param {lebai.led.IFanData} message FanData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FanData.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.mode != null && Object.hasOwnProperty.call(message, "mode"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.mode);
                return writer;
            };

            /**
             * Encodes the specified FanData message, length delimited. Does not implicitly {@link lebai.led.FanData.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.led.FanData
             * @static
             * @param {lebai.led.IFanData} message FanData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FanData.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FanData message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.led.FanData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.led.FanData} FanData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FanData.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.led.FanData();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.mode = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FanData message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.led.FanData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.led.FanData} FanData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FanData.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FanData message.
             * @function verify
             * @memberof lebai.led.FanData
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FanData.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.mode != null && message.hasOwnProperty("mode"))
                    switch (message.mode) {
                    default:
                        return "mode: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                return null;
            };

            /**
             * Creates a FanData message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.led.FanData
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.led.FanData} FanData
             */
            FanData.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.led.FanData)
                    return object;
                var message = new $root.lebai.led.FanData();
                switch (object.mode) {
                default:
                    if (typeof object.mode === "number") {
                        message.mode = object.mode;
                        break;
                    }
                    break;
                case "HOLD_FAN":
                case 0:
                    message.mode = 0;
                    break;
                case "CLOSE_FAN":
                case 1:
                    message.mode = 1;
                    break;
                case "OPEN_FAN":
                case 2:
                    message.mode = 2;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a FanData message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.led.FanData
             * @static
             * @param {lebai.led.FanData} message FanData
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FanData.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.mode = options.enums === String ? "HOLD_FAN" : 0;
                if (message.mode != null && message.hasOwnProperty("mode"))
                    object.mode = options.enums === String ? $root.lebai.led.FanMode[message.mode] === undefined ? message.mode : $root.lebai.led.FanMode[message.mode] : message.mode;
                return object;
            };

            /**
             * Converts this FanData to JSON.
             * @function toJSON
             * @memberof lebai.led.FanData
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FanData.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for FanData
             * @function getTypeUrl
             * @memberof lebai.led.FanData
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            FanData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.led.FanData";
            };

            return FanData;
        })();

        /**
         * VoiceKind enum.
         * @name lebai.led.VoiceKind
         * @enum {number}
         * @property {number} OFF=0 OFF value
         * @property {number} BOOTING=1 BOOTING value
         * @property {number} STOPING=2 STOPING value
         * @property {number} COLLISION_DETECTED=3 COLLISION_DETECTED value
         * @property {number} UPGRADE=4 UPGRADE value
         * @property {number} TEACH_MODE_ON=5 TEACH_MODE_ON value
         * @property {number} TEACH_MODE_OFF=6 TEACH_MODE_OFF value
         * @property {number} FINE_TUNNING_ON=7 FINE_TUNNING_ON value
         * @property {number} FINE_TUNNING_OFF=8 FINE_TUNNING_OFF value
         * @property {number} FINE_TUNNING_CHANGE=9 FINE_TUNNING_CHANGE value
         * @property {number} BORING=10 BORING value
         * @property {number} CUSTOM1=11 CUSTOM1 value
         * @property {number} CUSTOM2=12 CUSTOM2 value
         * @property {number} CUSTOM3=13 CUSTOM3 value
         * @property {number} CUSTOM4=14 CUSTOM4 value
         * @property {number} CUSTOM5=15 CUSTOM5 value
         */
        led.VoiceKind = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "OFF"] = 0;
            values[valuesById[1] = "BOOTING"] = 1;
            values[valuesById[2] = "STOPING"] = 2;
            values[valuesById[3] = "COLLISION_DETECTED"] = 3;
            values[valuesById[4] = "UPGRADE"] = 4;
            values[valuesById[5] = "TEACH_MODE_ON"] = 5;
            values[valuesById[6] = "TEACH_MODE_OFF"] = 6;
            values[valuesById[7] = "FINE_TUNNING_ON"] = 7;
            values[valuesById[8] = "FINE_TUNNING_OFF"] = 8;
            values[valuesById[9] = "FINE_TUNNING_CHANGE"] = 9;
            values[valuesById[10] = "BORING"] = 10;
            values[valuesById[11] = "CUSTOM1"] = 11;
            values[valuesById[12] = "CUSTOM2"] = 12;
            values[valuesById[13] = "CUSTOM3"] = 13;
            values[valuesById[14] = "CUSTOM4"] = 14;
            values[valuesById[15] = "CUSTOM5"] = 15;
            return values;
        })();

        /**
         * Volume enum.
         * @name lebai.led.Volume
         * @enum {number}
         * @property {number} MUTE=0 MUTE value
         * @property {number} LOW=1 LOW value
         * @property {number} MID=2 MID value
         * @property {number} HIGH=3 HIGH value
         */
        led.Volume = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "MUTE"] = 0;
            values[valuesById[1] = "LOW"] = 1;
            values[valuesById[2] = "MID"] = 2;
            values[valuesById[3] = "HIGH"] = 3;
            return values;
        })();

        led.VoiceData = (function() {

            /**
             * Properties of a VoiceData.
             * @memberof lebai.led
             * @interface IVoiceData
             * @property {lebai.led.VoiceKind|null} [voice] VoiceData voice
             * @property {lebai.led.Volume|null} [volume] VoiceData volume
             */

            /**
             * Constructs a new VoiceData.
             * @memberof lebai.led
             * @classdesc Represents a VoiceData.
             * @implements IVoiceData
             * @constructor
             * @param {lebai.led.IVoiceData=} [properties] Properties to set
             */
            function VoiceData(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * VoiceData voice.
             * @member {lebai.led.VoiceKind} voice
             * @memberof lebai.led.VoiceData
             * @instance
             */
            VoiceData.prototype.voice = 0;

            /**
             * VoiceData volume.
             * @member {lebai.led.Volume} volume
             * @memberof lebai.led.VoiceData
             * @instance
             */
            VoiceData.prototype.volume = 0;

            /**
             * Creates a new VoiceData instance using the specified properties.
             * @function create
             * @memberof lebai.led.VoiceData
             * @static
             * @param {lebai.led.IVoiceData=} [properties] Properties to set
             * @returns {lebai.led.VoiceData} VoiceData instance
             */
            VoiceData.create = function create(properties) {
                return new VoiceData(properties);
            };

            /**
             * Encodes the specified VoiceData message. Does not implicitly {@link lebai.led.VoiceData.verify|verify} messages.
             * @function encode
             * @memberof lebai.led.VoiceData
             * @static
             * @param {lebai.led.IVoiceData} message VoiceData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VoiceData.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.voice != null && Object.hasOwnProperty.call(message, "voice"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.voice);
                if (message.volume != null && Object.hasOwnProperty.call(message, "volume"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.volume);
                return writer;
            };

            /**
             * Encodes the specified VoiceData message, length delimited. Does not implicitly {@link lebai.led.VoiceData.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.led.VoiceData
             * @static
             * @param {lebai.led.IVoiceData} message VoiceData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VoiceData.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a VoiceData message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.led.VoiceData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.led.VoiceData} VoiceData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VoiceData.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.led.VoiceData();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2: {
                            message.voice = reader.int32();
                            break;
                        }
                    case 3: {
                            message.volume = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a VoiceData message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.led.VoiceData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.led.VoiceData} VoiceData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VoiceData.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a VoiceData message.
             * @function verify
             * @memberof lebai.led.VoiceData
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            VoiceData.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.voice != null && message.hasOwnProperty("voice"))
                    switch (message.voice) {
                    default:
                        return "voice: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                        break;
                    }
                if (message.volume != null && message.hasOwnProperty("volume"))
                    switch (message.volume) {
                    default:
                        return "volume: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                return null;
            };

            /**
             * Creates a VoiceData message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.led.VoiceData
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.led.VoiceData} VoiceData
             */
            VoiceData.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.led.VoiceData)
                    return object;
                var message = new $root.lebai.led.VoiceData();
                switch (object.voice) {
                default:
                    if (typeof object.voice === "number") {
                        message.voice = object.voice;
                        break;
                    }
                    break;
                case "OFF":
                case 0:
                    message.voice = 0;
                    break;
                case "BOOTING":
                case 1:
                    message.voice = 1;
                    break;
                case "STOPING":
                case 2:
                    message.voice = 2;
                    break;
                case "COLLISION_DETECTED":
                case 3:
                    message.voice = 3;
                    break;
                case "UPGRADE":
                case 4:
                    message.voice = 4;
                    break;
                case "TEACH_MODE_ON":
                case 5:
                    message.voice = 5;
                    break;
                case "TEACH_MODE_OFF":
                case 6:
                    message.voice = 6;
                    break;
                case "FINE_TUNNING_ON":
                case 7:
                    message.voice = 7;
                    break;
                case "FINE_TUNNING_OFF":
                case 8:
                    message.voice = 8;
                    break;
                case "FINE_TUNNING_CHANGE":
                case 9:
                    message.voice = 9;
                    break;
                case "BORING":
                case 10:
                    message.voice = 10;
                    break;
                case "CUSTOM1":
                case 11:
                    message.voice = 11;
                    break;
                case "CUSTOM2":
                case 12:
                    message.voice = 12;
                    break;
                case "CUSTOM3":
                case 13:
                    message.voice = 13;
                    break;
                case "CUSTOM4":
                case 14:
                    message.voice = 14;
                    break;
                case "CUSTOM5":
                case 15:
                    message.voice = 15;
                    break;
                }
                switch (object.volume) {
                default:
                    if (typeof object.volume === "number") {
                        message.volume = object.volume;
                        break;
                    }
                    break;
                case "MUTE":
                case 0:
                    message.volume = 0;
                    break;
                case "LOW":
                case 1:
                    message.volume = 1;
                    break;
                case "MID":
                case 2:
                    message.volume = 2;
                    break;
                case "HIGH":
                case 3:
                    message.volume = 3;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a VoiceData message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.led.VoiceData
             * @static
             * @param {lebai.led.VoiceData} message VoiceData
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            VoiceData.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.voice = options.enums === String ? "OFF" : 0;
                    object.volume = options.enums === String ? "MUTE" : 0;
                }
                if (message.voice != null && message.hasOwnProperty("voice"))
                    object.voice = options.enums === String ? $root.lebai.led.VoiceKind[message.voice] === undefined ? message.voice : $root.lebai.led.VoiceKind[message.voice] : message.voice;
                if (message.volume != null && message.hasOwnProperty("volume"))
                    object.volume = options.enums === String ? $root.lebai.led.Volume[message.volume] === undefined ? message.volume : $root.lebai.led.Volume[message.volume] : message.volume;
                return object;
            };

            /**
             * Converts this VoiceData to JSON.
             * @function toJSON
             * @memberof lebai.led.VoiceData
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            VoiceData.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for VoiceData
             * @function getTypeUrl
             * @memberof lebai.led.VoiceData
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            VoiceData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.led.VoiceData";
            };

            return VoiceData;
        })();

        led.LedStyle = (function() {

            /**
             * Properties of a LedStyle.
             * @memberof lebai.led
             * @interface ILedStyle
             * @property {lebai.led.ILedData|null} [led] LedStyle led
             * @property {lebai.led.VoiceKind|null} [voice] LedStyle voice
             * @property {lebai.led.Volume|null} [volume] LedStyle volume
             */

            /**
             * Constructs a new LedStyle.
             * @memberof lebai.led
             * @classdesc Represents a LedStyle.
             * @implements ILedStyle
             * @constructor
             * @param {lebai.led.ILedStyle=} [properties] Properties to set
             */
            function LedStyle(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LedStyle led.
             * @member {lebai.led.ILedData|null|undefined} led
             * @memberof lebai.led.LedStyle
             * @instance
             */
            LedStyle.prototype.led = null;

            /**
             * LedStyle voice.
             * @member {lebai.led.VoiceKind} voice
             * @memberof lebai.led.LedStyle
             * @instance
             */
            LedStyle.prototype.voice = 0;

            /**
             * LedStyle volume.
             * @member {lebai.led.Volume} volume
             * @memberof lebai.led.LedStyle
             * @instance
             */
            LedStyle.prototype.volume = 0;

            /**
             * Creates a new LedStyle instance using the specified properties.
             * @function create
             * @memberof lebai.led.LedStyle
             * @static
             * @param {lebai.led.ILedStyle=} [properties] Properties to set
             * @returns {lebai.led.LedStyle} LedStyle instance
             */
            LedStyle.create = function create(properties) {
                return new LedStyle(properties);
            };

            /**
             * Encodes the specified LedStyle message. Does not implicitly {@link lebai.led.LedStyle.verify|verify} messages.
             * @function encode
             * @memberof lebai.led.LedStyle
             * @static
             * @param {lebai.led.ILedStyle} message LedStyle message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LedStyle.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.led != null && Object.hasOwnProperty.call(message, "led"))
                    $root.lebai.led.LedData.encode(message.led, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.voice != null && Object.hasOwnProperty.call(message, "voice"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.voice);
                if (message.volume != null && Object.hasOwnProperty.call(message, "volume"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.volume);
                return writer;
            };

            /**
             * Encodes the specified LedStyle message, length delimited. Does not implicitly {@link lebai.led.LedStyle.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.led.LedStyle
             * @static
             * @param {lebai.led.ILedStyle} message LedStyle message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LedStyle.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LedStyle message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.led.LedStyle
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.led.LedStyle} LedStyle
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LedStyle.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.led.LedStyle();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.led = $root.lebai.led.LedData.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.voice = reader.int32();
                            break;
                        }
                    case 3: {
                            message.volume = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LedStyle message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.led.LedStyle
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.led.LedStyle} LedStyle
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LedStyle.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LedStyle message.
             * @function verify
             * @memberof lebai.led.LedStyle
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LedStyle.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.led != null && message.hasOwnProperty("led")) {
                    var error = $root.lebai.led.LedData.verify(message.led);
                    if (error)
                        return "led." + error;
                }
                if (message.voice != null && message.hasOwnProperty("voice"))
                    switch (message.voice) {
                    default:
                        return "voice: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                        break;
                    }
                if (message.volume != null && message.hasOwnProperty("volume"))
                    switch (message.volume) {
                    default:
                        return "volume: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                return null;
            };

            /**
             * Creates a LedStyle message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.led.LedStyle
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.led.LedStyle} LedStyle
             */
            LedStyle.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.led.LedStyle)
                    return object;
                var message = new $root.lebai.led.LedStyle();
                if (object.led != null) {
                    if (typeof object.led !== "object")
                        throw TypeError(".lebai.led.LedStyle.led: object expected");
                    message.led = $root.lebai.led.LedData.fromObject(object.led);
                }
                switch (object.voice) {
                default:
                    if (typeof object.voice === "number") {
                        message.voice = object.voice;
                        break;
                    }
                    break;
                case "OFF":
                case 0:
                    message.voice = 0;
                    break;
                case "BOOTING":
                case 1:
                    message.voice = 1;
                    break;
                case "STOPING":
                case 2:
                    message.voice = 2;
                    break;
                case "COLLISION_DETECTED":
                case 3:
                    message.voice = 3;
                    break;
                case "UPGRADE":
                case 4:
                    message.voice = 4;
                    break;
                case "TEACH_MODE_ON":
                case 5:
                    message.voice = 5;
                    break;
                case "TEACH_MODE_OFF":
                case 6:
                    message.voice = 6;
                    break;
                case "FINE_TUNNING_ON":
                case 7:
                    message.voice = 7;
                    break;
                case "FINE_TUNNING_OFF":
                case 8:
                    message.voice = 8;
                    break;
                case "FINE_TUNNING_CHANGE":
                case 9:
                    message.voice = 9;
                    break;
                case "BORING":
                case 10:
                    message.voice = 10;
                    break;
                case "CUSTOM1":
                case 11:
                    message.voice = 11;
                    break;
                case "CUSTOM2":
                case 12:
                    message.voice = 12;
                    break;
                case "CUSTOM3":
                case 13:
                    message.voice = 13;
                    break;
                case "CUSTOM4":
                case 14:
                    message.voice = 14;
                    break;
                case "CUSTOM5":
                case 15:
                    message.voice = 15;
                    break;
                }
                switch (object.volume) {
                default:
                    if (typeof object.volume === "number") {
                        message.volume = object.volume;
                        break;
                    }
                    break;
                case "MUTE":
                case 0:
                    message.volume = 0;
                    break;
                case "LOW":
                case 1:
                    message.volume = 1;
                    break;
                case "MID":
                case 2:
                    message.volume = 2;
                    break;
                case "HIGH":
                case 3:
                    message.volume = 3;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a LedStyle message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.led.LedStyle
             * @static
             * @param {lebai.led.LedStyle} message LedStyle
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LedStyle.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.led = null;
                    object.voice = options.enums === String ? "OFF" : 0;
                    object.volume = options.enums === String ? "MUTE" : 0;
                }
                if (message.led != null && message.hasOwnProperty("led"))
                    object.led = $root.lebai.led.LedData.toObject(message.led, options);
                if (message.voice != null && message.hasOwnProperty("voice"))
                    object.voice = options.enums === String ? $root.lebai.led.VoiceKind[message.voice] === undefined ? message.voice : $root.lebai.led.VoiceKind[message.voice] : message.voice;
                if (message.volume != null && message.hasOwnProperty("volume"))
                    object.volume = options.enums === String ? $root.lebai.led.Volume[message.volume] === undefined ? message.volume : $root.lebai.led.Volume[message.volume] : message.volume;
                return object;
            };

            /**
             * Converts this LedStyle to JSON.
             * @function toJSON
             * @memberof lebai.led.LedStyle
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LedStyle.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for LedStyle
             * @function getTypeUrl
             * @memberof lebai.led.LedStyle
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            LedStyle.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.led.LedStyle";
            };

            return LedStyle;
        })();

        led.SaveLedStyleRequest = (function() {

            /**
             * Properties of a SaveLedStyleRequest.
             * @memberof lebai.led
             * @interface ISaveLedStyleRequest
             * @property {string|null} [name] SaveLedStyleRequest name
             * @property {lebai.led.ILedStyle|null} [data] SaveLedStyleRequest data
             * @property {string|null} [dir] SaveLedStyleRequest dir
             */

            /**
             * Constructs a new SaveLedStyleRequest.
             * @memberof lebai.led
             * @classdesc Represents a SaveLedStyleRequest.
             * @implements ISaveLedStyleRequest
             * @constructor
             * @param {lebai.led.ISaveLedStyleRequest=} [properties] Properties to set
             */
            function SaveLedStyleRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SaveLedStyleRequest name.
             * @member {string} name
             * @memberof lebai.led.SaveLedStyleRequest
             * @instance
             */
            SaveLedStyleRequest.prototype.name = "";

            /**
             * SaveLedStyleRequest data.
             * @member {lebai.led.ILedStyle|null|undefined} data
             * @memberof lebai.led.SaveLedStyleRequest
             * @instance
             */
            SaveLedStyleRequest.prototype.data = null;

            /**
             * SaveLedStyleRequest dir.
             * @member {string} dir
             * @memberof lebai.led.SaveLedStyleRequest
             * @instance
             */
            SaveLedStyleRequest.prototype.dir = "";

            /**
             * Creates a new SaveLedStyleRequest instance using the specified properties.
             * @function create
             * @memberof lebai.led.SaveLedStyleRequest
             * @static
             * @param {lebai.led.ISaveLedStyleRequest=} [properties] Properties to set
             * @returns {lebai.led.SaveLedStyleRequest} SaveLedStyleRequest instance
             */
            SaveLedStyleRequest.create = function create(properties) {
                return new SaveLedStyleRequest(properties);
            };

            /**
             * Encodes the specified SaveLedStyleRequest message. Does not implicitly {@link lebai.led.SaveLedStyleRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.led.SaveLedStyleRequest
             * @static
             * @param {lebai.led.ISaveLedStyleRequest} message SaveLedStyleRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SaveLedStyleRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    $root.lebai.led.LedStyle.encode(message.data, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.dir != null && Object.hasOwnProperty.call(message, "dir"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.dir);
                return writer;
            };

            /**
             * Encodes the specified SaveLedStyleRequest message, length delimited. Does not implicitly {@link lebai.led.SaveLedStyleRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.led.SaveLedStyleRequest
             * @static
             * @param {lebai.led.ISaveLedStyleRequest} message SaveLedStyleRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SaveLedStyleRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SaveLedStyleRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.led.SaveLedStyleRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.led.SaveLedStyleRequest} SaveLedStyleRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SaveLedStyleRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.led.SaveLedStyleRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.name = reader.string();
                            break;
                        }
                    case 2: {
                            message.data = $root.lebai.led.LedStyle.decode(reader, reader.uint32());
                            break;
                        }
                    case 11: {
                            message.dir = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SaveLedStyleRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.led.SaveLedStyleRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.led.SaveLedStyleRequest} SaveLedStyleRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SaveLedStyleRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SaveLedStyleRequest message.
             * @function verify
             * @memberof lebai.led.SaveLedStyleRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SaveLedStyleRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.data != null && message.hasOwnProperty("data")) {
                    var error = $root.lebai.led.LedStyle.verify(message.data);
                    if (error)
                        return "data." + error;
                }
                if (message.dir != null && message.hasOwnProperty("dir"))
                    if (!$util.isString(message.dir))
                        return "dir: string expected";
                return null;
            };

            /**
             * Creates a SaveLedStyleRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.led.SaveLedStyleRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.led.SaveLedStyleRequest} SaveLedStyleRequest
             */
            SaveLedStyleRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.led.SaveLedStyleRequest)
                    return object;
                var message = new $root.lebai.led.SaveLedStyleRequest();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.data != null) {
                    if (typeof object.data !== "object")
                        throw TypeError(".lebai.led.SaveLedStyleRequest.data: object expected");
                    message.data = $root.lebai.led.LedStyle.fromObject(object.data);
                }
                if (object.dir != null)
                    message.dir = String(object.dir);
                return message;
            };

            /**
             * Creates a plain object from a SaveLedStyleRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.led.SaveLedStyleRequest
             * @static
             * @param {lebai.led.SaveLedStyleRequest} message SaveLedStyleRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SaveLedStyleRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.data = null;
                    object.dir = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.data != null && message.hasOwnProperty("data"))
                    object.data = $root.lebai.led.LedStyle.toObject(message.data, options);
                if (message.dir != null && message.hasOwnProperty("dir"))
                    object.dir = message.dir;
                return object;
            };

            /**
             * Converts this SaveLedStyleRequest to JSON.
             * @function toJSON
             * @memberof lebai.led.SaveLedStyleRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SaveLedStyleRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SaveLedStyleRequest
             * @function getTypeUrl
             * @memberof lebai.led.SaveLedStyleRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SaveLedStyleRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.led.SaveLedStyleRequest";
            };

            return SaveLedStyleRequest;
        })();

        led.LedStyleItem = (function() {

            /**
             * Properties of a LedStyleItem.
             * @memberof lebai.led
             * @interface ILedStyleItem
             * @property {lebai.system.RobotState|null} [state] LedStyleItem state
             * @property {lebai.led.ILedStyle|null} [style] LedStyleItem style
             */

            /**
             * Constructs a new LedStyleItem.
             * @memberof lebai.led
             * @classdesc Represents a LedStyleItem.
             * @implements ILedStyleItem
             * @constructor
             * @param {lebai.led.ILedStyleItem=} [properties] Properties to set
             */
            function LedStyleItem(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LedStyleItem state.
             * @member {lebai.system.RobotState} state
             * @memberof lebai.led.LedStyleItem
             * @instance
             */
            LedStyleItem.prototype.state = 0;

            /**
             * LedStyleItem style.
             * @member {lebai.led.ILedStyle|null|undefined} style
             * @memberof lebai.led.LedStyleItem
             * @instance
             */
            LedStyleItem.prototype.style = null;

            /**
             * Creates a new LedStyleItem instance using the specified properties.
             * @function create
             * @memberof lebai.led.LedStyleItem
             * @static
             * @param {lebai.led.ILedStyleItem=} [properties] Properties to set
             * @returns {lebai.led.LedStyleItem} LedStyleItem instance
             */
            LedStyleItem.create = function create(properties) {
                return new LedStyleItem(properties);
            };

            /**
             * Encodes the specified LedStyleItem message. Does not implicitly {@link lebai.led.LedStyleItem.verify|verify} messages.
             * @function encode
             * @memberof lebai.led.LedStyleItem
             * @static
             * @param {lebai.led.ILedStyleItem} message LedStyleItem message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LedStyleItem.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.state != null && Object.hasOwnProperty.call(message, "state"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.state);
                if (message.style != null && Object.hasOwnProperty.call(message, "style"))
                    $root.lebai.led.LedStyle.encode(message.style, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified LedStyleItem message, length delimited. Does not implicitly {@link lebai.led.LedStyleItem.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.led.LedStyleItem
             * @static
             * @param {lebai.led.ILedStyleItem} message LedStyleItem message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LedStyleItem.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LedStyleItem message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.led.LedStyleItem
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.led.LedStyleItem} LedStyleItem
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LedStyleItem.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.led.LedStyleItem();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.state = reader.int32();
                            break;
                        }
                    case 2: {
                            message.style = $root.lebai.led.LedStyle.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LedStyleItem message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.led.LedStyleItem
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.led.LedStyleItem} LedStyleItem
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LedStyleItem.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LedStyleItem message.
             * @function verify
             * @memberof lebai.led.LedStyleItem
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LedStyleItem.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.state != null && message.hasOwnProperty("state"))
                    switch (message.state) {
                    default:
                        return "state: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                        break;
                    }
                if (message.style != null && message.hasOwnProperty("style")) {
                    var error = $root.lebai.led.LedStyle.verify(message.style);
                    if (error)
                        return "style." + error;
                }
                return null;
            };

            /**
             * Creates a LedStyleItem message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.led.LedStyleItem
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.led.LedStyleItem} LedStyleItem
             */
            LedStyleItem.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.led.LedStyleItem)
                    return object;
                var message = new $root.lebai.led.LedStyleItem();
                switch (object.state) {
                default:
                    if (typeof object.state === "number") {
                        message.state = object.state;
                        break;
                    }
                    break;
                case "DISCONNECTED":
                case 0:
                    message.state = 0;
                    break;
                case "ESTOP":
                case 1:
                    message.state = 1;
                    break;
                case "BOOTING":
                case 2:
                    message.state = 2;
                    break;
                case "ROBOT_OFF":
                case 3:
                    message.state = 3;
                    break;
                case "ROBOT_ON":
                case 4:
                    message.state = 4;
                    break;
                case "IDLE":
                case 5:
                    message.state = 5;
                    break;
                case "PAUSED":
                case 6:
                    message.state = 6;
                    break;
                case "MOVING":
                case 7:
                    message.state = 7;
                    break;
                case "UPDATING":
                case 8:
                    message.state = 8;
                    break;
                case "STARTING":
                case 9:
                    message.state = 9;
                    break;
                case "STOPPING":
                case 10:
                    message.state = 10;
                    break;
                case "TEACHING":
                case 11:
                    message.state = 11;
                    break;
                case "STOP":
                case 12:
                    message.state = 12;
                    break;
                }
                if (object.style != null) {
                    if (typeof object.style !== "object")
                        throw TypeError(".lebai.led.LedStyleItem.style: object expected");
                    message.style = $root.lebai.led.LedStyle.fromObject(object.style);
                }
                return message;
            };

            /**
             * Creates a plain object from a LedStyleItem message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.led.LedStyleItem
             * @static
             * @param {lebai.led.LedStyleItem} message LedStyleItem
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LedStyleItem.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.state = options.enums === String ? "DISCONNECTED" : 0;
                    object.style = null;
                }
                if (message.state != null && message.hasOwnProperty("state"))
                    object.state = options.enums === String ? $root.lebai.system.RobotState[message.state] === undefined ? message.state : $root.lebai.system.RobotState[message.state] : message.state;
                if (message.style != null && message.hasOwnProperty("style"))
                    object.style = $root.lebai.led.LedStyle.toObject(message.style, options);
                return object;
            };

            /**
             * Converts this LedStyleItem to JSON.
             * @function toJSON
             * @memberof lebai.led.LedStyleItem
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LedStyleItem.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for LedStyleItem
             * @function getTypeUrl
             * @memberof lebai.led.LedStyleItem
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            LedStyleItem.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.led.LedStyleItem";
            };

            return LedStyleItem;
        })();

        led.LedStyles = (function() {

            /**
             * Properties of a LedStyles.
             * @memberof lebai.led
             * @interface ILedStyles
             * @property {Object.<string,lebai.led.ILedStyle>|null} [styles] LedStyles styles
             */

            /**
             * Constructs a new LedStyles.
             * @memberof lebai.led
             * @classdesc Represents a LedStyles.
             * @implements ILedStyles
             * @constructor
             * @param {lebai.led.ILedStyles=} [properties] Properties to set
             */
            function LedStyles(properties) {
                this.styles = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LedStyles styles.
             * @member {Object.<string,lebai.led.ILedStyle>} styles
             * @memberof lebai.led.LedStyles
             * @instance
             */
            LedStyles.prototype.styles = $util.emptyObject;

            /**
             * Creates a new LedStyles instance using the specified properties.
             * @function create
             * @memberof lebai.led.LedStyles
             * @static
             * @param {lebai.led.ILedStyles=} [properties] Properties to set
             * @returns {lebai.led.LedStyles} LedStyles instance
             */
            LedStyles.create = function create(properties) {
                return new LedStyles(properties);
            };

            /**
             * Encodes the specified LedStyles message. Does not implicitly {@link lebai.led.LedStyles.verify|verify} messages.
             * @function encode
             * @memberof lebai.led.LedStyles
             * @static
             * @param {lebai.led.ILedStyles} message LedStyles message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LedStyles.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.styles != null && Object.hasOwnProperty.call(message, "styles"))
                    for (var keys = Object.keys(message.styles), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 0 =*/8).int32(keys[i]);
                        $root.lebai.led.LedStyle.encode(message.styles[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                return writer;
            };

            /**
             * Encodes the specified LedStyles message, length delimited. Does not implicitly {@link lebai.led.LedStyles.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.led.LedStyles
             * @static
             * @param {lebai.led.ILedStyles} message LedStyles message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LedStyles.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LedStyles message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.led.LedStyles
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.led.LedStyles} LedStyles
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LedStyles.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.led.LedStyles(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (message.styles === $util.emptyObject)
                                message.styles = {};
                            var end2 = reader.uint32() + reader.pos;
                            key = 0;
                            value = null;
                            while (reader.pos < end2) {
                                var tag2 = reader.uint32();
                                switch (tag2 >>> 3) {
                                case 1:
                                    key = reader.int32();
                                    break;
                                case 2:
                                    value = $root.lebai.led.LedStyle.decode(reader, reader.uint32());
                                    break;
                                default:
                                    reader.skipType(tag2 & 7);
                                    break;
                                }
                            }
                            message.styles[key] = value;
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LedStyles message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.led.LedStyles
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.led.LedStyles} LedStyles
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LedStyles.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LedStyles message.
             * @function verify
             * @memberof lebai.led.LedStyles
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LedStyles.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.styles != null && message.hasOwnProperty("styles")) {
                    if (!$util.isObject(message.styles))
                        return "styles: object expected";
                    var key = Object.keys(message.styles);
                    for (var i = 0; i < key.length; ++i) {
                        if (!$util.key32Re.test(key[i]))
                            return "styles: integer key{k:int32} expected";
                        {
                            var error = $root.lebai.led.LedStyle.verify(message.styles[key[i]]);
                            if (error)
                                return "styles." + error;
                        }
                    }
                }
                return null;
            };

            /**
             * Creates a LedStyles message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.led.LedStyles
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.led.LedStyles} LedStyles
             */
            LedStyles.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.led.LedStyles)
                    return object;
                var message = new $root.lebai.led.LedStyles();
                if (object.styles) {
                    if (typeof object.styles !== "object")
                        throw TypeError(".lebai.led.LedStyles.styles: object expected");
                    message.styles = {};
                    for (var keys = Object.keys(object.styles), i = 0; i < keys.length; ++i) {
                        if (typeof object.styles[keys[i]] !== "object")
                            throw TypeError(".lebai.led.LedStyles.styles: object expected");
                        message.styles[keys[i]] = $root.lebai.led.LedStyle.fromObject(object.styles[keys[i]]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a LedStyles message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.led.LedStyles
             * @static
             * @param {lebai.led.LedStyles} message LedStyles
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LedStyles.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.styles = {};
                var keys2;
                if (message.styles && (keys2 = Object.keys(message.styles)).length) {
                    object.styles = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.styles[keys2[j]] = $root.lebai.led.LedStyle.toObject(message.styles[keys2[j]], options);
                }
                return object;
            };

            /**
             * Converts this LedStyles to JSON.
             * @function toJSON
             * @memberof lebai.led.LedStyles
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LedStyles.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for LedStyles
             * @function getTypeUrl
             * @memberof lebai.led.LedStyles
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            LedStyles.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.led.LedStyles";
            };

            return LedStyles;
        })();

        led.LedService = (function() {

            /**
             * Constructs a new LedService service.
             * @memberof lebai.led
             * @classdesc Represents a LedService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function LedService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (LedService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = LedService;

            /**
             * Creates new LedService service using the specified rpc implementation.
             * @function create
             * @memberof lebai.led.LedService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {LedService} RPC service. Useful where requests and/or responses are streamed.
             */
            LedService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link lebai.led.LedService#saveLedStyle}.
             * @memberof lebai.led.LedService
             * @typedef SaveLedStyleCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls SaveLedStyle.
             * @function saveLedStyle
             * @memberof lebai.led.LedService
             * @instance
             * @param {lebai.led.ISaveLedStyleRequest} request SaveLedStyleRequest message or plain object
             * @param {lebai.led.LedService.SaveLedStyleCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(LedService.prototype.saveLedStyle = function saveLedStyle(request, callback) {
                return this.rpcCall(saveLedStyle, $root.lebai.led.SaveLedStyleRequest, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "SaveLedStyle" });

            /**
             * Calls SaveLedStyle.
             * @function saveLedStyle
             * @memberof lebai.led.LedService
             * @instance
             * @param {lebai.led.ISaveLedStyleRequest} request SaveLedStyleRequest message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.led.LedService#loadLedStyle}.
             * @memberof lebai.led.LedService
             * @typedef LoadLedStyleCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.led.LedStyle} [response] LedStyle
             */

            /**
             * Calls LoadLedStyle.
             * @function loadLedStyle
             * @memberof lebai.led.LedService
             * @instance
             * @param {lebai.db.ILoadRequest} request LoadRequest message or plain object
             * @param {lebai.led.LedService.LoadLedStyleCallback} callback Node-style callback called with the error, if any, and LedStyle
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(LedService.prototype.loadLedStyle = function loadLedStyle(request, callback) {
                return this.rpcCall(loadLedStyle, $root.lebai.db.LoadRequest, $root.lebai.led.LedStyle, request, callback);
            }, "name", { value: "LoadLedStyle" });

            /**
             * Calls LoadLedStyle.
             * @function loadLedStyle
             * @memberof lebai.led.LedService
             * @instance
             * @param {lebai.db.ILoadRequest} request LoadRequest message or plain object
             * @returns {Promise<lebai.led.LedStyle>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.led.LedService#loadLedStyleList}.
             * @memberof lebai.led.LedService
             * @typedef LoadLedStyleListCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.db.LoadListResponse} [response] LoadListResponse
             */

            /**
             * Calls LoadLedStyleList.
             * @function loadLedStyleList
             * @memberof lebai.led.LedService
             * @instance
             * @param {lebai.db.ILoadListRequest} request LoadListRequest message or plain object
             * @param {lebai.led.LedService.LoadLedStyleListCallback} callback Node-style callback called with the error, if any, and LoadListResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(LedService.prototype.loadLedStyleList = function loadLedStyleList(request, callback) {
                return this.rpcCall(loadLedStyleList, $root.lebai.db.LoadListRequest, $root.lebai.db.LoadListResponse, request, callback);
            }, "name", { value: "LoadLedStyleList" });

            /**
             * Calls LoadLedStyleList.
             * @function loadLedStyleList
             * @memberof lebai.led.LedService
             * @instance
             * @param {lebai.db.ILoadListRequest} request LoadListRequest message or plain object
             * @returns {Promise<lebai.db.LoadListResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.led.LedService#setLedStyle}.
             * @memberof lebai.led.LedService
             * @typedef SetLedStyleCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls SetLedStyle.
             * @function setLedStyle
             * @memberof lebai.led.LedService
             * @instance
             * @param {lebai.led.ILedStyleItem} request LedStyleItem message or plain object
             * @param {lebai.led.LedService.SetLedStyleCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(LedService.prototype.setLedStyle = function setLedStyle(request, callback) {
                return this.rpcCall(setLedStyle, $root.lebai.led.LedStyleItem, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "SetLedStyle" });

            /**
             * Calls SetLedStyle.
             * @function setLedStyle
             * @memberof lebai.led.LedService
             * @instance
             * @param {lebai.led.ILedStyleItem} request LedStyleItem message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.led.LedService#setLedStyles}.
             * @memberof lebai.led.LedService
             * @typedef SetLedStylesCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls SetLedStyles.
             * @function setLedStyles
             * @memberof lebai.led.LedService
             * @instance
             * @param {lebai.led.ILedStyles} request LedStyles message or plain object
             * @param {lebai.led.LedService.SetLedStylesCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(LedService.prototype.setLedStyles = function setLedStyles(request, callback) {
                return this.rpcCall(setLedStyles, $root.lebai.led.LedStyles, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "SetLedStyles" });

            /**
             * Calls SetLedStyles.
             * @function setLedStyles
             * @memberof lebai.led.LedService
             * @instance
             * @param {lebai.led.ILedStyles} request LedStyles message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.led.LedService#getLedStyles}.
             * @memberof lebai.led.LedService
             * @typedef GetLedStylesCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.led.LedStyles} [response] LedStyles
             */

            /**
             * Calls GetLedStyles.
             * @function getLedStyles
             * @memberof lebai.led.LedService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {lebai.led.LedService.GetLedStylesCallback} callback Node-style callback called with the error, if any, and LedStyles
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(LedService.prototype.getLedStyles = function getLedStyles(request, callback) {
                return this.rpcCall(getLedStyles, $root.google.protobuf.Empty, $root.lebai.led.LedStyles, request, callback);
            }, "name", { value: "GetLedStyles" });

            /**
             * Calls GetLedStyles.
             * @function getLedStyles
             * @memberof lebai.led.LedService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<lebai.led.LedStyles>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.led.LedService#setLed}.
             * @memberof lebai.led.LedService
             * @typedef SetLedCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls SetLed.
             * @function setLed
             * @memberof lebai.led.LedService
             * @instance
             * @param {lebai.led.ILedData} request LedData message or plain object
             * @param {lebai.led.LedService.SetLedCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(LedService.prototype.setLed = function setLed(request, callback) {
                return this.rpcCall(setLed, $root.lebai.led.LedData, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "SetLed" });

            /**
             * Calls SetLed.
             * @function setLed
             * @memberof lebai.led.LedService
             * @instance
             * @param {lebai.led.ILedData} request LedData message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.led.LedService#setVoice}.
             * @memberof lebai.led.LedService
             * @typedef SetVoiceCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls SetVoice.
             * @function setVoice
             * @memberof lebai.led.LedService
             * @instance
             * @param {lebai.led.IVoiceData} request VoiceData message or plain object
             * @param {lebai.led.LedService.SetVoiceCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(LedService.prototype.setVoice = function setVoice(request, callback) {
                return this.rpcCall(setVoice, $root.lebai.led.VoiceData, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "SetVoice" });

            /**
             * Calls SetVoice.
             * @function setVoice
             * @memberof lebai.led.LedService
             * @instance
             * @param {lebai.led.IVoiceData} request VoiceData message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.led.LedService#setFan}.
             * @memberof lebai.led.LedService
             * @typedef SetFanCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls SetFan.
             * @function setFan
             * @memberof lebai.led.LedService
             * @instance
             * @param {lebai.led.IFanData} request FanData message or plain object
             * @param {lebai.led.LedService.SetFanCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(LedService.prototype.setFan = function setFan(request, callback) {
                return this.rpcCall(setFan, $root.lebai.led.FanData, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "SetFan" });

            /**
             * Calls SetFan.
             * @function setFan
             * @memberof lebai.led.LedService
             * @instance
             * @param {lebai.led.IFanData} request FanData message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            return LedService;
        })();

        return led;
    })();

    lebai.message = (function() {

        /**
         * Namespace message.
         * @memberof lebai
         * @namespace
         */
        var message = {};

        /**
         * Level enum.
         * @name lebai.message.Level
         * @enum {number}
         * @property {number} INFO=0 INFO value
         * @property {number} WARN=1 WARN value
         * @property {number} ERROR=2 ERROR value
         */
        message.Level = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "INFO"] = 0;
            values[valuesById[1] = "WARN"] = 1;
            values[valuesById[2] = "ERROR"] = 2;
            return values;
        })();

        /**
         * Kind enum.
         * @name lebai.message.Kind
         * @enum {number}
         * @property {number} ESTOP=0 ESTOP value
         * @property {number} HARD_ESTOP_LOCK=1 HARD_ESTOP_LOCK value
         * @property {number} DRIVER_ERROR=2 DRIVER_ERROR value
         * @property {number} REACH_JOINT_LIMIT=3 REACH_JOINT_LIMIT value
         * @property {number} COLLISION_DETECTED=4 COLLISION_DETECTED value
         * @property {number} JONIT_SPEED_EXCEED=5 JONIT_SPEED_EXCEED value
         * @property {number} TRAJECTOR_ERROR=6 TRAJECTOR_ERROR value
         * @property {number} OTA_FAILED=7 OTA_FAILED value
         */
        message.Kind = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "ESTOP"] = 0;
            values[valuesById[1] = "HARD_ESTOP_LOCK"] = 1;
            values[valuesById[2] = "DRIVER_ERROR"] = 2;
            values[valuesById[3] = "REACH_JOINT_LIMIT"] = 3;
            values[valuesById[4] = "COLLISION_DETECTED"] = 4;
            values[valuesById[5] = "JONIT_SPEED_EXCEED"] = 5;
            values[valuesById[6] = "TRAJECTOR_ERROR"] = 6;
            values[valuesById[7] = "OTA_FAILED"] = 7;
            return values;
        })();

        message.Message = (function() {

            /**
             * Properties of a Message.
             * @memberof lebai.message
             * @interface IMessage
             * @property {lebai.message.Level|null} [level] Message level
             * @property {lebai.message.Kind|null} [kind] Message kind
             * @property {string|null} [detail] Message detail
             * @property {google.protobuf.ITimestamp|null} [time] Message time
             */

            /**
             * Constructs a new Message.
             * @memberof lebai.message
             * @classdesc Represents a Message.
             * @implements IMessage
             * @constructor
             * @param {lebai.message.IMessage=} [properties] Properties to set
             */
            function Message(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Message level.
             * @member {lebai.message.Level} level
             * @memberof lebai.message.Message
             * @instance
             */
            Message.prototype.level = 0;

            /**
             * Message kind.
             * @member {lebai.message.Kind} kind
             * @memberof lebai.message.Message
             * @instance
             */
            Message.prototype.kind = 0;

            /**
             * Message detail.
             * @member {string} detail
             * @memberof lebai.message.Message
             * @instance
             */
            Message.prototype.detail = "";

            /**
             * Message time.
             * @member {google.protobuf.ITimestamp|null|undefined} time
             * @memberof lebai.message.Message
             * @instance
             */
            Message.prototype.time = null;

            /**
             * Creates a new Message instance using the specified properties.
             * @function create
             * @memberof lebai.message.Message
             * @static
             * @param {lebai.message.IMessage=} [properties] Properties to set
             * @returns {lebai.message.Message} Message instance
             */
            Message.create = function create(properties) {
                return new Message(properties);
            };

            /**
             * Encodes the specified Message message. Does not implicitly {@link lebai.message.Message.verify|verify} messages.
             * @function encode
             * @memberof lebai.message.Message
             * @static
             * @param {lebai.message.IMessage} message Message message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Message.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.level != null && Object.hasOwnProperty.call(message, "level"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.level);
                if (message.kind != null && Object.hasOwnProperty.call(message, "kind"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.kind);
                if (message.detail != null && Object.hasOwnProperty.call(message, "detail"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.detail);
                if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                    $root.google.protobuf.Timestamp.encode(message.time, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Message message, length delimited. Does not implicitly {@link lebai.message.Message.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.message.Message
             * @static
             * @param {lebai.message.IMessage} message Message message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Message.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Message message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.message.Message
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.message.Message} Message
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Message.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.message.Message();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.level = reader.int32();
                            break;
                        }
                    case 2: {
                            message.kind = reader.int32();
                            break;
                        }
                    case 3: {
                            message.detail = reader.string();
                            break;
                        }
                    case 11: {
                            message.time = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Message message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.message.Message
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.message.Message} Message
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Message.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Message message.
             * @function verify
             * @memberof lebai.message.Message
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Message.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.level != null && message.hasOwnProperty("level"))
                    switch (message.level) {
                    default:
                        return "level: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.kind != null && message.hasOwnProperty("kind"))
                    switch (message.kind) {
                    default:
                        return "kind: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                        break;
                    }
                if (message.detail != null && message.hasOwnProperty("detail"))
                    if (!$util.isString(message.detail))
                        return "detail: string expected";
                if (message.time != null && message.hasOwnProperty("time")) {
                    var error = $root.google.protobuf.Timestamp.verify(message.time);
                    if (error)
                        return "time." + error;
                }
                return null;
            };

            /**
             * Creates a Message message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.message.Message
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.message.Message} Message
             */
            Message.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.message.Message)
                    return object;
                var message = new $root.lebai.message.Message();
                switch (object.level) {
                default:
                    if (typeof object.level === "number") {
                        message.level = object.level;
                        break;
                    }
                    break;
                case "INFO":
                case 0:
                    message.level = 0;
                    break;
                case "WARN":
                case 1:
                    message.level = 1;
                    break;
                case "ERROR":
                case 2:
                    message.level = 2;
                    break;
                }
                switch (object.kind) {
                default:
                    if (typeof object.kind === "number") {
                        message.kind = object.kind;
                        break;
                    }
                    break;
                case "ESTOP":
                case 0:
                    message.kind = 0;
                    break;
                case "HARD_ESTOP_LOCK":
                case 1:
                    message.kind = 1;
                    break;
                case "DRIVER_ERROR":
                case 2:
                    message.kind = 2;
                    break;
                case "REACH_JOINT_LIMIT":
                case 3:
                    message.kind = 3;
                    break;
                case "COLLISION_DETECTED":
                case 4:
                    message.kind = 4;
                    break;
                case "JONIT_SPEED_EXCEED":
                case 5:
                    message.kind = 5;
                    break;
                case "TRAJECTOR_ERROR":
                case 6:
                    message.kind = 6;
                    break;
                case "OTA_FAILED":
                case 7:
                    message.kind = 7;
                    break;
                }
                if (object.detail != null)
                    message.detail = String(object.detail);
                if (object.time != null) {
                    if (typeof object.time !== "object")
                        throw TypeError(".lebai.message.Message.time: object expected");
                    message.time = $root.google.protobuf.Timestamp.fromObject(object.time);
                }
                return message;
            };

            /**
             * Creates a plain object from a Message message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.message.Message
             * @static
             * @param {lebai.message.Message} message Message
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Message.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.level = options.enums === String ? "INFO" : 0;
                    object.kind = options.enums === String ? "ESTOP" : 0;
                    object.detail = "";
                    object.time = null;
                }
                if (message.level != null && message.hasOwnProperty("level"))
                    object.level = options.enums === String ? $root.lebai.message.Level[message.level] === undefined ? message.level : $root.lebai.message.Level[message.level] : message.level;
                if (message.kind != null && message.hasOwnProperty("kind"))
                    object.kind = options.enums === String ? $root.lebai.message.Kind[message.kind] === undefined ? message.kind : $root.lebai.message.Kind[message.kind] : message.kind;
                if (message.detail != null && message.hasOwnProperty("detail"))
                    object.detail = message.detail;
                if (message.time != null && message.hasOwnProperty("time"))
                    object.time = $root.google.protobuf.Timestamp.toObject(message.time, options);
                return object;
            };

            /**
             * Converts this Message to JSON.
             * @function toJSON
             * @memberof lebai.message.Message
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Message.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Message
             * @function getTypeUrl
             * @memberof lebai.message.Message
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Message.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.message.Message";
            };

            return Message;
        })();

        message.Messages = (function() {

            /**
             * Properties of a Messages.
             * @memberof lebai.message
             * @interface IMessages
             * @property {Array.<lebai.message.IMessage>|null} [messages] Messages messages
             */

            /**
             * Constructs a new Messages.
             * @memberof lebai.message
             * @classdesc Represents a Messages.
             * @implements IMessages
             * @constructor
             * @param {lebai.message.IMessages=} [properties] Properties to set
             */
            function Messages(properties) {
                this.messages = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Messages messages.
             * @member {Array.<lebai.message.IMessage>} messages
             * @memberof lebai.message.Messages
             * @instance
             */
            Messages.prototype.messages = $util.emptyArray;

            /**
             * Creates a new Messages instance using the specified properties.
             * @function create
             * @memberof lebai.message.Messages
             * @static
             * @param {lebai.message.IMessages=} [properties] Properties to set
             * @returns {lebai.message.Messages} Messages instance
             */
            Messages.create = function create(properties) {
                return new Messages(properties);
            };

            /**
             * Encodes the specified Messages message. Does not implicitly {@link lebai.message.Messages.verify|verify} messages.
             * @function encode
             * @memberof lebai.message.Messages
             * @static
             * @param {lebai.message.IMessages} message Messages message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Messages.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.messages != null && message.messages.length)
                    for (var i = 0; i < message.messages.length; ++i)
                        $root.lebai.message.Message.encode(message.messages[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Messages message, length delimited. Does not implicitly {@link lebai.message.Messages.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.message.Messages
             * @static
             * @param {lebai.message.IMessages} message Messages message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Messages.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Messages message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.message.Messages
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.message.Messages} Messages
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Messages.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.message.Messages();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.messages && message.messages.length))
                                message.messages = [];
                            message.messages.push($root.lebai.message.Message.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Messages message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.message.Messages
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.message.Messages} Messages
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Messages.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Messages message.
             * @function verify
             * @memberof lebai.message.Messages
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Messages.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.messages != null && message.hasOwnProperty("messages")) {
                    if (!Array.isArray(message.messages))
                        return "messages: array expected";
                    for (var i = 0; i < message.messages.length; ++i) {
                        var error = $root.lebai.message.Message.verify(message.messages[i]);
                        if (error)
                            return "messages." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Messages message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.message.Messages
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.message.Messages} Messages
             */
            Messages.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.message.Messages)
                    return object;
                var message = new $root.lebai.message.Messages();
                if (object.messages) {
                    if (!Array.isArray(object.messages))
                        throw TypeError(".lebai.message.Messages.messages: array expected");
                    message.messages = [];
                    for (var i = 0; i < object.messages.length; ++i) {
                        if (typeof object.messages[i] !== "object")
                            throw TypeError(".lebai.message.Messages.messages: object expected");
                        message.messages[i] = $root.lebai.message.Message.fromObject(object.messages[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a Messages message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.message.Messages
             * @static
             * @param {lebai.message.Messages} message Messages
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Messages.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.messages = [];
                if (message.messages && message.messages.length) {
                    object.messages = [];
                    for (var j = 0; j < message.messages.length; ++j)
                        object.messages[j] = $root.lebai.message.Message.toObject(message.messages[j], options);
                }
                return object;
            };

            /**
             * Converts this Messages to JSON.
             * @function toJSON
             * @memberof lebai.message.Messages
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Messages.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Messages
             * @function getTypeUrl
             * @memberof lebai.message.Messages
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Messages.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.message.Messages";
            };

            return Messages;
        })();

        message.MessageService = (function() {

            /**
             * Constructs a new MessageService service.
             * @memberof lebai.message
             * @classdesc Represents a MessageService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function MessageService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (MessageService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = MessageService;

            /**
             * Creates new MessageService service using the specified rpc implementation.
             * @function create
             * @memberof lebai.message.MessageService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {MessageService} RPC service. Useful where requests and/or responses are streamed.
             */
            MessageService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link lebai.message.MessageService#getMessages}.
             * @memberof lebai.message.MessageService
             * @typedef GetMessagesCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.message.Messages} [response] Messages
             */

            /**
             * Calls GetMessages.
             * @function getMessages
             * @memberof lebai.message.MessageService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {lebai.message.MessageService.GetMessagesCallback} callback Node-style callback called with the error, if any, and Messages
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MessageService.prototype.getMessages = function getMessages(request, callback) {
                return this.rpcCall(getMessages, $root.google.protobuf.Empty, $root.lebai.message.Messages, request, callback);
            }, "name", { value: "GetMessages" });

            /**
             * Calls GetMessages.
             * @function getMessages
             * @memberof lebai.message.MessageService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<lebai.message.Messages>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.message.MessageService#subMessage}.
             * @memberof lebai.message.MessageService
             * @typedef SubMessageCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.message.Message} [response] Message
             */

            /**
             * Calls SubMessage.
             * @function subMessage
             * @memberof lebai.message.MessageService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {lebai.message.MessageService.SubMessageCallback} callback Node-style callback called with the error, if any, and Message
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MessageService.prototype.subMessage = function subMessage(request, callback) {
                return this.rpcCall(subMessage, $root.google.protobuf.Empty, $root.lebai.message.Message, request, callback);
            }, "name", { value: "SubMessage" });

            /**
             * Calls SubMessage.
             * @function subMessage
             * @memberof lebai.message.MessageService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<lebai.message.Message>} Promise
             * @variation 2
             */

            return MessageService;
        })();

        return message;
    })();

    lebai.modbus = (function() {

        /**
         * Namespace modbus.
         * @memberof lebai
         * @namespace
         */
        var modbus = {};

        /**
         * ModbusKind enum.
         * @name lebai.modbus.ModbusKind
         * @enum {number}
         * @property {number} ROBOT=0 ROBOT value
         * @property {number} FLANGE=1 FLANGE value
         * @property {number} EXTRA=2 EXTRA value
         * @property {number} MODBUS_FLANGE=3 MODBUS_FLANGE value
         * @property {number} MODBUS_RTU=4 MODBUS_RTU value
         * @property {number} MODBUS_TCP=5 MODBUS_TCP value
         */
        modbus.ModbusKind = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "ROBOT"] = 0;
            values[valuesById[1] = "FLANGE"] = 1;
            values[valuesById[2] = "EXTRA"] = 2;
            values[valuesById[3] = "MODBUS_FLANGE"] = 3;
            values[valuesById[4] = "MODBUS_RTU"] = 4;
            values[valuesById[5] = "MODBUS_TCP"] = 5;
            return values;
        })();

        modbus.Modbus = (function() {

            /**
             * Properties of a Modbus.
             * @memberof lebai.modbus
             * @interface IModbus
             * @property {lebai.modbus.ModbusKind|null} [kind] Modbus kind
             * @property {string|null} [address] Modbus address
             * @property {number|null} [port] Modbus port
             * @property {number|null} [slaveId] Modbus slaveId
             */

            /**
             * Constructs a new Modbus.
             * @memberof lebai.modbus
             * @classdesc Represents a Modbus.
             * @implements IModbus
             * @constructor
             * @param {lebai.modbus.IModbus=} [properties] Properties to set
             */
            function Modbus(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Modbus kind.
             * @member {lebai.modbus.ModbusKind} kind
             * @memberof lebai.modbus.Modbus
             * @instance
             */
            Modbus.prototype.kind = 0;

            /**
             * Modbus address.
             * @member {string} address
             * @memberof lebai.modbus.Modbus
             * @instance
             */
            Modbus.prototype.address = "";

            /**
             * Modbus port.
             * @member {number} port
             * @memberof lebai.modbus.Modbus
             * @instance
             */
            Modbus.prototype.port = 0;

            /**
             * Modbus slaveId.
             * @member {number} slaveId
             * @memberof lebai.modbus.Modbus
             * @instance
             */
            Modbus.prototype.slaveId = 0;

            /**
             * Creates a new Modbus instance using the specified properties.
             * @function create
             * @memberof lebai.modbus.Modbus
             * @static
             * @param {lebai.modbus.IModbus=} [properties] Properties to set
             * @returns {lebai.modbus.Modbus} Modbus instance
             */
            Modbus.create = function create(properties) {
                return new Modbus(properties);
            };

            /**
             * Encodes the specified Modbus message. Does not implicitly {@link lebai.modbus.Modbus.verify|verify} messages.
             * @function encode
             * @memberof lebai.modbus.Modbus
             * @static
             * @param {lebai.modbus.IModbus} message Modbus message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Modbus.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.kind != null && Object.hasOwnProperty.call(message, "kind"))
                    writer.uint32(/* id 12, wireType 0 =*/96).int32(message.kind);
                if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                    writer.uint32(/* id 13, wireType 2 =*/106).string(message.address);
                if (message.port != null && Object.hasOwnProperty.call(message, "port"))
                    writer.uint32(/* id 14, wireType 0 =*/112).uint32(message.port);
                if (message.slaveId != null && Object.hasOwnProperty.call(message, "slaveId"))
                    writer.uint32(/* id 15, wireType 0 =*/120).uint32(message.slaveId);
                return writer;
            };

            /**
             * Encodes the specified Modbus message, length delimited. Does not implicitly {@link lebai.modbus.Modbus.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.modbus.Modbus
             * @static
             * @param {lebai.modbus.IModbus} message Modbus message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Modbus.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Modbus message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.modbus.Modbus
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.modbus.Modbus} Modbus
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Modbus.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.modbus.Modbus();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 12: {
                            message.kind = reader.int32();
                            break;
                        }
                    case 13: {
                            message.address = reader.string();
                            break;
                        }
                    case 14: {
                            message.port = reader.uint32();
                            break;
                        }
                    case 15: {
                            message.slaveId = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Modbus message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.modbus.Modbus
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.modbus.Modbus} Modbus
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Modbus.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Modbus message.
             * @function verify
             * @memberof lebai.modbus.Modbus
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Modbus.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.kind != null && message.hasOwnProperty("kind"))
                    switch (message.kind) {
                    default:
                        return "kind: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                        break;
                    }
                if (message.address != null && message.hasOwnProperty("address"))
                    if (!$util.isString(message.address))
                        return "address: string expected";
                if (message.port != null && message.hasOwnProperty("port"))
                    if (!$util.isInteger(message.port))
                        return "port: integer expected";
                if (message.slaveId != null && message.hasOwnProperty("slaveId"))
                    if (!$util.isInteger(message.slaveId))
                        return "slaveId: integer expected";
                return null;
            };

            /**
             * Creates a Modbus message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.modbus.Modbus
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.modbus.Modbus} Modbus
             */
            Modbus.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.modbus.Modbus)
                    return object;
                var message = new $root.lebai.modbus.Modbus();
                switch (object.kind) {
                default:
                    if (typeof object.kind === "number") {
                        message.kind = object.kind;
                        break;
                    }
                    break;
                case "ROBOT":
                case 0:
                    message.kind = 0;
                    break;
                case "FLANGE":
                case 1:
                    message.kind = 1;
                    break;
                case "EXTRA":
                case 2:
                    message.kind = 2;
                    break;
                case "MODBUS_FLANGE":
                case 3:
                    message.kind = 3;
                    break;
                case "MODBUS_RTU":
                case 4:
                    message.kind = 4;
                    break;
                case "MODBUS_TCP":
                case 5:
                    message.kind = 5;
                    break;
                }
                if (object.address != null)
                    message.address = String(object.address);
                if (object.port != null)
                    message.port = object.port >>> 0;
                if (object.slaveId != null)
                    message.slaveId = object.slaveId >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a Modbus message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.modbus.Modbus
             * @static
             * @param {lebai.modbus.Modbus} message Modbus
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Modbus.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.kind = options.enums === String ? "ROBOT" : 0;
                    object.address = "";
                    object.port = 0;
                    object.slaveId = 0;
                }
                if (message.kind != null && message.hasOwnProperty("kind"))
                    object.kind = options.enums === String ? $root.lebai.modbus.ModbusKind[message.kind] === undefined ? message.kind : $root.lebai.modbus.ModbusKind[message.kind] : message.kind;
                if (message.address != null && message.hasOwnProperty("address"))
                    object.address = message.address;
                if (message.port != null && message.hasOwnProperty("port"))
                    object.port = message.port;
                if (message.slaveId != null && message.hasOwnProperty("slaveId"))
                    object.slaveId = message.slaveId;
                return object;
            };

            /**
             * Converts this Modbus to JSON.
             * @function toJSON
             * @memberof lebai.modbus.Modbus
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Modbus.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Modbus
             * @function getTypeUrl
             * @memberof lebai.modbus.Modbus
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Modbus.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.modbus.Modbus";
            };

            return Modbus;
        })();

        modbus.SaveModbusRequest = (function() {

            /**
             * Properties of a SaveModbusRequest.
             * @memberof lebai.modbus
             * @interface ISaveModbusRequest
             * @property {string|null} [name] SaveModbusRequest name
             * @property {lebai.modbus.IModbus|null} [data] SaveModbusRequest data
             */

            /**
             * Constructs a new SaveModbusRequest.
             * @memberof lebai.modbus
             * @classdesc Represents a SaveModbusRequest.
             * @implements ISaveModbusRequest
             * @constructor
             * @param {lebai.modbus.ISaveModbusRequest=} [properties] Properties to set
             */
            function SaveModbusRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SaveModbusRequest name.
             * @member {string} name
             * @memberof lebai.modbus.SaveModbusRequest
             * @instance
             */
            SaveModbusRequest.prototype.name = "";

            /**
             * SaveModbusRequest data.
             * @member {lebai.modbus.IModbus|null|undefined} data
             * @memberof lebai.modbus.SaveModbusRequest
             * @instance
             */
            SaveModbusRequest.prototype.data = null;

            /**
             * Creates a new SaveModbusRequest instance using the specified properties.
             * @function create
             * @memberof lebai.modbus.SaveModbusRequest
             * @static
             * @param {lebai.modbus.ISaveModbusRequest=} [properties] Properties to set
             * @returns {lebai.modbus.SaveModbusRequest} SaveModbusRequest instance
             */
            SaveModbusRequest.create = function create(properties) {
                return new SaveModbusRequest(properties);
            };

            /**
             * Encodes the specified SaveModbusRequest message. Does not implicitly {@link lebai.modbus.SaveModbusRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.modbus.SaveModbusRequest
             * @static
             * @param {lebai.modbus.ISaveModbusRequest} message SaveModbusRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SaveModbusRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    $root.lebai.modbus.Modbus.encode(message.data, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified SaveModbusRequest message, length delimited. Does not implicitly {@link lebai.modbus.SaveModbusRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.modbus.SaveModbusRequest
             * @static
             * @param {lebai.modbus.ISaveModbusRequest} message SaveModbusRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SaveModbusRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SaveModbusRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.modbus.SaveModbusRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.modbus.SaveModbusRequest} SaveModbusRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SaveModbusRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.modbus.SaveModbusRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.name = reader.string();
                            break;
                        }
                    case 2: {
                            message.data = $root.lebai.modbus.Modbus.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SaveModbusRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.modbus.SaveModbusRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.modbus.SaveModbusRequest} SaveModbusRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SaveModbusRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SaveModbusRequest message.
             * @function verify
             * @memberof lebai.modbus.SaveModbusRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SaveModbusRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.data != null && message.hasOwnProperty("data")) {
                    var error = $root.lebai.modbus.Modbus.verify(message.data);
                    if (error)
                        return "data." + error;
                }
                return null;
            };

            /**
             * Creates a SaveModbusRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.modbus.SaveModbusRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.modbus.SaveModbusRequest} SaveModbusRequest
             */
            SaveModbusRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.modbus.SaveModbusRequest)
                    return object;
                var message = new $root.lebai.modbus.SaveModbusRequest();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.data != null) {
                    if (typeof object.data !== "object")
                        throw TypeError(".lebai.modbus.SaveModbusRequest.data: object expected");
                    message.data = $root.lebai.modbus.Modbus.fromObject(object.data);
                }
                return message;
            };

            /**
             * Creates a plain object from a SaveModbusRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.modbus.SaveModbusRequest
             * @static
             * @param {lebai.modbus.SaveModbusRequest} message SaveModbusRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SaveModbusRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.data = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.data != null && message.hasOwnProperty("data"))
                    object.data = $root.lebai.modbus.Modbus.toObject(message.data, options);
                return object;
            };

            /**
             * Converts this SaveModbusRequest to JSON.
             * @function toJSON
             * @memberof lebai.modbus.SaveModbusRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SaveModbusRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SaveModbusRequest
             * @function getTypeUrl
             * @memberof lebai.modbus.SaveModbusRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SaveModbusRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.modbus.SaveModbusRequest";
            };

            return SaveModbusRequest;
        })();

        /**
         * ModbusRegisterKind enum.
         * @name lebai.modbus.ModbusRegisterKind
         * @enum {number}
         * @property {number} DISCRETE_INPUT=0 DISCRETE_INPUT value
         * @property {number} COIL=1 COIL value
         * @property {number} INPUT_REGISTER=2 INPUT_REGISTER value
         * @property {number} HOLDING_REGISTER=3 HOLDING_REGISTER value
         */
        modbus.ModbusRegisterKind = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "DISCRETE_INPUT"] = 0;
            values[valuesById[1] = "COIL"] = 1;
            values[valuesById[2] = "INPUT_REGISTER"] = 2;
            values[valuesById[3] = "HOLDING_REGISTER"] = 3;
            return values;
        })();

        modbus.ModbusRegister = (function() {

            /**
             * Properties of a ModbusRegister.
             * @memberof lebai.modbus
             * @interface IModbusRegister
             * @property {lebai.modbus.ModbusRegisterKind|null} [kind] ModbusRegister kind
             * @property {number|null} [address] ModbusRegister address
             */

            /**
             * Constructs a new ModbusRegister.
             * @memberof lebai.modbus
             * @classdesc Represents a ModbusRegister.
             * @implements IModbusRegister
             * @constructor
             * @param {lebai.modbus.IModbusRegister=} [properties] Properties to set
             */
            function ModbusRegister(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ModbusRegister kind.
             * @member {lebai.modbus.ModbusRegisterKind} kind
             * @memberof lebai.modbus.ModbusRegister
             * @instance
             */
            ModbusRegister.prototype.kind = 0;

            /**
             * ModbusRegister address.
             * @member {number} address
             * @memberof lebai.modbus.ModbusRegister
             * @instance
             */
            ModbusRegister.prototype.address = 0;

            /**
             * Creates a new ModbusRegister instance using the specified properties.
             * @function create
             * @memberof lebai.modbus.ModbusRegister
             * @static
             * @param {lebai.modbus.IModbusRegister=} [properties] Properties to set
             * @returns {lebai.modbus.ModbusRegister} ModbusRegister instance
             */
            ModbusRegister.create = function create(properties) {
                return new ModbusRegister(properties);
            };

            /**
             * Encodes the specified ModbusRegister message. Does not implicitly {@link lebai.modbus.ModbusRegister.verify|verify} messages.
             * @function encode
             * @memberof lebai.modbus.ModbusRegister
             * @static
             * @param {lebai.modbus.IModbusRegister} message ModbusRegister message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ModbusRegister.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.kind != null && Object.hasOwnProperty.call(message, "kind"))
                    writer.uint32(/* id 12, wireType 0 =*/96).int32(message.kind);
                if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                    writer.uint32(/* id 13, wireType 0 =*/104).uint32(message.address);
                return writer;
            };

            /**
             * Encodes the specified ModbusRegister message, length delimited. Does not implicitly {@link lebai.modbus.ModbusRegister.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.modbus.ModbusRegister
             * @static
             * @param {lebai.modbus.IModbusRegister} message ModbusRegister message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ModbusRegister.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ModbusRegister message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.modbus.ModbusRegister
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.modbus.ModbusRegister} ModbusRegister
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ModbusRegister.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.modbus.ModbusRegister();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 12: {
                            message.kind = reader.int32();
                            break;
                        }
                    case 13: {
                            message.address = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ModbusRegister message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.modbus.ModbusRegister
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.modbus.ModbusRegister} ModbusRegister
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ModbusRegister.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ModbusRegister message.
             * @function verify
             * @memberof lebai.modbus.ModbusRegister
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ModbusRegister.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.kind != null && message.hasOwnProperty("kind"))
                    switch (message.kind) {
                    default:
                        return "kind: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.address != null && message.hasOwnProperty("address"))
                    if (!$util.isInteger(message.address))
                        return "address: integer expected";
                return null;
            };

            /**
             * Creates a ModbusRegister message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.modbus.ModbusRegister
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.modbus.ModbusRegister} ModbusRegister
             */
            ModbusRegister.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.modbus.ModbusRegister)
                    return object;
                var message = new $root.lebai.modbus.ModbusRegister();
                switch (object.kind) {
                default:
                    if (typeof object.kind === "number") {
                        message.kind = object.kind;
                        break;
                    }
                    break;
                case "DISCRETE_INPUT":
                case 0:
                    message.kind = 0;
                    break;
                case "COIL":
                case 1:
                    message.kind = 1;
                    break;
                case "INPUT_REGISTER":
                case 2:
                    message.kind = 2;
                    break;
                case "HOLDING_REGISTER":
                case 3:
                    message.kind = 3;
                    break;
                }
                if (object.address != null)
                    message.address = object.address >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a ModbusRegister message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.modbus.ModbusRegister
             * @static
             * @param {lebai.modbus.ModbusRegister} message ModbusRegister
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ModbusRegister.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.kind = options.enums === String ? "DISCRETE_INPUT" : 0;
                    object.address = 0;
                }
                if (message.kind != null && message.hasOwnProperty("kind"))
                    object.kind = options.enums === String ? $root.lebai.modbus.ModbusRegisterKind[message.kind] === undefined ? message.kind : $root.lebai.modbus.ModbusRegisterKind[message.kind] : message.kind;
                if (message.address != null && message.hasOwnProperty("address"))
                    object.address = message.address;
                return object;
            };

            /**
             * Converts this ModbusRegister to JSON.
             * @function toJSON
             * @memberof lebai.modbus.ModbusRegister
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ModbusRegister.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ModbusRegister
             * @function getTypeUrl
             * @memberof lebai.modbus.ModbusRegister
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ModbusRegister.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.modbus.ModbusRegister";
            };

            return ModbusRegister;
        })();

        modbus.SaveModbusRegisterRequest = (function() {

            /**
             * Properties of a SaveModbusRegisterRequest.
             * @memberof lebai.modbus
             * @interface ISaveModbusRegisterRequest
             * @property {string|null} [device] SaveModbusRegisterRequest device
             * @property {string|null} [name] SaveModbusRegisterRequest name
             * @property {lebai.modbus.IModbusRegister|null} [data] SaveModbusRegisterRequest data
             */

            /**
             * Constructs a new SaveModbusRegisterRequest.
             * @memberof lebai.modbus
             * @classdesc Represents a SaveModbusRegisterRequest.
             * @implements ISaveModbusRegisterRequest
             * @constructor
             * @param {lebai.modbus.ISaveModbusRegisterRequest=} [properties] Properties to set
             */
            function SaveModbusRegisterRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SaveModbusRegisterRequest device.
             * @member {string} device
             * @memberof lebai.modbus.SaveModbusRegisterRequest
             * @instance
             */
            SaveModbusRegisterRequest.prototype.device = "";

            /**
             * SaveModbusRegisterRequest name.
             * @member {string} name
             * @memberof lebai.modbus.SaveModbusRegisterRequest
             * @instance
             */
            SaveModbusRegisterRequest.prototype.name = "";

            /**
             * SaveModbusRegisterRequest data.
             * @member {lebai.modbus.IModbusRegister|null|undefined} data
             * @memberof lebai.modbus.SaveModbusRegisterRequest
             * @instance
             */
            SaveModbusRegisterRequest.prototype.data = null;

            /**
             * Creates a new SaveModbusRegisterRequest instance using the specified properties.
             * @function create
             * @memberof lebai.modbus.SaveModbusRegisterRequest
             * @static
             * @param {lebai.modbus.ISaveModbusRegisterRequest=} [properties] Properties to set
             * @returns {lebai.modbus.SaveModbusRegisterRequest} SaveModbusRegisterRequest instance
             */
            SaveModbusRegisterRequest.create = function create(properties) {
                return new SaveModbusRegisterRequest(properties);
            };

            /**
             * Encodes the specified SaveModbusRegisterRequest message. Does not implicitly {@link lebai.modbus.SaveModbusRegisterRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.modbus.SaveModbusRegisterRequest
             * @static
             * @param {lebai.modbus.ISaveModbusRegisterRequest} message SaveModbusRegisterRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SaveModbusRegisterRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.device != null && Object.hasOwnProperty.call(message, "device"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.device);
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    $root.lebai.modbus.ModbusRegister.encode(message.data, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified SaveModbusRegisterRequest message, length delimited. Does not implicitly {@link lebai.modbus.SaveModbusRegisterRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.modbus.SaveModbusRegisterRequest
             * @static
             * @param {lebai.modbus.ISaveModbusRegisterRequest} message SaveModbusRegisterRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SaveModbusRegisterRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SaveModbusRegisterRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.modbus.SaveModbusRegisterRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.modbus.SaveModbusRegisterRequest} SaveModbusRegisterRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SaveModbusRegisterRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.modbus.SaveModbusRegisterRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.device = reader.string();
                            break;
                        }
                    case 2: {
                            message.name = reader.string();
                            break;
                        }
                    case 11: {
                            message.data = $root.lebai.modbus.ModbusRegister.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SaveModbusRegisterRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.modbus.SaveModbusRegisterRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.modbus.SaveModbusRegisterRequest} SaveModbusRegisterRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SaveModbusRegisterRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SaveModbusRegisterRequest message.
             * @function verify
             * @memberof lebai.modbus.SaveModbusRegisterRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SaveModbusRegisterRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.device != null && message.hasOwnProperty("device"))
                    if (!$util.isString(message.device))
                        return "device: string expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.data != null && message.hasOwnProperty("data")) {
                    var error = $root.lebai.modbus.ModbusRegister.verify(message.data);
                    if (error)
                        return "data." + error;
                }
                return null;
            };

            /**
             * Creates a SaveModbusRegisterRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.modbus.SaveModbusRegisterRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.modbus.SaveModbusRegisterRequest} SaveModbusRegisterRequest
             */
            SaveModbusRegisterRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.modbus.SaveModbusRegisterRequest)
                    return object;
                var message = new $root.lebai.modbus.SaveModbusRegisterRequest();
                if (object.device != null)
                    message.device = String(object.device);
                if (object.name != null)
                    message.name = String(object.name);
                if (object.data != null) {
                    if (typeof object.data !== "object")
                        throw TypeError(".lebai.modbus.SaveModbusRegisterRequest.data: object expected");
                    message.data = $root.lebai.modbus.ModbusRegister.fromObject(object.data);
                }
                return message;
            };

            /**
             * Creates a plain object from a SaveModbusRegisterRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.modbus.SaveModbusRegisterRequest
             * @static
             * @param {lebai.modbus.SaveModbusRegisterRequest} message SaveModbusRegisterRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SaveModbusRegisterRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.device = "";
                    object.name = "";
                    object.data = null;
                }
                if (message.device != null && message.hasOwnProperty("device"))
                    object.device = message.device;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.data != null && message.hasOwnProperty("data"))
                    object.data = $root.lebai.modbus.ModbusRegister.toObject(message.data, options);
                return object;
            };

            /**
             * Converts this SaveModbusRegisterRequest to JSON.
             * @function toJSON
             * @memberof lebai.modbus.SaveModbusRegisterRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SaveModbusRegisterRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SaveModbusRegisterRequest
             * @function getTypeUrl
             * @memberof lebai.modbus.SaveModbusRegisterRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SaveModbusRegisterRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.modbus.SaveModbusRegisterRequest";
            };

            return SaveModbusRegisterRequest;
        })();

        modbus.LoadModbusRegisterRequest = (function() {

            /**
             * Properties of a LoadModbusRegisterRequest.
             * @memberof lebai.modbus
             * @interface ILoadModbusRegisterRequest
             * @property {string|null} [device] LoadModbusRegisterRequest device
             * @property {string|null} [name] LoadModbusRegisterRequest name
             */

            /**
             * Constructs a new LoadModbusRegisterRequest.
             * @memberof lebai.modbus
             * @classdesc Represents a LoadModbusRegisterRequest.
             * @implements ILoadModbusRegisterRequest
             * @constructor
             * @param {lebai.modbus.ILoadModbusRegisterRequest=} [properties] Properties to set
             */
            function LoadModbusRegisterRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LoadModbusRegisterRequest device.
             * @member {string} device
             * @memberof lebai.modbus.LoadModbusRegisterRequest
             * @instance
             */
            LoadModbusRegisterRequest.prototype.device = "";

            /**
             * LoadModbusRegisterRequest name.
             * @member {string} name
             * @memberof lebai.modbus.LoadModbusRegisterRequest
             * @instance
             */
            LoadModbusRegisterRequest.prototype.name = "";

            /**
             * Creates a new LoadModbusRegisterRequest instance using the specified properties.
             * @function create
             * @memberof lebai.modbus.LoadModbusRegisterRequest
             * @static
             * @param {lebai.modbus.ILoadModbusRegisterRequest=} [properties] Properties to set
             * @returns {lebai.modbus.LoadModbusRegisterRequest} LoadModbusRegisterRequest instance
             */
            LoadModbusRegisterRequest.create = function create(properties) {
                return new LoadModbusRegisterRequest(properties);
            };

            /**
             * Encodes the specified LoadModbusRegisterRequest message. Does not implicitly {@link lebai.modbus.LoadModbusRegisterRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.modbus.LoadModbusRegisterRequest
             * @static
             * @param {lebai.modbus.ILoadModbusRegisterRequest} message LoadModbusRegisterRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LoadModbusRegisterRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.device != null && Object.hasOwnProperty.call(message, "device"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.device);
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                return writer;
            };

            /**
             * Encodes the specified LoadModbusRegisterRequest message, length delimited. Does not implicitly {@link lebai.modbus.LoadModbusRegisterRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.modbus.LoadModbusRegisterRequest
             * @static
             * @param {lebai.modbus.ILoadModbusRegisterRequest} message LoadModbusRegisterRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LoadModbusRegisterRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LoadModbusRegisterRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.modbus.LoadModbusRegisterRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.modbus.LoadModbusRegisterRequest} LoadModbusRegisterRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LoadModbusRegisterRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.modbus.LoadModbusRegisterRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.device = reader.string();
                            break;
                        }
                    case 2: {
                            message.name = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LoadModbusRegisterRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.modbus.LoadModbusRegisterRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.modbus.LoadModbusRegisterRequest} LoadModbusRegisterRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LoadModbusRegisterRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LoadModbusRegisterRequest message.
             * @function verify
             * @memberof lebai.modbus.LoadModbusRegisterRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LoadModbusRegisterRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.device != null && message.hasOwnProperty("device"))
                    if (!$util.isString(message.device))
                        return "device: string expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                return null;
            };

            /**
             * Creates a LoadModbusRegisterRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.modbus.LoadModbusRegisterRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.modbus.LoadModbusRegisterRequest} LoadModbusRegisterRequest
             */
            LoadModbusRegisterRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.modbus.LoadModbusRegisterRequest)
                    return object;
                var message = new $root.lebai.modbus.LoadModbusRegisterRequest();
                if (object.device != null)
                    message.device = String(object.device);
                if (object.name != null)
                    message.name = String(object.name);
                return message;
            };

            /**
             * Creates a plain object from a LoadModbusRegisterRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.modbus.LoadModbusRegisterRequest
             * @static
             * @param {lebai.modbus.LoadModbusRegisterRequest} message LoadModbusRegisterRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LoadModbusRegisterRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.device = "";
                    object.name = "";
                }
                if (message.device != null && message.hasOwnProperty("device"))
                    object.device = message.device;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                return object;
            };

            /**
             * Converts this LoadModbusRegisterRequest to JSON.
             * @function toJSON
             * @memberof lebai.modbus.LoadModbusRegisterRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LoadModbusRegisterRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for LoadModbusRegisterRequest
             * @function getTypeUrl
             * @memberof lebai.modbus.LoadModbusRegisterRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            LoadModbusRegisterRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.modbus.LoadModbusRegisterRequest";
            };

            return LoadModbusRegisterRequest;
        })();

        modbus.LoadModbusRegisterListRequest = (function() {

            /**
             * Properties of a LoadModbusRegisterListRequest.
             * @memberof lebai.modbus
             * @interface ILoadModbusRegisterListRequest
             * @property {string|null} [device] LoadModbusRegisterListRequest device
             */

            /**
             * Constructs a new LoadModbusRegisterListRequest.
             * @memberof lebai.modbus
             * @classdesc Represents a LoadModbusRegisterListRequest.
             * @implements ILoadModbusRegisterListRequest
             * @constructor
             * @param {lebai.modbus.ILoadModbusRegisterListRequest=} [properties] Properties to set
             */
            function LoadModbusRegisterListRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LoadModbusRegisterListRequest device.
             * @member {string} device
             * @memberof lebai.modbus.LoadModbusRegisterListRequest
             * @instance
             */
            LoadModbusRegisterListRequest.prototype.device = "";

            /**
             * Creates a new LoadModbusRegisterListRequest instance using the specified properties.
             * @function create
             * @memberof lebai.modbus.LoadModbusRegisterListRequest
             * @static
             * @param {lebai.modbus.ILoadModbusRegisterListRequest=} [properties] Properties to set
             * @returns {lebai.modbus.LoadModbusRegisterListRequest} LoadModbusRegisterListRequest instance
             */
            LoadModbusRegisterListRequest.create = function create(properties) {
                return new LoadModbusRegisterListRequest(properties);
            };

            /**
             * Encodes the specified LoadModbusRegisterListRequest message. Does not implicitly {@link lebai.modbus.LoadModbusRegisterListRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.modbus.LoadModbusRegisterListRequest
             * @static
             * @param {lebai.modbus.ILoadModbusRegisterListRequest} message LoadModbusRegisterListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LoadModbusRegisterListRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.device != null && Object.hasOwnProperty.call(message, "device"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.device);
                return writer;
            };

            /**
             * Encodes the specified LoadModbusRegisterListRequest message, length delimited. Does not implicitly {@link lebai.modbus.LoadModbusRegisterListRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.modbus.LoadModbusRegisterListRequest
             * @static
             * @param {lebai.modbus.ILoadModbusRegisterListRequest} message LoadModbusRegisterListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LoadModbusRegisterListRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LoadModbusRegisterListRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.modbus.LoadModbusRegisterListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.modbus.LoadModbusRegisterListRequest} LoadModbusRegisterListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LoadModbusRegisterListRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.modbus.LoadModbusRegisterListRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.device = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LoadModbusRegisterListRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.modbus.LoadModbusRegisterListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.modbus.LoadModbusRegisterListRequest} LoadModbusRegisterListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LoadModbusRegisterListRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LoadModbusRegisterListRequest message.
             * @function verify
             * @memberof lebai.modbus.LoadModbusRegisterListRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LoadModbusRegisterListRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.device != null && message.hasOwnProperty("device"))
                    if (!$util.isString(message.device))
                        return "device: string expected";
                return null;
            };

            /**
             * Creates a LoadModbusRegisterListRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.modbus.LoadModbusRegisterListRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.modbus.LoadModbusRegisterListRequest} LoadModbusRegisterListRequest
             */
            LoadModbusRegisterListRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.modbus.LoadModbusRegisterListRequest)
                    return object;
                var message = new $root.lebai.modbus.LoadModbusRegisterListRequest();
                if (object.device != null)
                    message.device = String(object.device);
                return message;
            };

            /**
             * Creates a plain object from a LoadModbusRegisterListRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.modbus.LoadModbusRegisterListRequest
             * @static
             * @param {lebai.modbus.LoadModbusRegisterListRequest} message LoadModbusRegisterListRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LoadModbusRegisterListRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.device = "";
                if (message.device != null && message.hasOwnProperty("device"))
                    object.device = message.device;
                return object;
            };

            /**
             * Converts this LoadModbusRegisterListRequest to JSON.
             * @function toJSON
             * @memberof lebai.modbus.LoadModbusRegisterListRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LoadModbusRegisterListRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for LoadModbusRegisterListRequest
             * @function getTypeUrl
             * @memberof lebai.modbus.LoadModbusRegisterListRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            LoadModbusRegisterListRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.modbus.LoadModbusRegisterListRequest";
            };

            return LoadModbusRegisterListRequest;
        })();

        modbus.SetModbusTimeoutRequest = (function() {

            /**
             * Properties of a SetModbusTimeoutRequest.
             * @memberof lebai.modbus
             * @interface ISetModbusTimeoutRequest
             * @property {string|null} [device] SetModbusTimeoutRequest device
             * @property {number|null} [timeout] SetModbusTimeoutRequest timeout
             */

            /**
             * Constructs a new SetModbusTimeoutRequest.
             * @memberof lebai.modbus
             * @classdesc Represents a SetModbusTimeoutRequest.
             * @implements ISetModbusTimeoutRequest
             * @constructor
             * @param {lebai.modbus.ISetModbusTimeoutRequest=} [properties] Properties to set
             */
            function SetModbusTimeoutRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SetModbusTimeoutRequest device.
             * @member {string} device
             * @memberof lebai.modbus.SetModbusTimeoutRequest
             * @instance
             */
            SetModbusTimeoutRequest.prototype.device = "";

            /**
             * SetModbusTimeoutRequest timeout.
             * @member {number} timeout
             * @memberof lebai.modbus.SetModbusTimeoutRequest
             * @instance
             */
            SetModbusTimeoutRequest.prototype.timeout = 0;

            /**
             * Creates a new SetModbusTimeoutRequest instance using the specified properties.
             * @function create
             * @memberof lebai.modbus.SetModbusTimeoutRequest
             * @static
             * @param {lebai.modbus.ISetModbusTimeoutRequest=} [properties] Properties to set
             * @returns {lebai.modbus.SetModbusTimeoutRequest} SetModbusTimeoutRequest instance
             */
            SetModbusTimeoutRequest.create = function create(properties) {
                return new SetModbusTimeoutRequest(properties);
            };

            /**
             * Encodes the specified SetModbusTimeoutRequest message. Does not implicitly {@link lebai.modbus.SetModbusTimeoutRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.modbus.SetModbusTimeoutRequest
             * @static
             * @param {lebai.modbus.ISetModbusTimeoutRequest} message SetModbusTimeoutRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetModbusTimeoutRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.device != null && Object.hasOwnProperty.call(message, "device"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.device);
                if (message.timeout != null && Object.hasOwnProperty.call(message, "timeout"))
                    writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.timeout);
                return writer;
            };

            /**
             * Encodes the specified SetModbusTimeoutRequest message, length delimited. Does not implicitly {@link lebai.modbus.SetModbusTimeoutRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.modbus.SetModbusTimeoutRequest
             * @static
             * @param {lebai.modbus.ISetModbusTimeoutRequest} message SetModbusTimeoutRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetModbusTimeoutRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetModbusTimeoutRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.modbus.SetModbusTimeoutRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.modbus.SetModbusTimeoutRequest} SetModbusTimeoutRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetModbusTimeoutRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.modbus.SetModbusTimeoutRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.device = reader.string();
                            break;
                        }
                    case 11: {
                            message.timeout = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetModbusTimeoutRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.modbus.SetModbusTimeoutRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.modbus.SetModbusTimeoutRequest} SetModbusTimeoutRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetModbusTimeoutRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetModbusTimeoutRequest message.
             * @function verify
             * @memberof lebai.modbus.SetModbusTimeoutRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetModbusTimeoutRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.device != null && message.hasOwnProperty("device"))
                    if (!$util.isString(message.device))
                        return "device: string expected";
                if (message.timeout != null && message.hasOwnProperty("timeout"))
                    if (!$util.isInteger(message.timeout))
                        return "timeout: integer expected";
                return null;
            };

            /**
             * Creates a SetModbusTimeoutRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.modbus.SetModbusTimeoutRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.modbus.SetModbusTimeoutRequest} SetModbusTimeoutRequest
             */
            SetModbusTimeoutRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.modbus.SetModbusTimeoutRequest)
                    return object;
                var message = new $root.lebai.modbus.SetModbusTimeoutRequest();
                if (object.device != null)
                    message.device = String(object.device);
                if (object.timeout != null)
                    message.timeout = object.timeout >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a SetModbusTimeoutRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.modbus.SetModbusTimeoutRequest
             * @static
             * @param {lebai.modbus.SetModbusTimeoutRequest} message SetModbusTimeoutRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetModbusTimeoutRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.device = "";
                    object.timeout = 0;
                }
                if (message.device != null && message.hasOwnProperty("device"))
                    object.device = message.device;
                if (message.timeout != null && message.hasOwnProperty("timeout"))
                    object.timeout = message.timeout;
                return object;
            };

            /**
             * Converts this SetModbusTimeoutRequest to JSON.
             * @function toJSON
             * @memberof lebai.modbus.SetModbusTimeoutRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetModbusTimeoutRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetModbusTimeoutRequest
             * @function getTypeUrl
             * @memberof lebai.modbus.SetModbusTimeoutRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetModbusTimeoutRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.modbus.SetModbusTimeoutRequest";
            };

            return SetModbusTimeoutRequest;
        })();

        modbus.SetCoilRequest = (function() {

            /**
             * Properties of a SetCoilRequest.
             * @memberof lebai.modbus
             * @interface ISetCoilRequest
             * @property {string|null} [device] SetCoilRequest device
             * @property {string|null} [pin] SetCoilRequest pin
             * @property {boolean|null} [value] SetCoilRequest value
             */

            /**
             * Constructs a new SetCoilRequest.
             * @memberof lebai.modbus
             * @classdesc Represents a SetCoilRequest.
             * @implements ISetCoilRequest
             * @constructor
             * @param {lebai.modbus.ISetCoilRequest=} [properties] Properties to set
             */
            function SetCoilRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SetCoilRequest device.
             * @member {string} device
             * @memberof lebai.modbus.SetCoilRequest
             * @instance
             */
            SetCoilRequest.prototype.device = "";

            /**
             * SetCoilRequest pin.
             * @member {string} pin
             * @memberof lebai.modbus.SetCoilRequest
             * @instance
             */
            SetCoilRequest.prototype.pin = "";

            /**
             * SetCoilRequest value.
             * @member {boolean} value
             * @memberof lebai.modbus.SetCoilRequest
             * @instance
             */
            SetCoilRequest.prototype.value = false;

            /**
             * Creates a new SetCoilRequest instance using the specified properties.
             * @function create
             * @memberof lebai.modbus.SetCoilRequest
             * @static
             * @param {lebai.modbus.ISetCoilRequest=} [properties] Properties to set
             * @returns {lebai.modbus.SetCoilRequest} SetCoilRequest instance
             */
            SetCoilRequest.create = function create(properties) {
                return new SetCoilRequest(properties);
            };

            /**
             * Encodes the specified SetCoilRequest message. Does not implicitly {@link lebai.modbus.SetCoilRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.modbus.SetCoilRequest
             * @static
             * @param {lebai.modbus.ISetCoilRequest} message SetCoilRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetCoilRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.device != null && Object.hasOwnProperty.call(message, "device"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.device);
                if (message.pin != null && Object.hasOwnProperty.call(message, "pin"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.pin);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 11, wireType 0 =*/88).bool(message.value);
                return writer;
            };

            /**
             * Encodes the specified SetCoilRequest message, length delimited. Does not implicitly {@link lebai.modbus.SetCoilRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.modbus.SetCoilRequest
             * @static
             * @param {lebai.modbus.ISetCoilRequest} message SetCoilRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetCoilRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetCoilRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.modbus.SetCoilRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.modbus.SetCoilRequest} SetCoilRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetCoilRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.modbus.SetCoilRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.device = reader.string();
                            break;
                        }
                    case 2: {
                            message.pin = reader.string();
                            break;
                        }
                    case 11: {
                            message.value = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetCoilRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.modbus.SetCoilRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.modbus.SetCoilRequest} SetCoilRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetCoilRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetCoilRequest message.
             * @function verify
             * @memberof lebai.modbus.SetCoilRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetCoilRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.device != null && message.hasOwnProperty("device"))
                    if (!$util.isString(message.device))
                        return "device: string expected";
                if (message.pin != null && message.hasOwnProperty("pin"))
                    if (!$util.isString(message.pin))
                        return "pin: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (typeof message.value !== "boolean")
                        return "value: boolean expected";
                return null;
            };

            /**
             * Creates a SetCoilRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.modbus.SetCoilRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.modbus.SetCoilRequest} SetCoilRequest
             */
            SetCoilRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.modbus.SetCoilRequest)
                    return object;
                var message = new $root.lebai.modbus.SetCoilRequest();
                if (object.device != null)
                    message.device = String(object.device);
                if (object.pin != null)
                    message.pin = String(object.pin);
                if (object.value != null)
                    message.value = Boolean(object.value);
                return message;
            };

            /**
             * Creates a plain object from a SetCoilRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.modbus.SetCoilRequest
             * @static
             * @param {lebai.modbus.SetCoilRequest} message SetCoilRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetCoilRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.device = "";
                    object.pin = "";
                    object.value = false;
                }
                if (message.device != null && message.hasOwnProperty("device"))
                    object.device = message.device;
                if (message.pin != null && message.hasOwnProperty("pin"))
                    object.pin = message.pin;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                return object;
            };

            /**
             * Converts this SetCoilRequest to JSON.
             * @function toJSON
             * @memberof lebai.modbus.SetCoilRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetCoilRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetCoilRequest
             * @function getTypeUrl
             * @memberof lebai.modbus.SetCoilRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetCoilRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.modbus.SetCoilRequest";
            };

            return SetCoilRequest;
        })();

        modbus.SetCoilsRequest = (function() {

            /**
             * Properties of a SetCoilsRequest.
             * @memberof lebai.modbus
             * @interface ISetCoilsRequest
             * @property {string|null} [device] SetCoilsRequest device
             * @property {string|null} [pin] SetCoilsRequest pin
             * @property {Array.<boolean>|null} [values] SetCoilsRequest values
             */

            /**
             * Constructs a new SetCoilsRequest.
             * @memberof lebai.modbus
             * @classdesc Represents a SetCoilsRequest.
             * @implements ISetCoilsRequest
             * @constructor
             * @param {lebai.modbus.ISetCoilsRequest=} [properties] Properties to set
             */
            function SetCoilsRequest(properties) {
                this.values = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SetCoilsRequest device.
             * @member {string} device
             * @memberof lebai.modbus.SetCoilsRequest
             * @instance
             */
            SetCoilsRequest.prototype.device = "";

            /**
             * SetCoilsRequest pin.
             * @member {string} pin
             * @memberof lebai.modbus.SetCoilsRequest
             * @instance
             */
            SetCoilsRequest.prototype.pin = "";

            /**
             * SetCoilsRequest values.
             * @member {Array.<boolean>} values
             * @memberof lebai.modbus.SetCoilsRequest
             * @instance
             */
            SetCoilsRequest.prototype.values = $util.emptyArray;

            /**
             * Creates a new SetCoilsRequest instance using the specified properties.
             * @function create
             * @memberof lebai.modbus.SetCoilsRequest
             * @static
             * @param {lebai.modbus.ISetCoilsRequest=} [properties] Properties to set
             * @returns {lebai.modbus.SetCoilsRequest} SetCoilsRequest instance
             */
            SetCoilsRequest.create = function create(properties) {
                return new SetCoilsRequest(properties);
            };

            /**
             * Encodes the specified SetCoilsRequest message. Does not implicitly {@link lebai.modbus.SetCoilsRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.modbus.SetCoilsRequest
             * @static
             * @param {lebai.modbus.ISetCoilsRequest} message SetCoilsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetCoilsRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.device != null && Object.hasOwnProperty.call(message, "device"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.device);
                if (message.pin != null && Object.hasOwnProperty.call(message, "pin"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.pin);
                if (message.values != null && message.values.length) {
                    writer.uint32(/* id 11, wireType 2 =*/90).fork();
                    for (var i = 0; i < message.values.length; ++i)
                        writer.bool(message.values[i]);
                    writer.ldelim();
                }
                return writer;
            };

            /**
             * Encodes the specified SetCoilsRequest message, length delimited. Does not implicitly {@link lebai.modbus.SetCoilsRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.modbus.SetCoilsRequest
             * @static
             * @param {lebai.modbus.ISetCoilsRequest} message SetCoilsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetCoilsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetCoilsRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.modbus.SetCoilsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.modbus.SetCoilsRequest} SetCoilsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetCoilsRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.modbus.SetCoilsRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.device = reader.string();
                            break;
                        }
                    case 2: {
                            message.pin = reader.string();
                            break;
                        }
                    case 11: {
                            if (!(message.values && message.values.length))
                                message.values = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.values.push(reader.bool());
                            } else
                                message.values.push(reader.bool());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetCoilsRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.modbus.SetCoilsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.modbus.SetCoilsRequest} SetCoilsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetCoilsRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetCoilsRequest message.
             * @function verify
             * @memberof lebai.modbus.SetCoilsRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetCoilsRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.device != null && message.hasOwnProperty("device"))
                    if (!$util.isString(message.device))
                        return "device: string expected";
                if (message.pin != null && message.hasOwnProperty("pin"))
                    if (!$util.isString(message.pin))
                        return "pin: string expected";
                if (message.values != null && message.hasOwnProperty("values")) {
                    if (!Array.isArray(message.values))
                        return "values: array expected";
                    for (var i = 0; i < message.values.length; ++i)
                        if (typeof message.values[i] !== "boolean")
                            return "values: boolean[] expected";
                }
                return null;
            };

            /**
             * Creates a SetCoilsRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.modbus.SetCoilsRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.modbus.SetCoilsRequest} SetCoilsRequest
             */
            SetCoilsRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.modbus.SetCoilsRequest)
                    return object;
                var message = new $root.lebai.modbus.SetCoilsRequest();
                if (object.device != null)
                    message.device = String(object.device);
                if (object.pin != null)
                    message.pin = String(object.pin);
                if (object.values) {
                    if (!Array.isArray(object.values))
                        throw TypeError(".lebai.modbus.SetCoilsRequest.values: array expected");
                    message.values = [];
                    for (var i = 0; i < object.values.length; ++i)
                        message.values[i] = Boolean(object.values[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a SetCoilsRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.modbus.SetCoilsRequest
             * @static
             * @param {lebai.modbus.SetCoilsRequest} message SetCoilsRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetCoilsRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.values = [];
                if (options.defaults) {
                    object.device = "";
                    object.pin = "";
                }
                if (message.device != null && message.hasOwnProperty("device"))
                    object.device = message.device;
                if (message.pin != null && message.hasOwnProperty("pin"))
                    object.pin = message.pin;
                if (message.values && message.values.length) {
                    object.values = [];
                    for (var j = 0; j < message.values.length; ++j)
                        object.values[j] = message.values[j];
                }
                return object;
            };

            /**
             * Converts this SetCoilsRequest to JSON.
             * @function toJSON
             * @memberof lebai.modbus.SetCoilsRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetCoilsRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetCoilsRequest
             * @function getTypeUrl
             * @memberof lebai.modbus.SetCoilsRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetCoilsRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.modbus.SetCoilsRequest";
            };

            return SetCoilsRequest;
        })();

        modbus.GetCoilRequest = (function() {

            /**
             * Properties of a GetCoilRequest.
             * @memberof lebai.modbus
             * @interface IGetCoilRequest
             * @property {string|null} [device] GetCoilRequest device
             * @property {string|null} [pin] GetCoilRequest pin
             */

            /**
             * Constructs a new GetCoilRequest.
             * @memberof lebai.modbus
             * @classdesc Represents a GetCoilRequest.
             * @implements IGetCoilRequest
             * @constructor
             * @param {lebai.modbus.IGetCoilRequest=} [properties] Properties to set
             */
            function GetCoilRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetCoilRequest device.
             * @member {string} device
             * @memberof lebai.modbus.GetCoilRequest
             * @instance
             */
            GetCoilRequest.prototype.device = "";

            /**
             * GetCoilRequest pin.
             * @member {string} pin
             * @memberof lebai.modbus.GetCoilRequest
             * @instance
             */
            GetCoilRequest.prototype.pin = "";

            /**
             * Creates a new GetCoilRequest instance using the specified properties.
             * @function create
             * @memberof lebai.modbus.GetCoilRequest
             * @static
             * @param {lebai.modbus.IGetCoilRequest=} [properties] Properties to set
             * @returns {lebai.modbus.GetCoilRequest} GetCoilRequest instance
             */
            GetCoilRequest.create = function create(properties) {
                return new GetCoilRequest(properties);
            };

            /**
             * Encodes the specified GetCoilRequest message. Does not implicitly {@link lebai.modbus.GetCoilRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.modbus.GetCoilRequest
             * @static
             * @param {lebai.modbus.IGetCoilRequest} message GetCoilRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetCoilRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.device != null && Object.hasOwnProperty.call(message, "device"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.device);
                if (message.pin != null && Object.hasOwnProperty.call(message, "pin"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.pin);
                return writer;
            };

            /**
             * Encodes the specified GetCoilRequest message, length delimited. Does not implicitly {@link lebai.modbus.GetCoilRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.modbus.GetCoilRequest
             * @static
             * @param {lebai.modbus.IGetCoilRequest} message GetCoilRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetCoilRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetCoilRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.modbus.GetCoilRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.modbus.GetCoilRequest} GetCoilRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetCoilRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.modbus.GetCoilRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.device = reader.string();
                            break;
                        }
                    case 2: {
                            message.pin = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetCoilRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.modbus.GetCoilRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.modbus.GetCoilRequest} GetCoilRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetCoilRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetCoilRequest message.
             * @function verify
             * @memberof lebai.modbus.GetCoilRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetCoilRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.device != null && message.hasOwnProperty("device"))
                    if (!$util.isString(message.device))
                        return "device: string expected";
                if (message.pin != null && message.hasOwnProperty("pin"))
                    if (!$util.isString(message.pin))
                        return "pin: string expected";
                return null;
            };

            /**
             * Creates a GetCoilRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.modbus.GetCoilRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.modbus.GetCoilRequest} GetCoilRequest
             */
            GetCoilRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.modbus.GetCoilRequest)
                    return object;
                var message = new $root.lebai.modbus.GetCoilRequest();
                if (object.device != null)
                    message.device = String(object.device);
                if (object.pin != null)
                    message.pin = String(object.pin);
                return message;
            };

            /**
             * Creates a plain object from a GetCoilRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.modbus.GetCoilRequest
             * @static
             * @param {lebai.modbus.GetCoilRequest} message GetCoilRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetCoilRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.device = "";
                    object.pin = "";
                }
                if (message.device != null && message.hasOwnProperty("device"))
                    object.device = message.device;
                if (message.pin != null && message.hasOwnProperty("pin"))
                    object.pin = message.pin;
                return object;
            };

            /**
             * Converts this GetCoilRequest to JSON.
             * @function toJSON
             * @memberof lebai.modbus.GetCoilRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetCoilRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetCoilRequest
             * @function getTypeUrl
             * @memberof lebai.modbus.GetCoilRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetCoilRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.modbus.GetCoilRequest";
            };

            return GetCoilRequest;
        })();

        modbus.GetCoilResponse = (function() {

            /**
             * Properties of a GetCoilResponse.
             * @memberof lebai.modbus
             * @interface IGetCoilResponse
             * @property {boolean|null} [value] GetCoilResponse value
             */

            /**
             * Constructs a new GetCoilResponse.
             * @memberof lebai.modbus
             * @classdesc Represents a GetCoilResponse.
             * @implements IGetCoilResponse
             * @constructor
             * @param {lebai.modbus.IGetCoilResponse=} [properties] Properties to set
             */
            function GetCoilResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetCoilResponse value.
             * @member {boolean} value
             * @memberof lebai.modbus.GetCoilResponse
             * @instance
             */
            GetCoilResponse.prototype.value = false;

            /**
             * Creates a new GetCoilResponse instance using the specified properties.
             * @function create
             * @memberof lebai.modbus.GetCoilResponse
             * @static
             * @param {lebai.modbus.IGetCoilResponse=} [properties] Properties to set
             * @returns {lebai.modbus.GetCoilResponse} GetCoilResponse instance
             */
            GetCoilResponse.create = function create(properties) {
                return new GetCoilResponse(properties);
            };

            /**
             * Encodes the specified GetCoilResponse message. Does not implicitly {@link lebai.modbus.GetCoilResponse.verify|verify} messages.
             * @function encode
             * @memberof lebai.modbus.GetCoilResponse
             * @static
             * @param {lebai.modbus.IGetCoilResponse} message GetCoilResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetCoilResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 11, wireType 0 =*/88).bool(message.value);
                return writer;
            };

            /**
             * Encodes the specified GetCoilResponse message, length delimited. Does not implicitly {@link lebai.modbus.GetCoilResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.modbus.GetCoilResponse
             * @static
             * @param {lebai.modbus.IGetCoilResponse} message GetCoilResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetCoilResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetCoilResponse message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.modbus.GetCoilResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.modbus.GetCoilResponse} GetCoilResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetCoilResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.modbus.GetCoilResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 11: {
                            message.value = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetCoilResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.modbus.GetCoilResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.modbus.GetCoilResponse} GetCoilResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetCoilResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetCoilResponse message.
             * @function verify
             * @memberof lebai.modbus.GetCoilResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetCoilResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (typeof message.value !== "boolean")
                        return "value: boolean expected";
                return null;
            };

            /**
             * Creates a GetCoilResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.modbus.GetCoilResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.modbus.GetCoilResponse} GetCoilResponse
             */
            GetCoilResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.modbus.GetCoilResponse)
                    return object;
                var message = new $root.lebai.modbus.GetCoilResponse();
                if (object.value != null)
                    message.value = Boolean(object.value);
                return message;
            };

            /**
             * Creates a plain object from a GetCoilResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.modbus.GetCoilResponse
             * @static
             * @param {lebai.modbus.GetCoilResponse} message GetCoilResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetCoilResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.value = false;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                return object;
            };

            /**
             * Converts this GetCoilResponse to JSON.
             * @function toJSON
             * @memberof lebai.modbus.GetCoilResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetCoilResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetCoilResponse
             * @function getTypeUrl
             * @memberof lebai.modbus.GetCoilResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetCoilResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.modbus.GetCoilResponse";
            };

            return GetCoilResponse;
        })();

        modbus.GetCoilsRequest = (function() {

            /**
             * Properties of a GetCoilsRequest.
             * @memberof lebai.modbus
             * @interface IGetCoilsRequest
             * @property {string|null} [device] GetCoilsRequest device
             * @property {string|null} [pin] GetCoilsRequest pin
             * @property {number|null} [count] GetCoilsRequest count
             */

            /**
             * Constructs a new GetCoilsRequest.
             * @memberof lebai.modbus
             * @classdesc Represents a GetCoilsRequest.
             * @implements IGetCoilsRequest
             * @constructor
             * @param {lebai.modbus.IGetCoilsRequest=} [properties] Properties to set
             */
            function GetCoilsRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetCoilsRequest device.
             * @member {string} device
             * @memberof lebai.modbus.GetCoilsRequest
             * @instance
             */
            GetCoilsRequest.prototype.device = "";

            /**
             * GetCoilsRequest pin.
             * @member {string} pin
             * @memberof lebai.modbus.GetCoilsRequest
             * @instance
             */
            GetCoilsRequest.prototype.pin = "";

            /**
             * GetCoilsRequest count.
             * @member {number} count
             * @memberof lebai.modbus.GetCoilsRequest
             * @instance
             */
            GetCoilsRequest.prototype.count = 0;

            /**
             * Creates a new GetCoilsRequest instance using the specified properties.
             * @function create
             * @memberof lebai.modbus.GetCoilsRequest
             * @static
             * @param {lebai.modbus.IGetCoilsRequest=} [properties] Properties to set
             * @returns {lebai.modbus.GetCoilsRequest} GetCoilsRequest instance
             */
            GetCoilsRequest.create = function create(properties) {
                return new GetCoilsRequest(properties);
            };

            /**
             * Encodes the specified GetCoilsRequest message. Does not implicitly {@link lebai.modbus.GetCoilsRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.modbus.GetCoilsRequest
             * @static
             * @param {lebai.modbus.IGetCoilsRequest} message GetCoilsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetCoilsRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.device != null && Object.hasOwnProperty.call(message, "device"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.device);
                if (message.pin != null && Object.hasOwnProperty.call(message, "pin"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.pin);
                if (message.count != null && Object.hasOwnProperty.call(message, "count"))
                    writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.count);
                return writer;
            };

            /**
             * Encodes the specified GetCoilsRequest message, length delimited. Does not implicitly {@link lebai.modbus.GetCoilsRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.modbus.GetCoilsRequest
             * @static
             * @param {lebai.modbus.IGetCoilsRequest} message GetCoilsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetCoilsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetCoilsRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.modbus.GetCoilsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.modbus.GetCoilsRequest} GetCoilsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetCoilsRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.modbus.GetCoilsRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.device = reader.string();
                            break;
                        }
                    case 2: {
                            message.pin = reader.string();
                            break;
                        }
                    case 11: {
                            message.count = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetCoilsRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.modbus.GetCoilsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.modbus.GetCoilsRequest} GetCoilsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetCoilsRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetCoilsRequest message.
             * @function verify
             * @memberof lebai.modbus.GetCoilsRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetCoilsRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.device != null && message.hasOwnProperty("device"))
                    if (!$util.isString(message.device))
                        return "device: string expected";
                if (message.pin != null && message.hasOwnProperty("pin"))
                    if (!$util.isString(message.pin))
                        return "pin: string expected";
                if (message.count != null && message.hasOwnProperty("count"))
                    if (!$util.isInteger(message.count))
                        return "count: integer expected";
                return null;
            };

            /**
             * Creates a GetCoilsRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.modbus.GetCoilsRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.modbus.GetCoilsRequest} GetCoilsRequest
             */
            GetCoilsRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.modbus.GetCoilsRequest)
                    return object;
                var message = new $root.lebai.modbus.GetCoilsRequest();
                if (object.device != null)
                    message.device = String(object.device);
                if (object.pin != null)
                    message.pin = String(object.pin);
                if (object.count != null)
                    message.count = object.count >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a GetCoilsRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.modbus.GetCoilsRequest
             * @static
             * @param {lebai.modbus.GetCoilsRequest} message GetCoilsRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetCoilsRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.device = "";
                    object.pin = "";
                    object.count = 0;
                }
                if (message.device != null && message.hasOwnProperty("device"))
                    object.device = message.device;
                if (message.pin != null && message.hasOwnProperty("pin"))
                    object.pin = message.pin;
                if (message.count != null && message.hasOwnProperty("count"))
                    object.count = message.count;
                return object;
            };

            /**
             * Converts this GetCoilsRequest to JSON.
             * @function toJSON
             * @memberof lebai.modbus.GetCoilsRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetCoilsRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetCoilsRequest
             * @function getTypeUrl
             * @memberof lebai.modbus.GetCoilsRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetCoilsRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.modbus.GetCoilsRequest";
            };

            return GetCoilsRequest;
        })();

        modbus.GetCoilsResponse = (function() {

            /**
             * Properties of a GetCoilsResponse.
             * @memberof lebai.modbus
             * @interface IGetCoilsResponse
             * @property {Array.<boolean>|null} [values] GetCoilsResponse values
             */

            /**
             * Constructs a new GetCoilsResponse.
             * @memberof lebai.modbus
             * @classdesc Represents a GetCoilsResponse.
             * @implements IGetCoilsResponse
             * @constructor
             * @param {lebai.modbus.IGetCoilsResponse=} [properties] Properties to set
             */
            function GetCoilsResponse(properties) {
                this.values = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetCoilsResponse values.
             * @member {Array.<boolean>} values
             * @memberof lebai.modbus.GetCoilsResponse
             * @instance
             */
            GetCoilsResponse.prototype.values = $util.emptyArray;

            /**
             * Creates a new GetCoilsResponse instance using the specified properties.
             * @function create
             * @memberof lebai.modbus.GetCoilsResponse
             * @static
             * @param {lebai.modbus.IGetCoilsResponse=} [properties] Properties to set
             * @returns {lebai.modbus.GetCoilsResponse} GetCoilsResponse instance
             */
            GetCoilsResponse.create = function create(properties) {
                return new GetCoilsResponse(properties);
            };

            /**
             * Encodes the specified GetCoilsResponse message. Does not implicitly {@link lebai.modbus.GetCoilsResponse.verify|verify} messages.
             * @function encode
             * @memberof lebai.modbus.GetCoilsResponse
             * @static
             * @param {lebai.modbus.IGetCoilsResponse} message GetCoilsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetCoilsResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.values != null && message.values.length) {
                    writer.uint32(/* id 11, wireType 2 =*/90).fork();
                    for (var i = 0; i < message.values.length; ++i)
                        writer.bool(message.values[i]);
                    writer.ldelim();
                }
                return writer;
            };

            /**
             * Encodes the specified GetCoilsResponse message, length delimited. Does not implicitly {@link lebai.modbus.GetCoilsResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.modbus.GetCoilsResponse
             * @static
             * @param {lebai.modbus.IGetCoilsResponse} message GetCoilsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetCoilsResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetCoilsResponse message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.modbus.GetCoilsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.modbus.GetCoilsResponse} GetCoilsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetCoilsResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.modbus.GetCoilsResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 11: {
                            if (!(message.values && message.values.length))
                                message.values = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.values.push(reader.bool());
                            } else
                                message.values.push(reader.bool());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetCoilsResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.modbus.GetCoilsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.modbus.GetCoilsResponse} GetCoilsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetCoilsResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetCoilsResponse message.
             * @function verify
             * @memberof lebai.modbus.GetCoilsResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetCoilsResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.values != null && message.hasOwnProperty("values")) {
                    if (!Array.isArray(message.values))
                        return "values: array expected";
                    for (var i = 0; i < message.values.length; ++i)
                        if (typeof message.values[i] !== "boolean")
                            return "values: boolean[] expected";
                }
                return null;
            };

            /**
             * Creates a GetCoilsResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.modbus.GetCoilsResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.modbus.GetCoilsResponse} GetCoilsResponse
             */
            GetCoilsResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.modbus.GetCoilsResponse)
                    return object;
                var message = new $root.lebai.modbus.GetCoilsResponse();
                if (object.values) {
                    if (!Array.isArray(object.values))
                        throw TypeError(".lebai.modbus.GetCoilsResponse.values: array expected");
                    message.values = [];
                    for (var i = 0; i < object.values.length; ++i)
                        message.values[i] = Boolean(object.values[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a GetCoilsResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.modbus.GetCoilsResponse
             * @static
             * @param {lebai.modbus.GetCoilsResponse} message GetCoilsResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetCoilsResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.values = [];
                if (message.values && message.values.length) {
                    object.values = [];
                    for (var j = 0; j < message.values.length; ++j)
                        object.values[j] = message.values[j];
                }
                return object;
            };

            /**
             * Converts this GetCoilsResponse to JSON.
             * @function toJSON
             * @memberof lebai.modbus.GetCoilsResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetCoilsResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetCoilsResponse
             * @function getTypeUrl
             * @memberof lebai.modbus.GetCoilsResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetCoilsResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.modbus.GetCoilsResponse";
            };

            return GetCoilsResponse;
        })();

        modbus.SetRegisterRequest = (function() {

            /**
             * Properties of a SetRegisterRequest.
             * @memberof lebai.modbus
             * @interface ISetRegisterRequest
             * @property {string|null} [device] SetRegisterRequest device
             * @property {string|null} [pin] SetRegisterRequest pin
             * @property {number|null} [value] SetRegisterRequest value
             */

            /**
             * Constructs a new SetRegisterRequest.
             * @memberof lebai.modbus
             * @classdesc Represents a SetRegisterRequest.
             * @implements ISetRegisterRequest
             * @constructor
             * @param {lebai.modbus.ISetRegisterRequest=} [properties] Properties to set
             */
            function SetRegisterRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SetRegisterRequest device.
             * @member {string} device
             * @memberof lebai.modbus.SetRegisterRequest
             * @instance
             */
            SetRegisterRequest.prototype.device = "";

            /**
             * SetRegisterRequest pin.
             * @member {string} pin
             * @memberof lebai.modbus.SetRegisterRequest
             * @instance
             */
            SetRegisterRequest.prototype.pin = "";

            /**
             * SetRegisterRequest value.
             * @member {number} value
             * @memberof lebai.modbus.SetRegisterRequest
             * @instance
             */
            SetRegisterRequest.prototype.value = 0;

            /**
             * Creates a new SetRegisterRequest instance using the specified properties.
             * @function create
             * @memberof lebai.modbus.SetRegisterRequest
             * @static
             * @param {lebai.modbus.ISetRegisterRequest=} [properties] Properties to set
             * @returns {lebai.modbus.SetRegisterRequest} SetRegisterRequest instance
             */
            SetRegisterRequest.create = function create(properties) {
                return new SetRegisterRequest(properties);
            };

            /**
             * Encodes the specified SetRegisterRequest message. Does not implicitly {@link lebai.modbus.SetRegisterRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.modbus.SetRegisterRequest
             * @static
             * @param {lebai.modbus.ISetRegisterRequest} message SetRegisterRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetRegisterRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.device != null && Object.hasOwnProperty.call(message, "device"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.device);
                if (message.pin != null && Object.hasOwnProperty.call(message, "pin"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.pin);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.value);
                return writer;
            };

            /**
             * Encodes the specified SetRegisterRequest message, length delimited. Does not implicitly {@link lebai.modbus.SetRegisterRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.modbus.SetRegisterRequest
             * @static
             * @param {lebai.modbus.ISetRegisterRequest} message SetRegisterRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetRegisterRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetRegisterRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.modbus.SetRegisterRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.modbus.SetRegisterRequest} SetRegisterRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetRegisterRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.modbus.SetRegisterRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.device = reader.string();
                            break;
                        }
                    case 2: {
                            message.pin = reader.string();
                            break;
                        }
                    case 11: {
                            message.value = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetRegisterRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.modbus.SetRegisterRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.modbus.SetRegisterRequest} SetRegisterRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetRegisterRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetRegisterRequest message.
             * @function verify
             * @memberof lebai.modbus.SetRegisterRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetRegisterRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.device != null && message.hasOwnProperty("device"))
                    if (!$util.isString(message.device))
                        return "device: string expected";
                if (message.pin != null && message.hasOwnProperty("pin"))
                    if (!$util.isString(message.pin))
                        return "pin: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isInteger(message.value))
                        return "value: integer expected";
                return null;
            };

            /**
             * Creates a SetRegisterRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.modbus.SetRegisterRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.modbus.SetRegisterRequest} SetRegisterRequest
             */
            SetRegisterRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.modbus.SetRegisterRequest)
                    return object;
                var message = new $root.lebai.modbus.SetRegisterRequest();
                if (object.device != null)
                    message.device = String(object.device);
                if (object.pin != null)
                    message.pin = String(object.pin);
                if (object.value != null)
                    message.value = object.value >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a SetRegisterRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.modbus.SetRegisterRequest
             * @static
             * @param {lebai.modbus.SetRegisterRequest} message SetRegisterRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetRegisterRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.device = "";
                    object.pin = "";
                    object.value = 0;
                }
                if (message.device != null && message.hasOwnProperty("device"))
                    object.device = message.device;
                if (message.pin != null && message.hasOwnProperty("pin"))
                    object.pin = message.pin;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                return object;
            };

            /**
             * Converts this SetRegisterRequest to JSON.
             * @function toJSON
             * @memberof lebai.modbus.SetRegisterRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetRegisterRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetRegisterRequest
             * @function getTypeUrl
             * @memberof lebai.modbus.SetRegisterRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetRegisterRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.modbus.SetRegisterRequest";
            };

            return SetRegisterRequest;
        })();

        modbus.SetRegistersRequest = (function() {

            /**
             * Properties of a SetRegistersRequest.
             * @memberof lebai.modbus
             * @interface ISetRegistersRequest
             * @property {string|null} [device] SetRegistersRequest device
             * @property {string|null} [pin] SetRegistersRequest pin
             * @property {Array.<number>|null} [values] SetRegistersRequest values
             */

            /**
             * Constructs a new SetRegistersRequest.
             * @memberof lebai.modbus
             * @classdesc Represents a SetRegistersRequest.
             * @implements ISetRegistersRequest
             * @constructor
             * @param {lebai.modbus.ISetRegistersRequest=} [properties] Properties to set
             */
            function SetRegistersRequest(properties) {
                this.values = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SetRegistersRequest device.
             * @member {string} device
             * @memberof lebai.modbus.SetRegistersRequest
             * @instance
             */
            SetRegistersRequest.prototype.device = "";

            /**
             * SetRegistersRequest pin.
             * @member {string} pin
             * @memberof lebai.modbus.SetRegistersRequest
             * @instance
             */
            SetRegistersRequest.prototype.pin = "";

            /**
             * SetRegistersRequest values.
             * @member {Array.<number>} values
             * @memberof lebai.modbus.SetRegistersRequest
             * @instance
             */
            SetRegistersRequest.prototype.values = $util.emptyArray;

            /**
             * Creates a new SetRegistersRequest instance using the specified properties.
             * @function create
             * @memberof lebai.modbus.SetRegistersRequest
             * @static
             * @param {lebai.modbus.ISetRegistersRequest=} [properties] Properties to set
             * @returns {lebai.modbus.SetRegistersRequest} SetRegistersRequest instance
             */
            SetRegistersRequest.create = function create(properties) {
                return new SetRegistersRequest(properties);
            };

            /**
             * Encodes the specified SetRegistersRequest message. Does not implicitly {@link lebai.modbus.SetRegistersRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.modbus.SetRegistersRequest
             * @static
             * @param {lebai.modbus.ISetRegistersRequest} message SetRegistersRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetRegistersRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.device != null && Object.hasOwnProperty.call(message, "device"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.device);
                if (message.pin != null && Object.hasOwnProperty.call(message, "pin"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.pin);
                if (message.values != null && message.values.length) {
                    writer.uint32(/* id 11, wireType 2 =*/90).fork();
                    for (var i = 0; i < message.values.length; ++i)
                        writer.uint32(message.values[i]);
                    writer.ldelim();
                }
                return writer;
            };

            /**
             * Encodes the specified SetRegistersRequest message, length delimited. Does not implicitly {@link lebai.modbus.SetRegistersRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.modbus.SetRegistersRequest
             * @static
             * @param {lebai.modbus.ISetRegistersRequest} message SetRegistersRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetRegistersRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetRegistersRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.modbus.SetRegistersRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.modbus.SetRegistersRequest} SetRegistersRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetRegistersRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.modbus.SetRegistersRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.device = reader.string();
                            break;
                        }
                    case 2: {
                            message.pin = reader.string();
                            break;
                        }
                    case 11: {
                            if (!(message.values && message.values.length))
                                message.values = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.values.push(reader.uint32());
                            } else
                                message.values.push(reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetRegistersRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.modbus.SetRegistersRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.modbus.SetRegistersRequest} SetRegistersRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetRegistersRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetRegistersRequest message.
             * @function verify
             * @memberof lebai.modbus.SetRegistersRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetRegistersRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.device != null && message.hasOwnProperty("device"))
                    if (!$util.isString(message.device))
                        return "device: string expected";
                if (message.pin != null && message.hasOwnProperty("pin"))
                    if (!$util.isString(message.pin))
                        return "pin: string expected";
                if (message.values != null && message.hasOwnProperty("values")) {
                    if (!Array.isArray(message.values))
                        return "values: array expected";
                    for (var i = 0; i < message.values.length; ++i)
                        if (!$util.isInteger(message.values[i]))
                            return "values: integer[] expected";
                }
                return null;
            };

            /**
             * Creates a SetRegistersRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.modbus.SetRegistersRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.modbus.SetRegistersRequest} SetRegistersRequest
             */
            SetRegistersRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.modbus.SetRegistersRequest)
                    return object;
                var message = new $root.lebai.modbus.SetRegistersRequest();
                if (object.device != null)
                    message.device = String(object.device);
                if (object.pin != null)
                    message.pin = String(object.pin);
                if (object.values) {
                    if (!Array.isArray(object.values))
                        throw TypeError(".lebai.modbus.SetRegistersRequest.values: array expected");
                    message.values = [];
                    for (var i = 0; i < object.values.length; ++i)
                        message.values[i] = object.values[i] >>> 0;
                }
                return message;
            };

            /**
             * Creates a plain object from a SetRegistersRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.modbus.SetRegistersRequest
             * @static
             * @param {lebai.modbus.SetRegistersRequest} message SetRegistersRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetRegistersRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.values = [];
                if (options.defaults) {
                    object.device = "";
                    object.pin = "";
                }
                if (message.device != null && message.hasOwnProperty("device"))
                    object.device = message.device;
                if (message.pin != null && message.hasOwnProperty("pin"))
                    object.pin = message.pin;
                if (message.values && message.values.length) {
                    object.values = [];
                    for (var j = 0; j < message.values.length; ++j)
                        object.values[j] = message.values[j];
                }
                return object;
            };

            /**
             * Converts this SetRegistersRequest to JSON.
             * @function toJSON
             * @memberof lebai.modbus.SetRegistersRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetRegistersRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetRegistersRequest
             * @function getTypeUrl
             * @memberof lebai.modbus.SetRegistersRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetRegistersRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.modbus.SetRegistersRequest";
            };

            return SetRegistersRequest;
        })();

        modbus.GetRegisterRequest = (function() {

            /**
             * Properties of a GetRegisterRequest.
             * @memberof lebai.modbus
             * @interface IGetRegisterRequest
             * @property {string|null} [device] GetRegisterRequest device
             * @property {string|null} [pin] GetRegisterRequest pin
             */

            /**
             * Constructs a new GetRegisterRequest.
             * @memberof lebai.modbus
             * @classdesc Represents a GetRegisterRequest.
             * @implements IGetRegisterRequest
             * @constructor
             * @param {lebai.modbus.IGetRegisterRequest=} [properties] Properties to set
             */
            function GetRegisterRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetRegisterRequest device.
             * @member {string} device
             * @memberof lebai.modbus.GetRegisterRequest
             * @instance
             */
            GetRegisterRequest.prototype.device = "";

            /**
             * GetRegisterRequest pin.
             * @member {string} pin
             * @memberof lebai.modbus.GetRegisterRequest
             * @instance
             */
            GetRegisterRequest.prototype.pin = "";

            /**
             * Creates a new GetRegisterRequest instance using the specified properties.
             * @function create
             * @memberof lebai.modbus.GetRegisterRequest
             * @static
             * @param {lebai.modbus.IGetRegisterRequest=} [properties] Properties to set
             * @returns {lebai.modbus.GetRegisterRequest} GetRegisterRequest instance
             */
            GetRegisterRequest.create = function create(properties) {
                return new GetRegisterRequest(properties);
            };

            /**
             * Encodes the specified GetRegisterRequest message. Does not implicitly {@link lebai.modbus.GetRegisterRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.modbus.GetRegisterRequest
             * @static
             * @param {lebai.modbus.IGetRegisterRequest} message GetRegisterRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetRegisterRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.device != null && Object.hasOwnProperty.call(message, "device"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.device);
                if (message.pin != null && Object.hasOwnProperty.call(message, "pin"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.pin);
                return writer;
            };

            /**
             * Encodes the specified GetRegisterRequest message, length delimited. Does not implicitly {@link lebai.modbus.GetRegisterRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.modbus.GetRegisterRequest
             * @static
             * @param {lebai.modbus.IGetRegisterRequest} message GetRegisterRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetRegisterRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetRegisterRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.modbus.GetRegisterRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.modbus.GetRegisterRequest} GetRegisterRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetRegisterRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.modbus.GetRegisterRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.device = reader.string();
                            break;
                        }
                    case 2: {
                            message.pin = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetRegisterRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.modbus.GetRegisterRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.modbus.GetRegisterRequest} GetRegisterRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetRegisterRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetRegisterRequest message.
             * @function verify
             * @memberof lebai.modbus.GetRegisterRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetRegisterRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.device != null && message.hasOwnProperty("device"))
                    if (!$util.isString(message.device))
                        return "device: string expected";
                if (message.pin != null && message.hasOwnProperty("pin"))
                    if (!$util.isString(message.pin))
                        return "pin: string expected";
                return null;
            };

            /**
             * Creates a GetRegisterRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.modbus.GetRegisterRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.modbus.GetRegisterRequest} GetRegisterRequest
             */
            GetRegisterRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.modbus.GetRegisterRequest)
                    return object;
                var message = new $root.lebai.modbus.GetRegisterRequest();
                if (object.device != null)
                    message.device = String(object.device);
                if (object.pin != null)
                    message.pin = String(object.pin);
                return message;
            };

            /**
             * Creates a plain object from a GetRegisterRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.modbus.GetRegisterRequest
             * @static
             * @param {lebai.modbus.GetRegisterRequest} message GetRegisterRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetRegisterRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.device = "";
                    object.pin = "";
                }
                if (message.device != null && message.hasOwnProperty("device"))
                    object.device = message.device;
                if (message.pin != null && message.hasOwnProperty("pin"))
                    object.pin = message.pin;
                return object;
            };

            /**
             * Converts this GetRegisterRequest to JSON.
             * @function toJSON
             * @memberof lebai.modbus.GetRegisterRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetRegisterRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetRegisterRequest
             * @function getTypeUrl
             * @memberof lebai.modbus.GetRegisterRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetRegisterRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.modbus.GetRegisterRequest";
            };

            return GetRegisterRequest;
        })();

        modbus.GetRegisterResponse = (function() {

            /**
             * Properties of a GetRegisterResponse.
             * @memberof lebai.modbus
             * @interface IGetRegisterResponse
             * @property {number|null} [value] GetRegisterResponse value
             */

            /**
             * Constructs a new GetRegisterResponse.
             * @memberof lebai.modbus
             * @classdesc Represents a GetRegisterResponse.
             * @implements IGetRegisterResponse
             * @constructor
             * @param {lebai.modbus.IGetRegisterResponse=} [properties] Properties to set
             */
            function GetRegisterResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetRegisterResponse value.
             * @member {number} value
             * @memberof lebai.modbus.GetRegisterResponse
             * @instance
             */
            GetRegisterResponse.prototype.value = 0;

            /**
             * Creates a new GetRegisterResponse instance using the specified properties.
             * @function create
             * @memberof lebai.modbus.GetRegisterResponse
             * @static
             * @param {lebai.modbus.IGetRegisterResponse=} [properties] Properties to set
             * @returns {lebai.modbus.GetRegisterResponse} GetRegisterResponse instance
             */
            GetRegisterResponse.create = function create(properties) {
                return new GetRegisterResponse(properties);
            };

            /**
             * Encodes the specified GetRegisterResponse message. Does not implicitly {@link lebai.modbus.GetRegisterResponse.verify|verify} messages.
             * @function encode
             * @memberof lebai.modbus.GetRegisterResponse
             * @static
             * @param {lebai.modbus.IGetRegisterResponse} message GetRegisterResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetRegisterResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.value);
                return writer;
            };

            /**
             * Encodes the specified GetRegisterResponse message, length delimited. Does not implicitly {@link lebai.modbus.GetRegisterResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.modbus.GetRegisterResponse
             * @static
             * @param {lebai.modbus.IGetRegisterResponse} message GetRegisterResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetRegisterResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetRegisterResponse message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.modbus.GetRegisterResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.modbus.GetRegisterResponse} GetRegisterResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetRegisterResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.modbus.GetRegisterResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 11: {
                            message.value = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetRegisterResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.modbus.GetRegisterResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.modbus.GetRegisterResponse} GetRegisterResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetRegisterResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetRegisterResponse message.
             * @function verify
             * @memberof lebai.modbus.GetRegisterResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetRegisterResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isInteger(message.value))
                        return "value: integer expected";
                return null;
            };

            /**
             * Creates a GetRegisterResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.modbus.GetRegisterResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.modbus.GetRegisterResponse} GetRegisterResponse
             */
            GetRegisterResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.modbus.GetRegisterResponse)
                    return object;
                var message = new $root.lebai.modbus.GetRegisterResponse();
                if (object.value != null)
                    message.value = object.value >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a GetRegisterResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.modbus.GetRegisterResponse
             * @static
             * @param {lebai.modbus.GetRegisterResponse} message GetRegisterResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetRegisterResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.value = 0;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                return object;
            };

            /**
             * Converts this GetRegisterResponse to JSON.
             * @function toJSON
             * @memberof lebai.modbus.GetRegisterResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetRegisterResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetRegisterResponse
             * @function getTypeUrl
             * @memberof lebai.modbus.GetRegisterResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetRegisterResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.modbus.GetRegisterResponse";
            };

            return GetRegisterResponse;
        })();

        modbus.GetRegistersRequest = (function() {

            /**
             * Properties of a GetRegistersRequest.
             * @memberof lebai.modbus
             * @interface IGetRegistersRequest
             * @property {string|null} [device] GetRegistersRequest device
             * @property {string|null} [pin] GetRegistersRequest pin
             * @property {number|null} [count] GetRegistersRequest count
             */

            /**
             * Constructs a new GetRegistersRequest.
             * @memberof lebai.modbus
             * @classdesc Represents a GetRegistersRequest.
             * @implements IGetRegistersRequest
             * @constructor
             * @param {lebai.modbus.IGetRegistersRequest=} [properties] Properties to set
             */
            function GetRegistersRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetRegistersRequest device.
             * @member {string} device
             * @memberof lebai.modbus.GetRegistersRequest
             * @instance
             */
            GetRegistersRequest.prototype.device = "";

            /**
             * GetRegistersRequest pin.
             * @member {string} pin
             * @memberof lebai.modbus.GetRegistersRequest
             * @instance
             */
            GetRegistersRequest.prototype.pin = "";

            /**
             * GetRegistersRequest count.
             * @member {number} count
             * @memberof lebai.modbus.GetRegistersRequest
             * @instance
             */
            GetRegistersRequest.prototype.count = 0;

            /**
             * Creates a new GetRegistersRequest instance using the specified properties.
             * @function create
             * @memberof lebai.modbus.GetRegistersRequest
             * @static
             * @param {lebai.modbus.IGetRegistersRequest=} [properties] Properties to set
             * @returns {lebai.modbus.GetRegistersRequest} GetRegistersRequest instance
             */
            GetRegistersRequest.create = function create(properties) {
                return new GetRegistersRequest(properties);
            };

            /**
             * Encodes the specified GetRegistersRequest message. Does not implicitly {@link lebai.modbus.GetRegistersRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.modbus.GetRegistersRequest
             * @static
             * @param {lebai.modbus.IGetRegistersRequest} message GetRegistersRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetRegistersRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.device != null && Object.hasOwnProperty.call(message, "device"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.device);
                if (message.pin != null && Object.hasOwnProperty.call(message, "pin"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.pin);
                if (message.count != null && Object.hasOwnProperty.call(message, "count"))
                    writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.count);
                return writer;
            };

            /**
             * Encodes the specified GetRegistersRequest message, length delimited. Does not implicitly {@link lebai.modbus.GetRegistersRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.modbus.GetRegistersRequest
             * @static
             * @param {lebai.modbus.IGetRegistersRequest} message GetRegistersRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetRegistersRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetRegistersRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.modbus.GetRegistersRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.modbus.GetRegistersRequest} GetRegistersRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetRegistersRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.modbus.GetRegistersRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.device = reader.string();
                            break;
                        }
                    case 2: {
                            message.pin = reader.string();
                            break;
                        }
                    case 11: {
                            message.count = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetRegistersRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.modbus.GetRegistersRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.modbus.GetRegistersRequest} GetRegistersRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetRegistersRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetRegistersRequest message.
             * @function verify
             * @memberof lebai.modbus.GetRegistersRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetRegistersRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.device != null && message.hasOwnProperty("device"))
                    if (!$util.isString(message.device))
                        return "device: string expected";
                if (message.pin != null && message.hasOwnProperty("pin"))
                    if (!$util.isString(message.pin))
                        return "pin: string expected";
                if (message.count != null && message.hasOwnProperty("count"))
                    if (!$util.isInteger(message.count))
                        return "count: integer expected";
                return null;
            };

            /**
             * Creates a GetRegistersRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.modbus.GetRegistersRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.modbus.GetRegistersRequest} GetRegistersRequest
             */
            GetRegistersRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.modbus.GetRegistersRequest)
                    return object;
                var message = new $root.lebai.modbus.GetRegistersRequest();
                if (object.device != null)
                    message.device = String(object.device);
                if (object.pin != null)
                    message.pin = String(object.pin);
                if (object.count != null)
                    message.count = object.count >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a GetRegistersRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.modbus.GetRegistersRequest
             * @static
             * @param {lebai.modbus.GetRegistersRequest} message GetRegistersRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetRegistersRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.device = "";
                    object.pin = "";
                    object.count = 0;
                }
                if (message.device != null && message.hasOwnProperty("device"))
                    object.device = message.device;
                if (message.pin != null && message.hasOwnProperty("pin"))
                    object.pin = message.pin;
                if (message.count != null && message.hasOwnProperty("count"))
                    object.count = message.count;
                return object;
            };

            /**
             * Converts this GetRegistersRequest to JSON.
             * @function toJSON
             * @memberof lebai.modbus.GetRegistersRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetRegistersRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetRegistersRequest
             * @function getTypeUrl
             * @memberof lebai.modbus.GetRegistersRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetRegistersRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.modbus.GetRegistersRequest";
            };

            return GetRegistersRequest;
        })();

        modbus.GetRegistersResponse = (function() {

            /**
             * Properties of a GetRegistersResponse.
             * @memberof lebai.modbus
             * @interface IGetRegistersResponse
             * @property {Array.<number>|null} [values] GetRegistersResponse values
             */

            /**
             * Constructs a new GetRegistersResponse.
             * @memberof lebai.modbus
             * @classdesc Represents a GetRegistersResponse.
             * @implements IGetRegistersResponse
             * @constructor
             * @param {lebai.modbus.IGetRegistersResponse=} [properties] Properties to set
             */
            function GetRegistersResponse(properties) {
                this.values = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetRegistersResponse values.
             * @member {Array.<number>} values
             * @memberof lebai.modbus.GetRegistersResponse
             * @instance
             */
            GetRegistersResponse.prototype.values = $util.emptyArray;

            /**
             * Creates a new GetRegistersResponse instance using the specified properties.
             * @function create
             * @memberof lebai.modbus.GetRegistersResponse
             * @static
             * @param {lebai.modbus.IGetRegistersResponse=} [properties] Properties to set
             * @returns {lebai.modbus.GetRegistersResponse} GetRegistersResponse instance
             */
            GetRegistersResponse.create = function create(properties) {
                return new GetRegistersResponse(properties);
            };

            /**
             * Encodes the specified GetRegistersResponse message. Does not implicitly {@link lebai.modbus.GetRegistersResponse.verify|verify} messages.
             * @function encode
             * @memberof lebai.modbus.GetRegistersResponse
             * @static
             * @param {lebai.modbus.IGetRegistersResponse} message GetRegistersResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetRegistersResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.values != null && message.values.length) {
                    writer.uint32(/* id 11, wireType 2 =*/90).fork();
                    for (var i = 0; i < message.values.length; ++i)
                        writer.uint32(message.values[i]);
                    writer.ldelim();
                }
                return writer;
            };

            /**
             * Encodes the specified GetRegistersResponse message, length delimited. Does not implicitly {@link lebai.modbus.GetRegistersResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.modbus.GetRegistersResponse
             * @static
             * @param {lebai.modbus.IGetRegistersResponse} message GetRegistersResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetRegistersResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetRegistersResponse message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.modbus.GetRegistersResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.modbus.GetRegistersResponse} GetRegistersResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetRegistersResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.modbus.GetRegistersResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 11: {
                            if (!(message.values && message.values.length))
                                message.values = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.values.push(reader.uint32());
                            } else
                                message.values.push(reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetRegistersResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.modbus.GetRegistersResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.modbus.GetRegistersResponse} GetRegistersResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetRegistersResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetRegistersResponse message.
             * @function verify
             * @memberof lebai.modbus.GetRegistersResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetRegistersResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.values != null && message.hasOwnProperty("values")) {
                    if (!Array.isArray(message.values))
                        return "values: array expected";
                    for (var i = 0; i < message.values.length; ++i)
                        if (!$util.isInteger(message.values[i]))
                            return "values: integer[] expected";
                }
                return null;
            };

            /**
             * Creates a GetRegistersResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.modbus.GetRegistersResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.modbus.GetRegistersResponse} GetRegistersResponse
             */
            GetRegistersResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.modbus.GetRegistersResponse)
                    return object;
                var message = new $root.lebai.modbus.GetRegistersResponse();
                if (object.values) {
                    if (!Array.isArray(object.values))
                        throw TypeError(".lebai.modbus.GetRegistersResponse.values: array expected");
                    message.values = [];
                    for (var i = 0; i < object.values.length; ++i)
                        message.values[i] = object.values[i] >>> 0;
                }
                return message;
            };

            /**
             * Creates a plain object from a GetRegistersResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.modbus.GetRegistersResponse
             * @static
             * @param {lebai.modbus.GetRegistersResponse} message GetRegistersResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetRegistersResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.values = [];
                if (message.values && message.values.length) {
                    object.values = [];
                    for (var j = 0; j < message.values.length; ++j)
                        object.values[j] = message.values[j];
                }
                return object;
            };

            /**
             * Converts this GetRegistersResponse to JSON.
             * @function toJSON
             * @memberof lebai.modbus.GetRegistersResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetRegistersResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetRegistersResponse
             * @function getTypeUrl
             * @memberof lebai.modbus.GetRegistersResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetRegistersResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.modbus.GetRegistersResponse";
            };

            return GetRegistersResponse;
        })();

        modbus.ModbusService = (function() {

            /**
             * Constructs a new ModbusService service.
             * @memberof lebai.modbus
             * @classdesc Represents a ModbusService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function ModbusService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (ModbusService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = ModbusService;

            /**
             * Creates new ModbusService service using the specified rpc implementation.
             * @function create
             * @memberof lebai.modbus.ModbusService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {ModbusService} RPC service. Useful where requests and/or responses are streamed.
             */
            ModbusService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link lebai.modbus.ModbusService#saveModbus}.
             * @memberof lebai.modbus.ModbusService
             * @typedef SaveModbusCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls SaveModbus.
             * @function saveModbus
             * @memberof lebai.modbus.ModbusService
             * @instance
             * @param {lebai.modbus.ISaveModbusRequest} request SaveModbusRequest message or plain object
             * @param {lebai.modbus.ModbusService.SaveModbusCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ModbusService.prototype.saveModbus = function saveModbus(request, callback) {
                return this.rpcCall(saveModbus, $root.lebai.modbus.SaveModbusRequest, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "SaveModbus" });

            /**
             * Calls SaveModbus.
             * @function saveModbus
             * @memberof lebai.modbus.ModbusService
             * @instance
             * @param {lebai.modbus.ISaveModbusRequest} request SaveModbusRequest message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.modbus.ModbusService#loadModbus}.
             * @memberof lebai.modbus.ModbusService
             * @typedef LoadModbusCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.modbus.Modbus} [response] Modbus
             */

            /**
             * Calls LoadModbus.
             * @function loadModbus
             * @memberof lebai.modbus.ModbusService
             * @instance
             * @param {lebai.db.ILoadRequest} request LoadRequest message or plain object
             * @param {lebai.modbus.ModbusService.LoadModbusCallback} callback Node-style callback called with the error, if any, and Modbus
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ModbusService.prototype.loadModbus = function loadModbus(request, callback) {
                return this.rpcCall(loadModbus, $root.lebai.db.LoadRequest, $root.lebai.modbus.Modbus, request, callback);
            }, "name", { value: "LoadModbus" });

            /**
             * Calls LoadModbus.
             * @function loadModbus
             * @memberof lebai.modbus.ModbusService
             * @instance
             * @param {lebai.db.ILoadRequest} request LoadRequest message or plain object
             * @returns {Promise<lebai.modbus.Modbus>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.modbus.ModbusService#loadModbusList}.
             * @memberof lebai.modbus.ModbusService
             * @typedef LoadModbusListCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.db.LoadListResponse} [response] LoadListResponse
             */

            /**
             * Calls LoadModbusList.
             * @function loadModbusList
             * @memberof lebai.modbus.ModbusService
             * @instance
             * @param {lebai.db.ILoadListRequest} request LoadListRequest message or plain object
             * @param {lebai.modbus.ModbusService.LoadModbusListCallback} callback Node-style callback called with the error, if any, and LoadListResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ModbusService.prototype.loadModbusList = function loadModbusList(request, callback) {
                return this.rpcCall(loadModbusList, $root.lebai.db.LoadListRequest, $root.lebai.db.LoadListResponse, request, callback);
            }, "name", { value: "LoadModbusList" });

            /**
             * Calls LoadModbusList.
             * @function loadModbusList
             * @memberof lebai.modbus.ModbusService
             * @instance
             * @param {lebai.db.ILoadListRequest} request LoadListRequest message or plain object
             * @returns {Promise<lebai.db.LoadListResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.modbus.ModbusService#saveModbusRegister}.
             * @memberof lebai.modbus.ModbusService
             * @typedef SaveModbusRegisterCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls SaveModbusRegister.
             * @function saveModbusRegister
             * @memberof lebai.modbus.ModbusService
             * @instance
             * @param {lebai.modbus.ISaveModbusRegisterRequest} request SaveModbusRegisterRequest message or plain object
             * @param {lebai.modbus.ModbusService.SaveModbusRegisterCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ModbusService.prototype.saveModbusRegister = function saveModbusRegister(request, callback) {
                return this.rpcCall(saveModbusRegister, $root.lebai.modbus.SaveModbusRegisterRequest, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "SaveModbusRegister" });

            /**
             * Calls SaveModbusRegister.
             * @function saveModbusRegister
             * @memberof lebai.modbus.ModbusService
             * @instance
             * @param {lebai.modbus.ISaveModbusRegisterRequest} request SaveModbusRegisterRequest message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.modbus.ModbusService#loadModbusRegister}.
             * @memberof lebai.modbus.ModbusService
             * @typedef LoadModbusRegisterCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.modbus.ModbusRegister} [response] ModbusRegister
             */

            /**
             * Calls LoadModbusRegister.
             * @function loadModbusRegister
             * @memberof lebai.modbus.ModbusService
             * @instance
             * @param {lebai.modbus.ILoadModbusRegisterRequest} request LoadModbusRegisterRequest message or plain object
             * @param {lebai.modbus.ModbusService.LoadModbusRegisterCallback} callback Node-style callback called with the error, if any, and ModbusRegister
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ModbusService.prototype.loadModbusRegister = function loadModbusRegister(request, callback) {
                return this.rpcCall(loadModbusRegister, $root.lebai.modbus.LoadModbusRegisterRequest, $root.lebai.modbus.ModbusRegister, request, callback);
            }, "name", { value: "LoadModbusRegister" });

            /**
             * Calls LoadModbusRegister.
             * @function loadModbusRegister
             * @memberof lebai.modbus.ModbusService
             * @instance
             * @param {lebai.modbus.ILoadModbusRegisterRequest} request LoadModbusRegisterRequest message or plain object
             * @returns {Promise<lebai.modbus.ModbusRegister>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.modbus.ModbusService#loadModbusRegisterList}.
             * @memberof lebai.modbus.ModbusService
             * @typedef LoadModbusRegisterListCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.db.LoadListResponse} [response] LoadListResponse
             */

            /**
             * Calls LoadModbusRegisterList.
             * @function loadModbusRegisterList
             * @memberof lebai.modbus.ModbusService
             * @instance
             * @param {lebai.modbus.ILoadModbusRegisterListRequest} request LoadModbusRegisterListRequest message or plain object
             * @param {lebai.modbus.ModbusService.LoadModbusRegisterListCallback} callback Node-style callback called with the error, if any, and LoadListResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ModbusService.prototype.loadModbusRegisterList = function loadModbusRegisterList(request, callback) {
                return this.rpcCall(loadModbusRegisterList, $root.lebai.modbus.LoadModbusRegisterListRequest, $root.lebai.db.LoadListResponse, request, callback);
            }, "name", { value: "LoadModbusRegisterList" });

            /**
             * Calls LoadModbusRegisterList.
             * @function loadModbusRegisterList
             * @memberof lebai.modbus.ModbusService
             * @instance
             * @param {lebai.modbus.ILoadModbusRegisterListRequest} request LoadModbusRegisterListRequest message or plain object
             * @returns {Promise<lebai.db.LoadListResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.modbus.ModbusService#setModbusTimeout}.
             * @memberof lebai.modbus.ModbusService
             * @typedef SetModbusTimeoutCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls SetModbusTimeout.
             * @function setModbusTimeout
             * @memberof lebai.modbus.ModbusService
             * @instance
             * @param {lebai.modbus.ISetModbusTimeoutRequest} request SetModbusTimeoutRequest message or plain object
             * @param {lebai.modbus.ModbusService.SetModbusTimeoutCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ModbusService.prototype.setModbusTimeout = function setModbusTimeout(request, callback) {
                return this.rpcCall(setModbusTimeout, $root.lebai.modbus.SetModbusTimeoutRequest, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "SetModbusTimeout" });

            /**
             * Calls SetModbusTimeout.
             * @function setModbusTimeout
             * @memberof lebai.modbus.ModbusService
             * @instance
             * @param {lebai.modbus.ISetModbusTimeoutRequest} request SetModbusTimeoutRequest message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.modbus.ModbusService#readDiscreteInputs}.
             * @memberof lebai.modbus.ModbusService
             * @typedef ReadDiscreteInputsCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.modbus.GetCoilsResponse} [response] GetCoilsResponse
             */

            /**
             * Calls ReadDiscreteInputs.
             * @function readDiscreteInputs
             * @memberof lebai.modbus.ModbusService
             * @instance
             * @param {lebai.modbus.IGetCoilsRequest} request GetCoilsRequest message or plain object
             * @param {lebai.modbus.ModbusService.ReadDiscreteInputsCallback} callback Node-style callback called with the error, if any, and GetCoilsResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ModbusService.prototype.readDiscreteInputs = function readDiscreteInputs(request, callback) {
                return this.rpcCall(readDiscreteInputs, $root.lebai.modbus.GetCoilsRequest, $root.lebai.modbus.GetCoilsResponse, request, callback);
            }, "name", { value: "ReadDiscreteInputs" });

            /**
             * Calls ReadDiscreteInputs.
             * @function readDiscreteInputs
             * @memberof lebai.modbus.ModbusService
             * @instance
             * @param {lebai.modbus.IGetCoilsRequest} request GetCoilsRequest message or plain object
             * @returns {Promise<lebai.modbus.GetCoilsResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.modbus.ModbusService#readCoils}.
             * @memberof lebai.modbus.ModbusService
             * @typedef ReadCoilsCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.modbus.GetCoilsResponse} [response] GetCoilsResponse
             */

            /**
             * Calls ReadCoils.
             * @function readCoils
             * @memberof lebai.modbus.ModbusService
             * @instance
             * @param {lebai.modbus.IGetCoilsRequest} request GetCoilsRequest message or plain object
             * @param {lebai.modbus.ModbusService.ReadCoilsCallback} callback Node-style callback called with the error, if any, and GetCoilsResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ModbusService.prototype.readCoils = function readCoils(request, callback) {
                return this.rpcCall(readCoils, $root.lebai.modbus.GetCoilsRequest, $root.lebai.modbus.GetCoilsResponse, request, callback);
            }, "name", { value: "ReadCoils" });

            /**
             * Calls ReadCoils.
             * @function readCoils
             * @memberof lebai.modbus.ModbusService
             * @instance
             * @param {lebai.modbus.IGetCoilsRequest} request GetCoilsRequest message or plain object
             * @returns {Promise<lebai.modbus.GetCoilsResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.modbus.ModbusService#writeSingleCoil}.
             * @memberof lebai.modbus.ModbusService
             * @typedef WriteSingleCoilCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls WriteSingleCoil.
             * @function writeSingleCoil
             * @memberof lebai.modbus.ModbusService
             * @instance
             * @param {lebai.modbus.ISetCoilRequest} request SetCoilRequest message or plain object
             * @param {lebai.modbus.ModbusService.WriteSingleCoilCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ModbusService.prototype.writeSingleCoil = function writeSingleCoil(request, callback) {
                return this.rpcCall(writeSingleCoil, $root.lebai.modbus.SetCoilRequest, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "WriteSingleCoil" });

            /**
             * Calls WriteSingleCoil.
             * @function writeSingleCoil
             * @memberof lebai.modbus.ModbusService
             * @instance
             * @param {lebai.modbus.ISetCoilRequest} request SetCoilRequest message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.modbus.ModbusService#writeMultipleCoils}.
             * @memberof lebai.modbus.ModbusService
             * @typedef WriteMultipleCoilsCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls WriteMultipleCoils.
             * @function writeMultipleCoils
             * @memberof lebai.modbus.ModbusService
             * @instance
             * @param {lebai.modbus.ISetCoilsRequest} request SetCoilsRequest message or plain object
             * @param {lebai.modbus.ModbusService.WriteMultipleCoilsCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ModbusService.prototype.writeMultipleCoils = function writeMultipleCoils(request, callback) {
                return this.rpcCall(writeMultipleCoils, $root.lebai.modbus.SetCoilsRequest, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "WriteMultipleCoils" });

            /**
             * Calls WriteMultipleCoils.
             * @function writeMultipleCoils
             * @memberof lebai.modbus.ModbusService
             * @instance
             * @param {lebai.modbus.ISetCoilsRequest} request SetCoilsRequest message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.modbus.ModbusService#readInputRegisters}.
             * @memberof lebai.modbus.ModbusService
             * @typedef ReadInputRegistersCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.modbus.GetRegistersResponse} [response] GetRegistersResponse
             */

            /**
             * Calls ReadInputRegisters.
             * @function readInputRegisters
             * @memberof lebai.modbus.ModbusService
             * @instance
             * @param {lebai.modbus.IGetRegistersRequest} request GetRegistersRequest message or plain object
             * @param {lebai.modbus.ModbusService.ReadInputRegistersCallback} callback Node-style callback called with the error, if any, and GetRegistersResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ModbusService.prototype.readInputRegisters = function readInputRegisters(request, callback) {
                return this.rpcCall(readInputRegisters, $root.lebai.modbus.GetRegistersRequest, $root.lebai.modbus.GetRegistersResponse, request, callback);
            }, "name", { value: "ReadInputRegisters" });

            /**
             * Calls ReadInputRegisters.
             * @function readInputRegisters
             * @memberof lebai.modbus.ModbusService
             * @instance
             * @param {lebai.modbus.IGetRegistersRequest} request GetRegistersRequest message or plain object
             * @returns {Promise<lebai.modbus.GetRegistersResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.modbus.ModbusService#readHoldingRegisters}.
             * @memberof lebai.modbus.ModbusService
             * @typedef ReadHoldingRegistersCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.modbus.GetRegistersResponse} [response] GetRegistersResponse
             */

            /**
             * Calls ReadHoldingRegisters.
             * @function readHoldingRegisters
             * @memberof lebai.modbus.ModbusService
             * @instance
             * @param {lebai.modbus.IGetRegistersRequest} request GetRegistersRequest message or plain object
             * @param {lebai.modbus.ModbusService.ReadHoldingRegistersCallback} callback Node-style callback called with the error, if any, and GetRegistersResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ModbusService.prototype.readHoldingRegisters = function readHoldingRegisters(request, callback) {
                return this.rpcCall(readHoldingRegisters, $root.lebai.modbus.GetRegistersRequest, $root.lebai.modbus.GetRegistersResponse, request, callback);
            }, "name", { value: "ReadHoldingRegisters" });

            /**
             * Calls ReadHoldingRegisters.
             * @function readHoldingRegisters
             * @memberof lebai.modbus.ModbusService
             * @instance
             * @param {lebai.modbus.IGetRegistersRequest} request GetRegistersRequest message or plain object
             * @returns {Promise<lebai.modbus.GetRegistersResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.modbus.ModbusService#writeSingleRegister}.
             * @memberof lebai.modbus.ModbusService
             * @typedef WriteSingleRegisterCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls WriteSingleRegister.
             * @function writeSingleRegister
             * @memberof lebai.modbus.ModbusService
             * @instance
             * @param {lebai.modbus.ISetRegisterRequest} request SetRegisterRequest message or plain object
             * @param {lebai.modbus.ModbusService.WriteSingleRegisterCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ModbusService.prototype.writeSingleRegister = function writeSingleRegister(request, callback) {
                return this.rpcCall(writeSingleRegister, $root.lebai.modbus.SetRegisterRequest, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "WriteSingleRegister" });

            /**
             * Calls WriteSingleRegister.
             * @function writeSingleRegister
             * @memberof lebai.modbus.ModbusService
             * @instance
             * @param {lebai.modbus.ISetRegisterRequest} request SetRegisterRequest message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.modbus.ModbusService#writeMultipleRegisters}.
             * @memberof lebai.modbus.ModbusService
             * @typedef WriteMultipleRegistersCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls WriteMultipleRegisters.
             * @function writeMultipleRegisters
             * @memberof lebai.modbus.ModbusService
             * @instance
             * @param {lebai.modbus.ISetRegistersRequest} request SetRegistersRequest message or plain object
             * @param {lebai.modbus.ModbusService.WriteMultipleRegistersCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ModbusService.prototype.writeMultipleRegisters = function writeMultipleRegisters(request, callback) {
                return this.rpcCall(writeMultipleRegisters, $root.lebai.modbus.SetRegistersRequest, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "WriteMultipleRegisters" });

            /**
             * Calls WriteMultipleRegisters.
             * @function writeMultipleRegisters
             * @memberof lebai.modbus.ModbusService
             * @instance
             * @param {lebai.modbus.ISetRegistersRequest} request SetRegistersRequest message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            return ModbusService;
        })();

        return modbus;
    })();

    lebai.motion = (function() {

        /**
         * Namespace motion.
         * @memberof lebai
         * @namespace
         */
        var motion = {};

        motion.MotionIndex = (function() {

            /**
             * Properties of a MotionIndex.
             * @memberof lebai.motion
             * @interface IMotionIndex
             * @property {number|null} [id] MotionIndex id
             */

            /**
             * Constructs a new MotionIndex.
             * @memberof lebai.motion
             * @classdesc Represents a MotionIndex.
             * @implements IMotionIndex
             * @constructor
             * @param {lebai.motion.IMotionIndex=} [properties] Properties to set
             */
            function MotionIndex(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MotionIndex id.
             * @member {number} id
             * @memberof lebai.motion.MotionIndex
             * @instance
             */
            MotionIndex.prototype.id = 0;

            /**
             * Creates a new MotionIndex instance using the specified properties.
             * @function create
             * @memberof lebai.motion.MotionIndex
             * @static
             * @param {lebai.motion.IMotionIndex=} [properties] Properties to set
             * @returns {lebai.motion.MotionIndex} MotionIndex instance
             */
            MotionIndex.create = function create(properties) {
                return new MotionIndex(properties);
            };

            /**
             * Encodes the specified MotionIndex message. Does not implicitly {@link lebai.motion.MotionIndex.verify|verify} messages.
             * @function encode
             * @memberof lebai.motion.MotionIndex
             * @static
             * @param {lebai.motion.IMotionIndex} message MotionIndex message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MotionIndex.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
                return writer;
            };

            /**
             * Encodes the specified MotionIndex message, length delimited. Does not implicitly {@link lebai.motion.MotionIndex.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.motion.MotionIndex
             * @static
             * @param {lebai.motion.IMotionIndex} message MotionIndex message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MotionIndex.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MotionIndex message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.motion.MotionIndex
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.motion.MotionIndex} MotionIndex
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MotionIndex.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.motion.MotionIndex();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.id = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MotionIndex message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.motion.MotionIndex
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.motion.MotionIndex} MotionIndex
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MotionIndex.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MotionIndex message.
             * @function verify
             * @memberof lebai.motion.MotionIndex
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MotionIndex.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id))
                        return "id: integer expected";
                return null;
            };

            /**
             * Creates a MotionIndex message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.motion.MotionIndex
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.motion.MotionIndex} MotionIndex
             */
            MotionIndex.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.motion.MotionIndex)
                    return object;
                var message = new $root.lebai.motion.MotionIndex();
                if (object.id != null)
                    message.id = object.id >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a MotionIndex message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.motion.MotionIndex
             * @static
             * @param {lebai.motion.MotionIndex} message MotionIndex
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MotionIndex.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.id = 0;
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                return object;
            };

            /**
             * Converts this MotionIndex to JSON.
             * @function toJSON
             * @memberof lebai.motion.MotionIndex
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MotionIndex.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MotionIndex
             * @function getTypeUrl
             * @memberof lebai.motion.MotionIndex
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MotionIndex.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.motion.MotionIndex";
            };

            return MotionIndex;
        })();

        /**
         * MotionState enum.
         * @name lebai.motion.MotionState
         * @enum {number}
         * @property {number} WAIT=0 WAIT value
         * @property {number} RUNNING=1 RUNNING value
         * @property {number} FINISHED=2 FINISHED value
         */
        motion.MotionState = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "WAIT"] = 0;
            values[valuesById[1] = "RUNNING"] = 1;
            values[valuesById[2] = "FINISHED"] = 2;
            return values;
        })();

        motion.GetMotionStateResponse = (function() {

            /**
             * Properties of a GetMotionStateResponse.
             * @memberof lebai.motion
             * @interface IGetMotionStateResponse
             * @property {lebai.motion.MotionState|null} [state] GetMotionStateResponse state
             */

            /**
             * Constructs a new GetMotionStateResponse.
             * @memberof lebai.motion
             * @classdesc Represents a GetMotionStateResponse.
             * @implements IGetMotionStateResponse
             * @constructor
             * @param {lebai.motion.IGetMotionStateResponse=} [properties] Properties to set
             */
            function GetMotionStateResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetMotionStateResponse state.
             * @member {lebai.motion.MotionState} state
             * @memberof lebai.motion.GetMotionStateResponse
             * @instance
             */
            GetMotionStateResponse.prototype.state = 0;

            /**
             * Creates a new GetMotionStateResponse instance using the specified properties.
             * @function create
             * @memberof lebai.motion.GetMotionStateResponse
             * @static
             * @param {lebai.motion.IGetMotionStateResponse=} [properties] Properties to set
             * @returns {lebai.motion.GetMotionStateResponse} GetMotionStateResponse instance
             */
            GetMotionStateResponse.create = function create(properties) {
                return new GetMotionStateResponse(properties);
            };

            /**
             * Encodes the specified GetMotionStateResponse message. Does not implicitly {@link lebai.motion.GetMotionStateResponse.verify|verify} messages.
             * @function encode
             * @memberof lebai.motion.GetMotionStateResponse
             * @static
             * @param {lebai.motion.IGetMotionStateResponse} message GetMotionStateResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetMotionStateResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.state != null && Object.hasOwnProperty.call(message, "state"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.state);
                return writer;
            };

            /**
             * Encodes the specified GetMotionStateResponse message, length delimited. Does not implicitly {@link lebai.motion.GetMotionStateResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.motion.GetMotionStateResponse
             * @static
             * @param {lebai.motion.IGetMotionStateResponse} message GetMotionStateResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetMotionStateResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetMotionStateResponse message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.motion.GetMotionStateResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.motion.GetMotionStateResponse} GetMotionStateResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetMotionStateResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.motion.GetMotionStateResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.state = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetMotionStateResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.motion.GetMotionStateResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.motion.GetMotionStateResponse} GetMotionStateResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetMotionStateResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetMotionStateResponse message.
             * @function verify
             * @memberof lebai.motion.GetMotionStateResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetMotionStateResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.state != null && message.hasOwnProperty("state"))
                    switch (message.state) {
                    default:
                        return "state: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                return null;
            };

            /**
             * Creates a GetMotionStateResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.motion.GetMotionStateResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.motion.GetMotionStateResponse} GetMotionStateResponse
             */
            GetMotionStateResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.motion.GetMotionStateResponse)
                    return object;
                var message = new $root.lebai.motion.GetMotionStateResponse();
                switch (object.state) {
                default:
                    if (typeof object.state === "number") {
                        message.state = object.state;
                        break;
                    }
                    break;
                case "WAIT":
                case 0:
                    message.state = 0;
                    break;
                case "RUNNING":
                case 1:
                    message.state = 1;
                    break;
                case "FINISHED":
                case 2:
                    message.state = 2;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a GetMotionStateResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.motion.GetMotionStateResponse
             * @static
             * @param {lebai.motion.GetMotionStateResponse} message GetMotionStateResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetMotionStateResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.state = options.enums === String ? "WAIT" : 0;
                if (message.state != null && message.hasOwnProperty("state"))
                    object.state = options.enums === String ? $root.lebai.motion.MotionState[message.state] === undefined ? message.state : $root.lebai.motion.MotionState[message.state] : message.state;
                return object;
            };

            /**
             * Converts this GetMotionStateResponse to JSON.
             * @function toJSON
             * @memberof lebai.motion.GetMotionStateResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetMotionStateResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetMotionStateResponse
             * @function getTypeUrl
             * @memberof lebai.motion.GetMotionStateResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetMotionStateResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.motion.GetMotionStateResponse";
            };

            return GetMotionStateResponse;
        })();

        motion.MoveParam = (function() {

            /**
             * Properties of a MoveParam.
             * @memberof lebai.motion
             * @interface IMoveParam
             * @property {number|null} [velocity] MoveParam velocity
             * @property {number|null} [acc] MoveParam acc
             * @property {number|null} [time] MoveParam time
             * @property {number|null} [radius] MoveParam radius
             */

            /**
             * Constructs a new MoveParam.
             * @memberof lebai.motion
             * @classdesc Represents a MoveParam.
             * @implements IMoveParam
             * @constructor
             * @param {lebai.motion.IMoveParam=} [properties] Properties to set
             */
            function MoveParam(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MoveParam velocity.
             * @member {number} velocity
             * @memberof lebai.motion.MoveParam
             * @instance
             */
            MoveParam.prototype.velocity = 0;

            /**
             * MoveParam acc.
             * @member {number} acc
             * @memberof lebai.motion.MoveParam
             * @instance
             */
            MoveParam.prototype.acc = 0;

            /**
             * MoveParam time.
             * @member {number} time
             * @memberof lebai.motion.MoveParam
             * @instance
             */
            MoveParam.prototype.time = 0;

            /**
             * MoveParam radius.
             * @member {number} radius
             * @memberof lebai.motion.MoveParam
             * @instance
             */
            MoveParam.prototype.radius = 0;

            /**
             * Creates a new MoveParam instance using the specified properties.
             * @function create
             * @memberof lebai.motion.MoveParam
             * @static
             * @param {lebai.motion.IMoveParam=} [properties] Properties to set
             * @returns {lebai.motion.MoveParam} MoveParam instance
             */
            MoveParam.create = function create(properties) {
                return new MoveParam(properties);
            };

            /**
             * Encodes the specified MoveParam message. Does not implicitly {@link lebai.motion.MoveParam.verify|verify} messages.
             * @function encode
             * @memberof lebai.motion.MoveParam
             * @static
             * @param {lebai.motion.IMoveParam} message MoveParam message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MoveParam.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.velocity != null && Object.hasOwnProperty.call(message, "velocity"))
                    writer.uint32(/* id 2, wireType 1 =*/17).double(message.velocity);
                if (message.acc != null && Object.hasOwnProperty.call(message, "acc"))
                    writer.uint32(/* id 3, wireType 1 =*/25).double(message.acc);
                if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                    writer.uint32(/* id 4, wireType 1 =*/33).double(message.time);
                if (message.radius != null && Object.hasOwnProperty.call(message, "radius"))
                    writer.uint32(/* id 5, wireType 1 =*/41).double(message.radius);
                return writer;
            };

            /**
             * Encodes the specified MoveParam message, length delimited. Does not implicitly {@link lebai.motion.MoveParam.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.motion.MoveParam
             * @static
             * @param {lebai.motion.IMoveParam} message MoveParam message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MoveParam.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MoveParam message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.motion.MoveParam
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.motion.MoveParam} MoveParam
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MoveParam.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.motion.MoveParam();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2: {
                            message.velocity = reader.double();
                            break;
                        }
                    case 3: {
                            message.acc = reader.double();
                            break;
                        }
                    case 4: {
                            message.time = reader.double();
                            break;
                        }
                    case 5: {
                            message.radius = reader.double();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MoveParam message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.motion.MoveParam
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.motion.MoveParam} MoveParam
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MoveParam.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MoveParam message.
             * @function verify
             * @memberof lebai.motion.MoveParam
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MoveParam.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.velocity != null && message.hasOwnProperty("velocity"))
                    if (typeof message.velocity !== "number")
                        return "velocity: number expected";
                if (message.acc != null && message.hasOwnProperty("acc"))
                    if (typeof message.acc !== "number")
                        return "acc: number expected";
                if (message.time != null && message.hasOwnProperty("time"))
                    if (typeof message.time !== "number")
                        return "time: number expected";
                if (message.radius != null && message.hasOwnProperty("radius"))
                    if (typeof message.radius !== "number")
                        return "radius: number expected";
                return null;
            };

            /**
             * Creates a MoveParam message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.motion.MoveParam
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.motion.MoveParam} MoveParam
             */
            MoveParam.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.motion.MoveParam)
                    return object;
                var message = new $root.lebai.motion.MoveParam();
                if (object.velocity != null)
                    message.velocity = Number(object.velocity);
                if (object.acc != null)
                    message.acc = Number(object.acc);
                if (object.time != null)
                    message.time = Number(object.time);
                if (object.radius != null)
                    message.radius = Number(object.radius);
                return message;
            };

            /**
             * Creates a plain object from a MoveParam message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.motion.MoveParam
             * @static
             * @param {lebai.motion.MoveParam} message MoveParam
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MoveParam.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.velocity = 0;
                    object.acc = 0;
                    object.time = 0;
                    object.radius = 0;
                }
                if (message.velocity != null && message.hasOwnProperty("velocity"))
                    object.velocity = options.json && !isFinite(message.velocity) ? String(message.velocity) : message.velocity;
                if (message.acc != null && message.hasOwnProperty("acc"))
                    object.acc = options.json && !isFinite(message.acc) ? String(message.acc) : message.acc;
                if (message.time != null && message.hasOwnProperty("time"))
                    object.time = options.json && !isFinite(message.time) ? String(message.time) : message.time;
                if (message.radius != null && message.hasOwnProperty("radius"))
                    object.radius = options.json && !isFinite(message.radius) ? String(message.radius) : message.radius;
                return object;
            };

            /**
             * Converts this MoveParam to JSON.
             * @function toJSON
             * @memberof lebai.motion.MoveParam
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MoveParam.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MoveParam
             * @function getTypeUrl
             * @memberof lebai.motion.MoveParam
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MoveParam.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.motion.MoveParam";
            };

            return MoveParam;
        })();

        motion.MoveRequest = (function() {

            /**
             * Properties of a MoveRequest.
             * @memberof lebai.motion
             * @interface IMoveRequest
             * @property {lebai.posture.IPose|null} [pose] MoveRequest pose
             * @property {lebai.motion.IMoveParam|null} [param] MoveRequest param
             */

            /**
             * Constructs a new MoveRequest.
             * @memberof lebai.motion
             * @classdesc Represents a MoveRequest.
             * @implements IMoveRequest
             * @constructor
             * @param {lebai.motion.IMoveRequest=} [properties] Properties to set
             */
            function MoveRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MoveRequest pose.
             * @member {lebai.posture.IPose|null|undefined} pose
             * @memberof lebai.motion.MoveRequest
             * @instance
             */
            MoveRequest.prototype.pose = null;

            /**
             * MoveRequest param.
             * @member {lebai.motion.IMoveParam|null|undefined} param
             * @memberof lebai.motion.MoveRequest
             * @instance
             */
            MoveRequest.prototype.param = null;

            /**
             * Creates a new MoveRequest instance using the specified properties.
             * @function create
             * @memberof lebai.motion.MoveRequest
             * @static
             * @param {lebai.motion.IMoveRequest=} [properties] Properties to set
             * @returns {lebai.motion.MoveRequest} MoveRequest instance
             */
            MoveRequest.create = function create(properties) {
                return new MoveRequest(properties);
            };

            /**
             * Encodes the specified MoveRequest message. Does not implicitly {@link lebai.motion.MoveRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.motion.MoveRequest
             * @static
             * @param {lebai.motion.IMoveRequest} message MoveRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MoveRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.pose != null && Object.hasOwnProperty.call(message, "pose"))
                    $root.lebai.posture.Pose.encode(message.pose, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.param != null && Object.hasOwnProperty.call(message, "param"))
                    $root.lebai.motion.MoveParam.encode(message.param, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified MoveRequest message, length delimited. Does not implicitly {@link lebai.motion.MoveRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.motion.MoveRequest
             * @static
             * @param {lebai.motion.IMoveRequest} message MoveRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MoveRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MoveRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.motion.MoveRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.motion.MoveRequest} MoveRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MoveRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.motion.MoveRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.pose = $root.lebai.posture.Pose.decode(reader, reader.uint32());
                            break;
                        }
                    case 11: {
                            message.param = $root.lebai.motion.MoveParam.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MoveRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.motion.MoveRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.motion.MoveRequest} MoveRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MoveRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MoveRequest message.
             * @function verify
             * @memberof lebai.motion.MoveRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MoveRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.pose != null && message.hasOwnProperty("pose")) {
                    var error = $root.lebai.posture.Pose.verify(message.pose);
                    if (error)
                        return "pose." + error;
                }
                if (message.param != null && message.hasOwnProperty("param")) {
                    var error = $root.lebai.motion.MoveParam.verify(message.param);
                    if (error)
                        return "param." + error;
                }
                return null;
            };

            /**
             * Creates a MoveRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.motion.MoveRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.motion.MoveRequest} MoveRequest
             */
            MoveRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.motion.MoveRequest)
                    return object;
                var message = new $root.lebai.motion.MoveRequest();
                if (object.pose != null) {
                    if (typeof object.pose !== "object")
                        throw TypeError(".lebai.motion.MoveRequest.pose: object expected");
                    message.pose = $root.lebai.posture.Pose.fromObject(object.pose);
                }
                if (object.param != null) {
                    if (typeof object.param !== "object")
                        throw TypeError(".lebai.motion.MoveRequest.param: object expected");
                    message.param = $root.lebai.motion.MoveParam.fromObject(object.param);
                }
                return message;
            };

            /**
             * Creates a plain object from a MoveRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.motion.MoveRequest
             * @static
             * @param {lebai.motion.MoveRequest} message MoveRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MoveRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.pose = null;
                    object.param = null;
                }
                if (message.pose != null && message.hasOwnProperty("pose"))
                    object.pose = $root.lebai.posture.Pose.toObject(message.pose, options);
                if (message.param != null && message.hasOwnProperty("param"))
                    object.param = $root.lebai.motion.MoveParam.toObject(message.param, options);
                return object;
            };

            /**
             * Converts this MoveRequest to JSON.
             * @function toJSON
             * @memberof lebai.motion.MoveRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MoveRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MoveRequest
             * @function getTypeUrl
             * @memberof lebai.motion.MoveRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MoveRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.motion.MoveRequest";
            };

            return MoveRequest;
        })();

        motion.MovecRequest = (function() {

            /**
             * Properties of a MovecRequest.
             * @memberof lebai.motion
             * @interface IMovecRequest
             * @property {lebai.posture.IPose|null} [poseVia] MovecRequest poseVia
             * @property {lebai.posture.IPose|null} [pose] MovecRequest pose
             * @property {number|null} [rad] MovecRequest rad
             * @property {lebai.motion.IMoveParam|null} [param] MovecRequest param
             */

            /**
             * Constructs a new MovecRequest.
             * @memberof lebai.motion
             * @classdesc Represents a MovecRequest.
             * @implements IMovecRequest
             * @constructor
             * @param {lebai.motion.IMovecRequest=} [properties] Properties to set
             */
            function MovecRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MovecRequest poseVia.
             * @member {lebai.posture.IPose|null|undefined} poseVia
             * @memberof lebai.motion.MovecRequest
             * @instance
             */
            MovecRequest.prototype.poseVia = null;

            /**
             * MovecRequest pose.
             * @member {lebai.posture.IPose|null|undefined} pose
             * @memberof lebai.motion.MovecRequest
             * @instance
             */
            MovecRequest.prototype.pose = null;

            /**
             * MovecRequest rad.
             * @member {number} rad
             * @memberof lebai.motion.MovecRequest
             * @instance
             */
            MovecRequest.prototype.rad = 0;

            /**
             * MovecRequest param.
             * @member {lebai.motion.IMoveParam|null|undefined} param
             * @memberof lebai.motion.MovecRequest
             * @instance
             */
            MovecRequest.prototype.param = null;

            /**
             * Creates a new MovecRequest instance using the specified properties.
             * @function create
             * @memberof lebai.motion.MovecRequest
             * @static
             * @param {lebai.motion.IMovecRequest=} [properties] Properties to set
             * @returns {lebai.motion.MovecRequest} MovecRequest instance
             */
            MovecRequest.create = function create(properties) {
                return new MovecRequest(properties);
            };

            /**
             * Encodes the specified MovecRequest message. Does not implicitly {@link lebai.motion.MovecRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.motion.MovecRequest
             * @static
             * @param {lebai.motion.IMovecRequest} message MovecRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MovecRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.poseVia != null && Object.hasOwnProperty.call(message, "poseVia"))
                    $root.lebai.posture.Pose.encode(message.poseVia, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.pose != null && Object.hasOwnProperty.call(message, "pose"))
                    $root.lebai.posture.Pose.encode(message.pose, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.rad != null && Object.hasOwnProperty.call(message, "rad"))
                    writer.uint32(/* id 3, wireType 1 =*/25).double(message.rad);
                if (message.param != null && Object.hasOwnProperty.call(message, "param"))
                    $root.lebai.motion.MoveParam.encode(message.param, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified MovecRequest message, length delimited. Does not implicitly {@link lebai.motion.MovecRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.motion.MovecRequest
             * @static
             * @param {lebai.motion.IMovecRequest} message MovecRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MovecRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MovecRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.motion.MovecRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.motion.MovecRequest} MovecRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MovecRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.motion.MovecRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.poseVia = $root.lebai.posture.Pose.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.pose = $root.lebai.posture.Pose.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            message.rad = reader.double();
                            break;
                        }
                    case 11: {
                            message.param = $root.lebai.motion.MoveParam.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MovecRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.motion.MovecRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.motion.MovecRequest} MovecRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MovecRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MovecRequest message.
             * @function verify
             * @memberof lebai.motion.MovecRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MovecRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.poseVia != null && message.hasOwnProperty("poseVia")) {
                    var error = $root.lebai.posture.Pose.verify(message.poseVia);
                    if (error)
                        return "poseVia." + error;
                }
                if (message.pose != null && message.hasOwnProperty("pose")) {
                    var error = $root.lebai.posture.Pose.verify(message.pose);
                    if (error)
                        return "pose." + error;
                }
                if (message.rad != null && message.hasOwnProperty("rad"))
                    if (typeof message.rad !== "number")
                        return "rad: number expected";
                if (message.param != null && message.hasOwnProperty("param")) {
                    var error = $root.lebai.motion.MoveParam.verify(message.param);
                    if (error)
                        return "param." + error;
                }
                return null;
            };

            /**
             * Creates a MovecRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.motion.MovecRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.motion.MovecRequest} MovecRequest
             */
            MovecRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.motion.MovecRequest)
                    return object;
                var message = new $root.lebai.motion.MovecRequest();
                if (object.poseVia != null) {
                    if (typeof object.poseVia !== "object")
                        throw TypeError(".lebai.motion.MovecRequest.poseVia: object expected");
                    message.poseVia = $root.lebai.posture.Pose.fromObject(object.poseVia);
                }
                if (object.pose != null) {
                    if (typeof object.pose !== "object")
                        throw TypeError(".lebai.motion.MovecRequest.pose: object expected");
                    message.pose = $root.lebai.posture.Pose.fromObject(object.pose);
                }
                if (object.rad != null)
                    message.rad = Number(object.rad);
                if (object.param != null) {
                    if (typeof object.param !== "object")
                        throw TypeError(".lebai.motion.MovecRequest.param: object expected");
                    message.param = $root.lebai.motion.MoveParam.fromObject(object.param);
                }
                return message;
            };

            /**
             * Creates a plain object from a MovecRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.motion.MovecRequest
             * @static
             * @param {lebai.motion.MovecRequest} message MovecRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MovecRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.poseVia = null;
                    object.pose = null;
                    object.rad = 0;
                    object.param = null;
                }
                if (message.poseVia != null && message.hasOwnProperty("poseVia"))
                    object.poseVia = $root.lebai.posture.Pose.toObject(message.poseVia, options);
                if (message.pose != null && message.hasOwnProperty("pose"))
                    object.pose = $root.lebai.posture.Pose.toObject(message.pose, options);
                if (message.rad != null && message.hasOwnProperty("rad"))
                    object.rad = options.json && !isFinite(message.rad) ? String(message.rad) : message.rad;
                if (message.param != null && message.hasOwnProperty("param"))
                    object.param = $root.lebai.motion.MoveParam.toObject(message.param, options);
                return object;
            };

            /**
             * Converts this MovecRequest to JSON.
             * @function toJSON
             * @memberof lebai.motion.MovecRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MovecRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MovecRequest
             * @function getTypeUrl
             * @memberof lebai.motion.MovecRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MovecRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.motion.MovecRequest";
            };

            return MovecRequest;
        })();

        motion.SpeedParam = (function() {

            /**
             * Properties of a SpeedParam.
             * @memberof lebai.motion
             * @interface ISpeedParam
             * @property {number|null} [acc] SpeedParam acc
             * @property {number|null} [time] SpeedParam time
             * @property {boolean|null} [constrained] SpeedParam constrained
             */

            /**
             * Constructs a new SpeedParam.
             * @memberof lebai.motion
             * @classdesc Represents a SpeedParam.
             * @implements ISpeedParam
             * @constructor
             * @param {lebai.motion.ISpeedParam=} [properties] Properties to set
             */
            function SpeedParam(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SpeedParam acc.
             * @member {number} acc
             * @memberof lebai.motion.SpeedParam
             * @instance
             */
            SpeedParam.prototype.acc = 0;

            /**
             * SpeedParam time.
             * @member {number} time
             * @memberof lebai.motion.SpeedParam
             * @instance
             */
            SpeedParam.prototype.time = 0;

            /**
             * SpeedParam constrained.
             * @member {boolean} constrained
             * @memberof lebai.motion.SpeedParam
             * @instance
             */
            SpeedParam.prototype.constrained = false;

            /**
             * Creates a new SpeedParam instance using the specified properties.
             * @function create
             * @memberof lebai.motion.SpeedParam
             * @static
             * @param {lebai.motion.ISpeedParam=} [properties] Properties to set
             * @returns {lebai.motion.SpeedParam} SpeedParam instance
             */
            SpeedParam.create = function create(properties) {
                return new SpeedParam(properties);
            };

            /**
             * Encodes the specified SpeedParam message. Does not implicitly {@link lebai.motion.SpeedParam.verify|verify} messages.
             * @function encode
             * @memberof lebai.motion.SpeedParam
             * @static
             * @param {lebai.motion.ISpeedParam} message SpeedParam message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SpeedParam.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.acc != null && Object.hasOwnProperty.call(message, "acc"))
                    writer.uint32(/* id 3, wireType 1 =*/25).double(message.acc);
                if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                    writer.uint32(/* id 4, wireType 1 =*/33).double(message.time);
                if (message.constrained != null && Object.hasOwnProperty.call(message, "constrained"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.constrained);
                return writer;
            };

            /**
             * Encodes the specified SpeedParam message, length delimited. Does not implicitly {@link lebai.motion.SpeedParam.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.motion.SpeedParam
             * @static
             * @param {lebai.motion.ISpeedParam} message SpeedParam message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SpeedParam.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SpeedParam message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.motion.SpeedParam
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.motion.SpeedParam} SpeedParam
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SpeedParam.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.motion.SpeedParam();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 3: {
                            message.acc = reader.double();
                            break;
                        }
                    case 4: {
                            message.time = reader.double();
                            break;
                        }
                    case 6: {
                            message.constrained = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SpeedParam message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.motion.SpeedParam
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.motion.SpeedParam} SpeedParam
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SpeedParam.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SpeedParam message.
             * @function verify
             * @memberof lebai.motion.SpeedParam
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SpeedParam.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.acc != null && message.hasOwnProperty("acc"))
                    if (typeof message.acc !== "number")
                        return "acc: number expected";
                if (message.time != null && message.hasOwnProperty("time"))
                    if (typeof message.time !== "number")
                        return "time: number expected";
                if (message.constrained != null && message.hasOwnProperty("constrained"))
                    if (typeof message.constrained !== "boolean")
                        return "constrained: boolean expected";
                return null;
            };

            /**
             * Creates a SpeedParam message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.motion.SpeedParam
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.motion.SpeedParam} SpeedParam
             */
            SpeedParam.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.motion.SpeedParam)
                    return object;
                var message = new $root.lebai.motion.SpeedParam();
                if (object.acc != null)
                    message.acc = Number(object.acc);
                if (object.time != null)
                    message.time = Number(object.time);
                if (object.constrained != null)
                    message.constrained = Boolean(object.constrained);
                return message;
            };

            /**
             * Creates a plain object from a SpeedParam message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.motion.SpeedParam
             * @static
             * @param {lebai.motion.SpeedParam} message SpeedParam
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SpeedParam.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.acc = 0;
                    object.time = 0;
                    object.constrained = false;
                }
                if (message.acc != null && message.hasOwnProperty("acc"))
                    object.acc = options.json && !isFinite(message.acc) ? String(message.acc) : message.acc;
                if (message.time != null && message.hasOwnProperty("time"))
                    object.time = options.json && !isFinite(message.time) ? String(message.time) : message.time;
                if (message.constrained != null && message.hasOwnProperty("constrained"))
                    object.constrained = message.constrained;
                return object;
            };

            /**
             * Converts this SpeedParam to JSON.
             * @function toJSON
             * @memberof lebai.motion.SpeedParam
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SpeedParam.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SpeedParam
             * @function getTypeUrl
             * @memberof lebai.motion.SpeedParam
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SpeedParam.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.motion.SpeedParam";
            };

            return SpeedParam;
        })();

        motion.SpeedJRequest = (function() {

            /**
             * Properties of a SpeedJRequest.
             * @memberof lebai.motion
             * @interface ISpeedJRequest
             * @property {lebai.posture.IJointPose|null} [speed] SpeedJRequest speed
             * @property {lebai.motion.ISpeedParam|null} [param] SpeedJRequest param
             */

            /**
             * Constructs a new SpeedJRequest.
             * @memberof lebai.motion
             * @classdesc Represents a SpeedJRequest.
             * @implements ISpeedJRequest
             * @constructor
             * @param {lebai.motion.ISpeedJRequest=} [properties] Properties to set
             */
            function SpeedJRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SpeedJRequest speed.
             * @member {lebai.posture.IJointPose|null|undefined} speed
             * @memberof lebai.motion.SpeedJRequest
             * @instance
             */
            SpeedJRequest.prototype.speed = null;

            /**
             * SpeedJRequest param.
             * @member {lebai.motion.ISpeedParam|null|undefined} param
             * @memberof lebai.motion.SpeedJRequest
             * @instance
             */
            SpeedJRequest.prototype.param = null;

            /**
             * Creates a new SpeedJRequest instance using the specified properties.
             * @function create
             * @memberof lebai.motion.SpeedJRequest
             * @static
             * @param {lebai.motion.ISpeedJRequest=} [properties] Properties to set
             * @returns {lebai.motion.SpeedJRequest} SpeedJRequest instance
             */
            SpeedJRequest.create = function create(properties) {
                return new SpeedJRequest(properties);
            };

            /**
             * Encodes the specified SpeedJRequest message. Does not implicitly {@link lebai.motion.SpeedJRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.motion.SpeedJRequest
             * @static
             * @param {lebai.motion.ISpeedJRequest} message SpeedJRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SpeedJRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.speed != null && Object.hasOwnProperty.call(message, "speed"))
                    $root.lebai.posture.JointPose.encode(message.speed, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.param != null && Object.hasOwnProperty.call(message, "param"))
                    $root.lebai.motion.SpeedParam.encode(message.param, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified SpeedJRequest message, length delimited. Does not implicitly {@link lebai.motion.SpeedJRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.motion.SpeedJRequest
             * @static
             * @param {lebai.motion.ISpeedJRequest} message SpeedJRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SpeedJRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SpeedJRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.motion.SpeedJRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.motion.SpeedJRequest} SpeedJRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SpeedJRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.motion.SpeedJRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.speed = $root.lebai.posture.JointPose.decode(reader, reader.uint32());
                            break;
                        }
                    case 11: {
                            message.param = $root.lebai.motion.SpeedParam.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SpeedJRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.motion.SpeedJRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.motion.SpeedJRequest} SpeedJRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SpeedJRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SpeedJRequest message.
             * @function verify
             * @memberof lebai.motion.SpeedJRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SpeedJRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.speed != null && message.hasOwnProperty("speed")) {
                    var error = $root.lebai.posture.JointPose.verify(message.speed);
                    if (error)
                        return "speed." + error;
                }
                if (message.param != null && message.hasOwnProperty("param")) {
                    var error = $root.lebai.motion.SpeedParam.verify(message.param);
                    if (error)
                        return "param." + error;
                }
                return null;
            };

            /**
             * Creates a SpeedJRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.motion.SpeedJRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.motion.SpeedJRequest} SpeedJRequest
             */
            SpeedJRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.motion.SpeedJRequest)
                    return object;
                var message = new $root.lebai.motion.SpeedJRequest();
                if (object.speed != null) {
                    if (typeof object.speed !== "object")
                        throw TypeError(".lebai.motion.SpeedJRequest.speed: object expected");
                    message.speed = $root.lebai.posture.JointPose.fromObject(object.speed);
                }
                if (object.param != null) {
                    if (typeof object.param !== "object")
                        throw TypeError(".lebai.motion.SpeedJRequest.param: object expected");
                    message.param = $root.lebai.motion.SpeedParam.fromObject(object.param);
                }
                return message;
            };

            /**
             * Creates a plain object from a SpeedJRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.motion.SpeedJRequest
             * @static
             * @param {lebai.motion.SpeedJRequest} message SpeedJRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SpeedJRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.speed = null;
                    object.param = null;
                }
                if (message.speed != null && message.hasOwnProperty("speed"))
                    object.speed = $root.lebai.posture.JointPose.toObject(message.speed, options);
                if (message.param != null && message.hasOwnProperty("param"))
                    object.param = $root.lebai.motion.SpeedParam.toObject(message.param, options);
                return object;
            };

            /**
             * Converts this SpeedJRequest to JSON.
             * @function toJSON
             * @memberof lebai.motion.SpeedJRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SpeedJRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SpeedJRequest
             * @function getTypeUrl
             * @memberof lebai.motion.SpeedJRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SpeedJRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.motion.SpeedJRequest";
            };

            return SpeedJRequest;
        })();

        motion.SpeedLRequest = (function() {

            /**
             * Properties of a SpeedLRequest.
             * @memberof lebai.motion
             * @interface ISpeedLRequest
             * @property {lebai.posture.ICartesianPose|null} [speed] SpeedLRequest speed
             * @property {lebai.motion.ISpeedParam|null} [param] SpeedLRequest param
             * @property {lebai.posture.ICartesianFrame|null} [frame] SpeedLRequest frame
             */

            /**
             * Constructs a new SpeedLRequest.
             * @memberof lebai.motion
             * @classdesc Represents a SpeedLRequest.
             * @implements ISpeedLRequest
             * @constructor
             * @param {lebai.motion.ISpeedLRequest=} [properties] Properties to set
             */
            function SpeedLRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SpeedLRequest speed.
             * @member {lebai.posture.ICartesianPose|null|undefined} speed
             * @memberof lebai.motion.SpeedLRequest
             * @instance
             */
            SpeedLRequest.prototype.speed = null;

            /**
             * SpeedLRequest param.
             * @member {lebai.motion.ISpeedParam|null|undefined} param
             * @memberof lebai.motion.SpeedLRequest
             * @instance
             */
            SpeedLRequest.prototype.param = null;

            /**
             * SpeedLRequest frame.
             * @member {lebai.posture.ICartesianFrame|null|undefined} frame
             * @memberof lebai.motion.SpeedLRequest
             * @instance
             */
            SpeedLRequest.prototype.frame = null;

            /**
             * Creates a new SpeedLRequest instance using the specified properties.
             * @function create
             * @memberof lebai.motion.SpeedLRequest
             * @static
             * @param {lebai.motion.ISpeedLRequest=} [properties] Properties to set
             * @returns {lebai.motion.SpeedLRequest} SpeedLRequest instance
             */
            SpeedLRequest.create = function create(properties) {
                return new SpeedLRequest(properties);
            };

            /**
             * Encodes the specified SpeedLRequest message. Does not implicitly {@link lebai.motion.SpeedLRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.motion.SpeedLRequest
             * @static
             * @param {lebai.motion.ISpeedLRequest} message SpeedLRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SpeedLRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.speed != null && Object.hasOwnProperty.call(message, "speed"))
                    $root.lebai.posture.CartesianPose.encode(message.speed, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.param != null && Object.hasOwnProperty.call(message, "param"))
                    $root.lebai.motion.SpeedParam.encode(message.param, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                if (message.frame != null && Object.hasOwnProperty.call(message, "frame"))
                    $root.lebai.posture.CartesianFrame.encode(message.frame, writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified SpeedLRequest message, length delimited. Does not implicitly {@link lebai.motion.SpeedLRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.motion.SpeedLRequest
             * @static
             * @param {lebai.motion.ISpeedLRequest} message SpeedLRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SpeedLRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SpeedLRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.motion.SpeedLRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.motion.SpeedLRequest} SpeedLRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SpeedLRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.motion.SpeedLRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.speed = $root.lebai.posture.CartesianPose.decode(reader, reader.uint32());
                            break;
                        }
                    case 11: {
                            message.param = $root.lebai.motion.SpeedParam.decode(reader, reader.uint32());
                            break;
                        }
                    case 21: {
                            message.frame = $root.lebai.posture.CartesianFrame.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SpeedLRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.motion.SpeedLRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.motion.SpeedLRequest} SpeedLRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SpeedLRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SpeedLRequest message.
             * @function verify
             * @memberof lebai.motion.SpeedLRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SpeedLRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.speed != null && message.hasOwnProperty("speed")) {
                    var error = $root.lebai.posture.CartesianPose.verify(message.speed);
                    if (error)
                        return "speed." + error;
                }
                if (message.param != null && message.hasOwnProperty("param")) {
                    var error = $root.lebai.motion.SpeedParam.verify(message.param);
                    if (error)
                        return "param." + error;
                }
                if (message.frame != null && message.hasOwnProperty("frame")) {
                    var error = $root.lebai.posture.CartesianFrame.verify(message.frame);
                    if (error)
                        return "frame." + error;
                }
                return null;
            };

            /**
             * Creates a SpeedLRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.motion.SpeedLRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.motion.SpeedLRequest} SpeedLRequest
             */
            SpeedLRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.motion.SpeedLRequest)
                    return object;
                var message = new $root.lebai.motion.SpeedLRequest();
                if (object.speed != null) {
                    if (typeof object.speed !== "object")
                        throw TypeError(".lebai.motion.SpeedLRequest.speed: object expected");
                    message.speed = $root.lebai.posture.CartesianPose.fromObject(object.speed);
                }
                if (object.param != null) {
                    if (typeof object.param !== "object")
                        throw TypeError(".lebai.motion.SpeedLRequest.param: object expected");
                    message.param = $root.lebai.motion.SpeedParam.fromObject(object.param);
                }
                if (object.frame != null) {
                    if (typeof object.frame !== "object")
                        throw TypeError(".lebai.motion.SpeedLRequest.frame: object expected");
                    message.frame = $root.lebai.posture.CartesianFrame.fromObject(object.frame);
                }
                return message;
            };

            /**
             * Creates a plain object from a SpeedLRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.motion.SpeedLRequest
             * @static
             * @param {lebai.motion.SpeedLRequest} message SpeedLRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SpeedLRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.speed = null;
                    object.param = null;
                    object.frame = null;
                }
                if (message.speed != null && message.hasOwnProperty("speed"))
                    object.speed = $root.lebai.posture.CartesianPose.toObject(message.speed, options);
                if (message.param != null && message.hasOwnProperty("param"))
                    object.param = $root.lebai.motion.SpeedParam.toObject(message.param, options);
                if (message.frame != null && message.hasOwnProperty("frame"))
                    object.frame = $root.lebai.posture.CartesianFrame.toObject(message.frame, options);
                return object;
            };

            /**
             * Converts this SpeedLRequest to JSON.
             * @function toJSON
             * @memberof lebai.motion.SpeedLRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SpeedLRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SpeedLRequest
             * @function getTypeUrl
             * @memberof lebai.motion.SpeedLRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SpeedLRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.motion.SpeedLRequest";
            };

            return SpeedLRequest;
        })();

        motion.JointMove = (function() {

            /**
             * Properties of a JointMove.
             * @memberof lebai.motion
             * @interface IJointMove
             * @property {number|null} [pose] JointMove pose
             * @property {number|null} [velocity] JointMove velocity
             * @property {number|null} [acc] JointMove acc
             */

            /**
             * Constructs a new JointMove.
             * @memberof lebai.motion
             * @classdesc Represents a JointMove.
             * @implements IJointMove
             * @constructor
             * @param {lebai.motion.IJointMove=} [properties] Properties to set
             */
            function JointMove(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * JointMove pose.
             * @member {number} pose
             * @memberof lebai.motion.JointMove
             * @instance
             */
            JointMove.prototype.pose = 0;

            /**
             * JointMove velocity.
             * @member {number|null|undefined} velocity
             * @memberof lebai.motion.JointMove
             * @instance
             */
            JointMove.prototype.velocity = null;

            /**
             * JointMove acc.
             * @member {number|null|undefined} acc
             * @memberof lebai.motion.JointMove
             * @instance
             */
            JointMove.prototype.acc = null;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * JointMove _velocity.
             * @member {"velocity"|undefined} _velocity
             * @memberof lebai.motion.JointMove
             * @instance
             */
            Object.defineProperty(JointMove.prototype, "_velocity", {
                get: $util.oneOfGetter($oneOfFields = ["velocity"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * JointMove _acc.
             * @member {"acc"|undefined} _acc
             * @memberof lebai.motion.JointMove
             * @instance
             */
            Object.defineProperty(JointMove.prototype, "_acc", {
                get: $util.oneOfGetter($oneOfFields = ["acc"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new JointMove instance using the specified properties.
             * @function create
             * @memberof lebai.motion.JointMove
             * @static
             * @param {lebai.motion.IJointMove=} [properties] Properties to set
             * @returns {lebai.motion.JointMove} JointMove instance
             */
            JointMove.create = function create(properties) {
                return new JointMove(properties);
            };

            /**
             * Encodes the specified JointMove message. Does not implicitly {@link lebai.motion.JointMove.verify|verify} messages.
             * @function encode
             * @memberof lebai.motion.JointMove
             * @static
             * @param {lebai.motion.IJointMove} message JointMove message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            JointMove.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.pose != null && Object.hasOwnProperty.call(message, "pose"))
                    writer.uint32(/* id 1, wireType 1 =*/9).double(message.pose);
                if (message.velocity != null && Object.hasOwnProperty.call(message, "velocity"))
                    writer.uint32(/* id 2, wireType 1 =*/17).double(message.velocity);
                if (message.acc != null && Object.hasOwnProperty.call(message, "acc"))
                    writer.uint32(/* id 3, wireType 1 =*/25).double(message.acc);
                return writer;
            };

            /**
             * Encodes the specified JointMove message, length delimited. Does not implicitly {@link lebai.motion.JointMove.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.motion.JointMove
             * @static
             * @param {lebai.motion.IJointMove} message JointMove message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            JointMove.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a JointMove message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.motion.JointMove
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.motion.JointMove} JointMove
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            JointMove.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.motion.JointMove();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.pose = reader.double();
                            break;
                        }
                    case 2: {
                            message.velocity = reader.double();
                            break;
                        }
                    case 3: {
                            message.acc = reader.double();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a JointMove message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.motion.JointMove
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.motion.JointMove} JointMove
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            JointMove.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a JointMove message.
             * @function verify
             * @memberof lebai.motion.JointMove
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            JointMove.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.pose != null && message.hasOwnProperty("pose"))
                    if (typeof message.pose !== "number")
                        return "pose: number expected";
                if (message.velocity != null && message.hasOwnProperty("velocity")) {
                    properties._velocity = 1;
                    if (typeof message.velocity !== "number")
                        return "velocity: number expected";
                }
                if (message.acc != null && message.hasOwnProperty("acc")) {
                    properties._acc = 1;
                    if (typeof message.acc !== "number")
                        return "acc: number expected";
                }
                return null;
            };

            /**
             * Creates a JointMove message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.motion.JointMove
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.motion.JointMove} JointMove
             */
            JointMove.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.motion.JointMove)
                    return object;
                var message = new $root.lebai.motion.JointMove();
                if (object.pose != null)
                    message.pose = Number(object.pose);
                if (object.velocity != null)
                    message.velocity = Number(object.velocity);
                if (object.acc != null)
                    message.acc = Number(object.acc);
                return message;
            };

            /**
             * Creates a plain object from a JointMove message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.motion.JointMove
             * @static
             * @param {lebai.motion.JointMove} message JointMove
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            JointMove.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.pose = 0;
                if (message.pose != null && message.hasOwnProperty("pose"))
                    object.pose = options.json && !isFinite(message.pose) ? String(message.pose) : message.pose;
                if (message.velocity != null && message.hasOwnProperty("velocity")) {
                    object.velocity = options.json && !isFinite(message.velocity) ? String(message.velocity) : message.velocity;
                    if (options.oneofs)
                        object._velocity = "velocity";
                }
                if (message.acc != null && message.hasOwnProperty("acc")) {
                    object.acc = options.json && !isFinite(message.acc) ? String(message.acc) : message.acc;
                    if (options.oneofs)
                        object._acc = "acc";
                }
                return object;
            };

            /**
             * Converts this JointMove to JSON.
             * @function toJSON
             * @memberof lebai.motion.JointMove
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            JointMove.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for JointMove
             * @function getTypeUrl
             * @memberof lebai.motion.JointMove
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            JointMove.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.motion.JointMove";
            };

            return JointMove;
        })();

        /**
         * PvatKind enum.
         * @name lebai.motion.PvatKind
         * @enum {number}
         * @property {number} PT=0 PT value
         * @property {number} PVT=1 PVT value
         * @property {number} PVAT=2 PVAT value
         */
        motion.PvatKind = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "PT"] = 0;
            values[valuesById[1] = "PVT"] = 1;
            values[valuesById[2] = "PVAT"] = 2;
            return values;
        })();

        motion.MovePvatRequest = (function() {

            /**
             * Properties of a MovePvatRequest.
             * @memberof lebai.motion
             * @interface IMovePvatRequest
             * @property {Array.<lebai.motion.IJointMove>|null} [joints] MovePvatRequest joints
             * @property {number|null} [duration] MovePvatRequest duration
             */

            /**
             * Constructs a new MovePvatRequest.
             * @memberof lebai.motion
             * @classdesc Represents a MovePvatRequest.
             * @implements IMovePvatRequest
             * @constructor
             * @param {lebai.motion.IMovePvatRequest=} [properties] Properties to set
             */
            function MovePvatRequest(properties) {
                this.joints = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MovePvatRequest joints.
             * @member {Array.<lebai.motion.IJointMove>} joints
             * @memberof lebai.motion.MovePvatRequest
             * @instance
             */
            MovePvatRequest.prototype.joints = $util.emptyArray;

            /**
             * MovePvatRequest duration.
             * @member {number} duration
             * @memberof lebai.motion.MovePvatRequest
             * @instance
             */
            MovePvatRequest.prototype.duration = 0;

            /**
             * Creates a new MovePvatRequest instance using the specified properties.
             * @function create
             * @memberof lebai.motion.MovePvatRequest
             * @static
             * @param {lebai.motion.IMovePvatRequest=} [properties] Properties to set
             * @returns {lebai.motion.MovePvatRequest} MovePvatRequest instance
             */
            MovePvatRequest.create = function create(properties) {
                return new MovePvatRequest(properties);
            };

            /**
             * Encodes the specified MovePvatRequest message. Does not implicitly {@link lebai.motion.MovePvatRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.motion.MovePvatRequest
             * @static
             * @param {lebai.motion.IMovePvatRequest} message MovePvatRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MovePvatRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.joints != null && message.joints.length)
                    for (var i = 0; i < message.joints.length; ++i)
                        $root.lebai.motion.JointMove.encode(message.joints[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                if (message.duration != null && Object.hasOwnProperty.call(message, "duration"))
                    writer.uint32(/* id 11, wireType 1 =*/89).double(message.duration);
                return writer;
            };

            /**
             * Encodes the specified MovePvatRequest message, length delimited. Does not implicitly {@link lebai.motion.MovePvatRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.motion.MovePvatRequest
             * @static
             * @param {lebai.motion.IMovePvatRequest} message MovePvatRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MovePvatRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MovePvatRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.motion.MovePvatRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.motion.MovePvatRequest} MovePvatRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MovePvatRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.motion.MovePvatRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 10: {
                            if (!(message.joints && message.joints.length))
                                message.joints = [];
                            message.joints.push($root.lebai.motion.JointMove.decode(reader, reader.uint32()));
                            break;
                        }
                    case 11: {
                            message.duration = reader.double();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MovePvatRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.motion.MovePvatRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.motion.MovePvatRequest} MovePvatRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MovePvatRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MovePvatRequest message.
             * @function verify
             * @memberof lebai.motion.MovePvatRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MovePvatRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.joints != null && message.hasOwnProperty("joints")) {
                    if (!Array.isArray(message.joints))
                        return "joints: array expected";
                    for (var i = 0; i < message.joints.length; ++i) {
                        var error = $root.lebai.motion.JointMove.verify(message.joints[i]);
                        if (error)
                            return "joints." + error;
                    }
                }
                if (message.duration != null && message.hasOwnProperty("duration"))
                    if (typeof message.duration !== "number")
                        return "duration: number expected";
                return null;
            };

            /**
             * Creates a MovePvatRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.motion.MovePvatRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.motion.MovePvatRequest} MovePvatRequest
             */
            MovePvatRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.motion.MovePvatRequest)
                    return object;
                var message = new $root.lebai.motion.MovePvatRequest();
                if (object.joints) {
                    if (!Array.isArray(object.joints))
                        throw TypeError(".lebai.motion.MovePvatRequest.joints: array expected");
                    message.joints = [];
                    for (var i = 0; i < object.joints.length; ++i) {
                        if (typeof object.joints[i] !== "object")
                            throw TypeError(".lebai.motion.MovePvatRequest.joints: object expected");
                        message.joints[i] = $root.lebai.motion.JointMove.fromObject(object.joints[i]);
                    }
                }
                if (object.duration != null)
                    message.duration = Number(object.duration);
                return message;
            };

            /**
             * Creates a plain object from a MovePvatRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.motion.MovePvatRequest
             * @static
             * @param {lebai.motion.MovePvatRequest} message MovePvatRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MovePvatRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.joints = [];
                if (options.defaults)
                    object.duration = 0;
                if (message.joints && message.joints.length) {
                    object.joints = [];
                    for (var j = 0; j < message.joints.length; ++j)
                        object.joints[j] = $root.lebai.motion.JointMove.toObject(message.joints[j], options);
                }
                if (message.duration != null && message.hasOwnProperty("duration"))
                    object.duration = options.json && !isFinite(message.duration) ? String(message.duration) : message.duration;
                return object;
            };

            /**
             * Converts this MovePvatRequest to JSON.
             * @function toJSON
             * @memberof lebai.motion.MovePvatRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MovePvatRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MovePvatRequest
             * @function getTypeUrl
             * @memberof lebai.motion.MovePvatRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MovePvatRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.motion.MovePvatRequest";
            };

            return MovePvatRequest;
        })();

        motion.Trajectory = (function() {

            /**
             * Properties of a Trajectory.
             * @memberof lebai.motion
             * @interface ITrajectory
             * @property {lebai.motion.PvatKind|null} [kind] Trajectory kind
             * @property {Array.<lebai.motion.IMovePvatRequest>|null} [data] Trajectory data
             */

            /**
             * Constructs a new Trajectory.
             * @memberof lebai.motion
             * @classdesc Represents a Trajectory.
             * @implements ITrajectory
             * @constructor
             * @param {lebai.motion.ITrajectory=} [properties] Properties to set
             */
            function Trajectory(properties) {
                this.data = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Trajectory kind.
             * @member {lebai.motion.PvatKind} kind
             * @memberof lebai.motion.Trajectory
             * @instance
             */
            Trajectory.prototype.kind = 0;

            /**
             * Trajectory data.
             * @member {Array.<lebai.motion.IMovePvatRequest>} data
             * @memberof lebai.motion.Trajectory
             * @instance
             */
            Trajectory.prototype.data = $util.emptyArray;

            /**
             * Creates a new Trajectory instance using the specified properties.
             * @function create
             * @memberof lebai.motion.Trajectory
             * @static
             * @param {lebai.motion.ITrajectory=} [properties] Properties to set
             * @returns {lebai.motion.Trajectory} Trajectory instance
             */
            Trajectory.create = function create(properties) {
                return new Trajectory(properties);
            };

            /**
             * Encodes the specified Trajectory message. Does not implicitly {@link lebai.motion.Trajectory.verify|verify} messages.
             * @function encode
             * @memberof lebai.motion.Trajectory
             * @static
             * @param {lebai.motion.ITrajectory} message Trajectory message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Trajectory.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.kind != null && Object.hasOwnProperty.call(message, "kind"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.kind);
                if (message.data != null && message.data.length)
                    for (var i = 0; i < message.data.length; ++i)
                        $root.lebai.motion.MovePvatRequest.encode(message.data[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Trajectory message, length delimited. Does not implicitly {@link lebai.motion.Trajectory.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.motion.Trajectory
             * @static
             * @param {lebai.motion.ITrajectory} message Trajectory message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Trajectory.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Trajectory message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.motion.Trajectory
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.motion.Trajectory} Trajectory
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Trajectory.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.motion.Trajectory();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.kind = reader.int32();
                            break;
                        }
                    case 11: {
                            if (!(message.data && message.data.length))
                                message.data = [];
                            message.data.push($root.lebai.motion.MovePvatRequest.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Trajectory message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.motion.Trajectory
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.motion.Trajectory} Trajectory
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Trajectory.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Trajectory message.
             * @function verify
             * @memberof lebai.motion.Trajectory
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Trajectory.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.kind != null && message.hasOwnProperty("kind"))
                    switch (message.kind) {
                    default:
                        return "kind: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.data != null && message.hasOwnProperty("data")) {
                    if (!Array.isArray(message.data))
                        return "data: array expected";
                    for (var i = 0; i < message.data.length; ++i) {
                        var error = $root.lebai.motion.MovePvatRequest.verify(message.data[i]);
                        if (error)
                            return "data." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Trajectory message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.motion.Trajectory
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.motion.Trajectory} Trajectory
             */
            Trajectory.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.motion.Trajectory)
                    return object;
                var message = new $root.lebai.motion.Trajectory();
                switch (object.kind) {
                default:
                    if (typeof object.kind === "number") {
                        message.kind = object.kind;
                        break;
                    }
                    break;
                case "PT":
                case 0:
                    message.kind = 0;
                    break;
                case "PVT":
                case 1:
                    message.kind = 1;
                    break;
                case "PVAT":
                case 2:
                    message.kind = 2;
                    break;
                }
                if (object.data) {
                    if (!Array.isArray(object.data))
                        throw TypeError(".lebai.motion.Trajectory.data: array expected");
                    message.data = [];
                    for (var i = 0; i < object.data.length; ++i) {
                        if (typeof object.data[i] !== "object")
                            throw TypeError(".lebai.motion.Trajectory.data: object expected");
                        message.data[i] = $root.lebai.motion.MovePvatRequest.fromObject(object.data[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a Trajectory message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.motion.Trajectory
             * @static
             * @param {lebai.motion.Trajectory} message Trajectory
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Trajectory.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.data = [];
                if (options.defaults)
                    object.kind = options.enums === String ? "PT" : 0;
                if (message.kind != null && message.hasOwnProperty("kind"))
                    object.kind = options.enums === String ? $root.lebai.motion.PvatKind[message.kind] === undefined ? message.kind : $root.lebai.motion.PvatKind[message.kind] : message.kind;
                if (message.data && message.data.length) {
                    object.data = [];
                    for (var j = 0; j < message.data.length; ++j)
                        object.data[j] = $root.lebai.motion.MovePvatRequest.toObject(message.data[j], options);
                }
                return object;
            };

            /**
             * Converts this Trajectory to JSON.
             * @function toJSON
             * @memberof lebai.motion.Trajectory
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Trajectory.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Trajectory
             * @function getTypeUrl
             * @memberof lebai.motion.Trajectory
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Trajectory.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.motion.Trajectory";
            };

            return Trajectory;
        })();

        motion.SaveTrajectoryRequest = (function() {

            /**
             * Properties of a SaveTrajectoryRequest.
             * @memberof lebai.motion
             * @interface ISaveTrajectoryRequest
             * @property {string|null} [name] SaveTrajectoryRequest name
             * @property {lebai.motion.ITrajectory|null} [data] SaveTrajectoryRequest data
             * @property {string|null} [dir] SaveTrajectoryRequest dir
             */

            /**
             * Constructs a new SaveTrajectoryRequest.
             * @memberof lebai.motion
             * @classdesc Represents a SaveTrajectoryRequest.
             * @implements ISaveTrajectoryRequest
             * @constructor
             * @param {lebai.motion.ISaveTrajectoryRequest=} [properties] Properties to set
             */
            function SaveTrajectoryRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SaveTrajectoryRequest name.
             * @member {string} name
             * @memberof lebai.motion.SaveTrajectoryRequest
             * @instance
             */
            SaveTrajectoryRequest.prototype.name = "";

            /**
             * SaveTrajectoryRequest data.
             * @member {lebai.motion.ITrajectory|null|undefined} data
             * @memberof lebai.motion.SaveTrajectoryRequest
             * @instance
             */
            SaveTrajectoryRequest.prototype.data = null;

            /**
             * SaveTrajectoryRequest dir.
             * @member {string} dir
             * @memberof lebai.motion.SaveTrajectoryRequest
             * @instance
             */
            SaveTrajectoryRequest.prototype.dir = "";

            /**
             * Creates a new SaveTrajectoryRequest instance using the specified properties.
             * @function create
             * @memberof lebai.motion.SaveTrajectoryRequest
             * @static
             * @param {lebai.motion.ISaveTrajectoryRequest=} [properties] Properties to set
             * @returns {lebai.motion.SaveTrajectoryRequest} SaveTrajectoryRequest instance
             */
            SaveTrajectoryRequest.create = function create(properties) {
                return new SaveTrajectoryRequest(properties);
            };

            /**
             * Encodes the specified SaveTrajectoryRequest message. Does not implicitly {@link lebai.motion.SaveTrajectoryRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.motion.SaveTrajectoryRequest
             * @static
             * @param {lebai.motion.ISaveTrajectoryRequest} message SaveTrajectoryRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SaveTrajectoryRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    $root.lebai.motion.Trajectory.encode(message.data, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.dir != null && Object.hasOwnProperty.call(message, "dir"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.dir);
                return writer;
            };

            /**
             * Encodes the specified SaveTrajectoryRequest message, length delimited. Does not implicitly {@link lebai.motion.SaveTrajectoryRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.motion.SaveTrajectoryRequest
             * @static
             * @param {lebai.motion.ISaveTrajectoryRequest} message SaveTrajectoryRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SaveTrajectoryRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SaveTrajectoryRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.motion.SaveTrajectoryRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.motion.SaveTrajectoryRequest} SaveTrajectoryRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SaveTrajectoryRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.motion.SaveTrajectoryRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.name = reader.string();
                            break;
                        }
                    case 2: {
                            message.data = $root.lebai.motion.Trajectory.decode(reader, reader.uint32());
                            break;
                        }
                    case 11: {
                            message.dir = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SaveTrajectoryRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.motion.SaveTrajectoryRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.motion.SaveTrajectoryRequest} SaveTrajectoryRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SaveTrajectoryRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SaveTrajectoryRequest message.
             * @function verify
             * @memberof lebai.motion.SaveTrajectoryRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SaveTrajectoryRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.data != null && message.hasOwnProperty("data")) {
                    var error = $root.lebai.motion.Trajectory.verify(message.data);
                    if (error)
                        return "data." + error;
                }
                if (message.dir != null && message.hasOwnProperty("dir"))
                    if (!$util.isString(message.dir))
                        return "dir: string expected";
                return null;
            };

            /**
             * Creates a SaveTrajectoryRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.motion.SaveTrajectoryRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.motion.SaveTrajectoryRequest} SaveTrajectoryRequest
             */
            SaveTrajectoryRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.motion.SaveTrajectoryRequest)
                    return object;
                var message = new $root.lebai.motion.SaveTrajectoryRequest();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.data != null) {
                    if (typeof object.data !== "object")
                        throw TypeError(".lebai.motion.SaveTrajectoryRequest.data: object expected");
                    message.data = $root.lebai.motion.Trajectory.fromObject(object.data);
                }
                if (object.dir != null)
                    message.dir = String(object.dir);
                return message;
            };

            /**
             * Creates a plain object from a SaveTrajectoryRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.motion.SaveTrajectoryRequest
             * @static
             * @param {lebai.motion.SaveTrajectoryRequest} message SaveTrajectoryRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SaveTrajectoryRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.data = null;
                    object.dir = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.data != null && message.hasOwnProperty("data"))
                    object.data = $root.lebai.motion.Trajectory.toObject(message.data, options);
                if (message.dir != null && message.hasOwnProperty("dir"))
                    object.dir = message.dir;
                return object;
            };

            /**
             * Converts this SaveTrajectoryRequest to JSON.
             * @function toJSON
             * @memberof lebai.motion.SaveTrajectoryRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SaveTrajectoryRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SaveTrajectoryRequest
             * @function getTypeUrl
             * @memberof lebai.motion.SaveTrajectoryRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SaveTrajectoryRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.motion.SaveTrajectoryRequest";
            };

            return SaveTrajectoryRequest;
        })();

        motion.StartRecordTrajectoryRequest = (function() {

            /**
             * Properties of a StartRecordTrajectoryRequest.
             * @memberof lebai.motion
             * @interface IStartRecordTrajectoryRequest
             * @property {lebai.motion.PvatKind|null} [kind] StartRecordTrajectoryRequest kind
             * @property {number|null} [duration] StartRecordTrajectoryRequest duration
             */

            /**
             * Constructs a new StartRecordTrajectoryRequest.
             * @memberof lebai.motion
             * @classdesc Represents a StartRecordTrajectoryRequest.
             * @implements IStartRecordTrajectoryRequest
             * @constructor
             * @param {lebai.motion.IStartRecordTrajectoryRequest=} [properties] Properties to set
             */
            function StartRecordTrajectoryRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StartRecordTrajectoryRequest kind.
             * @member {lebai.motion.PvatKind} kind
             * @memberof lebai.motion.StartRecordTrajectoryRequest
             * @instance
             */
            StartRecordTrajectoryRequest.prototype.kind = 0;

            /**
             * StartRecordTrajectoryRequest duration.
             * @member {number} duration
             * @memberof lebai.motion.StartRecordTrajectoryRequest
             * @instance
             */
            StartRecordTrajectoryRequest.prototype.duration = 0;

            /**
             * Creates a new StartRecordTrajectoryRequest instance using the specified properties.
             * @function create
             * @memberof lebai.motion.StartRecordTrajectoryRequest
             * @static
             * @param {lebai.motion.IStartRecordTrajectoryRequest=} [properties] Properties to set
             * @returns {lebai.motion.StartRecordTrajectoryRequest} StartRecordTrajectoryRequest instance
             */
            StartRecordTrajectoryRequest.create = function create(properties) {
                return new StartRecordTrajectoryRequest(properties);
            };

            /**
             * Encodes the specified StartRecordTrajectoryRequest message. Does not implicitly {@link lebai.motion.StartRecordTrajectoryRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.motion.StartRecordTrajectoryRequest
             * @static
             * @param {lebai.motion.IStartRecordTrajectoryRequest} message StartRecordTrajectoryRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StartRecordTrajectoryRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.kind != null && Object.hasOwnProperty.call(message, "kind"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.kind);
                if (message.duration != null && Object.hasOwnProperty.call(message, "duration"))
                    writer.uint32(/* id 11, wireType 1 =*/89).double(message.duration);
                return writer;
            };

            /**
             * Encodes the specified StartRecordTrajectoryRequest message, length delimited. Does not implicitly {@link lebai.motion.StartRecordTrajectoryRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.motion.StartRecordTrajectoryRequest
             * @static
             * @param {lebai.motion.IStartRecordTrajectoryRequest} message StartRecordTrajectoryRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StartRecordTrajectoryRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StartRecordTrajectoryRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.motion.StartRecordTrajectoryRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.motion.StartRecordTrajectoryRequest} StartRecordTrajectoryRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StartRecordTrajectoryRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.motion.StartRecordTrajectoryRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.kind = reader.int32();
                            break;
                        }
                    case 11: {
                            message.duration = reader.double();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StartRecordTrajectoryRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.motion.StartRecordTrajectoryRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.motion.StartRecordTrajectoryRequest} StartRecordTrajectoryRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StartRecordTrajectoryRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StartRecordTrajectoryRequest message.
             * @function verify
             * @memberof lebai.motion.StartRecordTrajectoryRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StartRecordTrajectoryRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.kind != null && message.hasOwnProperty("kind"))
                    switch (message.kind) {
                    default:
                        return "kind: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.duration != null && message.hasOwnProperty("duration"))
                    if (typeof message.duration !== "number")
                        return "duration: number expected";
                return null;
            };

            /**
             * Creates a StartRecordTrajectoryRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.motion.StartRecordTrajectoryRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.motion.StartRecordTrajectoryRequest} StartRecordTrajectoryRequest
             */
            StartRecordTrajectoryRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.motion.StartRecordTrajectoryRequest)
                    return object;
                var message = new $root.lebai.motion.StartRecordTrajectoryRequest();
                switch (object.kind) {
                default:
                    if (typeof object.kind === "number") {
                        message.kind = object.kind;
                        break;
                    }
                    break;
                case "PT":
                case 0:
                    message.kind = 0;
                    break;
                case "PVT":
                case 1:
                    message.kind = 1;
                    break;
                case "PVAT":
                case 2:
                    message.kind = 2;
                    break;
                }
                if (object.duration != null)
                    message.duration = Number(object.duration);
                return message;
            };

            /**
             * Creates a plain object from a StartRecordTrajectoryRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.motion.StartRecordTrajectoryRequest
             * @static
             * @param {lebai.motion.StartRecordTrajectoryRequest} message StartRecordTrajectoryRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StartRecordTrajectoryRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.kind = options.enums === String ? "PT" : 0;
                    object.duration = 0;
                }
                if (message.kind != null && message.hasOwnProperty("kind"))
                    object.kind = options.enums === String ? $root.lebai.motion.PvatKind[message.kind] === undefined ? message.kind : $root.lebai.motion.PvatKind[message.kind] : message.kind;
                if (message.duration != null && message.hasOwnProperty("duration"))
                    object.duration = options.json && !isFinite(message.duration) ? String(message.duration) : message.duration;
                return object;
            };

            /**
             * Converts this StartRecordTrajectoryRequest to JSON.
             * @function toJSON
             * @memberof lebai.motion.StartRecordTrajectoryRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StartRecordTrajectoryRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for StartRecordTrajectoryRequest
             * @function getTypeUrl
             * @memberof lebai.motion.StartRecordTrajectoryRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            StartRecordTrajectoryRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.motion.StartRecordTrajectoryRequest";
            };

            return StartRecordTrajectoryRequest;
        })();

        motion.EndRecordTrajectoryRequest = (function() {

            /**
             * Properties of an EndRecordTrajectoryRequest.
             * @memberof lebai.motion
             * @interface IEndRecordTrajectoryRequest
             * @property {string|null} [name] EndRecordTrajectoryRequest name
             * @property {string|null} [dir] EndRecordTrajectoryRequest dir
             */

            /**
             * Constructs a new EndRecordTrajectoryRequest.
             * @memberof lebai.motion
             * @classdesc Represents an EndRecordTrajectoryRequest.
             * @implements IEndRecordTrajectoryRequest
             * @constructor
             * @param {lebai.motion.IEndRecordTrajectoryRequest=} [properties] Properties to set
             */
            function EndRecordTrajectoryRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EndRecordTrajectoryRequest name.
             * @member {string} name
             * @memberof lebai.motion.EndRecordTrajectoryRequest
             * @instance
             */
            EndRecordTrajectoryRequest.prototype.name = "";

            /**
             * EndRecordTrajectoryRequest dir.
             * @member {string} dir
             * @memberof lebai.motion.EndRecordTrajectoryRequest
             * @instance
             */
            EndRecordTrajectoryRequest.prototype.dir = "";

            /**
             * Creates a new EndRecordTrajectoryRequest instance using the specified properties.
             * @function create
             * @memberof lebai.motion.EndRecordTrajectoryRequest
             * @static
             * @param {lebai.motion.IEndRecordTrajectoryRequest=} [properties] Properties to set
             * @returns {lebai.motion.EndRecordTrajectoryRequest} EndRecordTrajectoryRequest instance
             */
            EndRecordTrajectoryRequest.create = function create(properties) {
                return new EndRecordTrajectoryRequest(properties);
            };

            /**
             * Encodes the specified EndRecordTrajectoryRequest message. Does not implicitly {@link lebai.motion.EndRecordTrajectoryRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.motion.EndRecordTrajectoryRequest
             * @static
             * @param {lebai.motion.IEndRecordTrajectoryRequest} message EndRecordTrajectoryRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EndRecordTrajectoryRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.dir != null && Object.hasOwnProperty.call(message, "dir"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.dir);
                return writer;
            };

            /**
             * Encodes the specified EndRecordTrajectoryRequest message, length delimited. Does not implicitly {@link lebai.motion.EndRecordTrajectoryRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.motion.EndRecordTrajectoryRequest
             * @static
             * @param {lebai.motion.IEndRecordTrajectoryRequest} message EndRecordTrajectoryRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EndRecordTrajectoryRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EndRecordTrajectoryRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.motion.EndRecordTrajectoryRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.motion.EndRecordTrajectoryRequest} EndRecordTrajectoryRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EndRecordTrajectoryRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.motion.EndRecordTrajectoryRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.name = reader.string();
                            break;
                        }
                    case 11: {
                            message.dir = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EndRecordTrajectoryRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.motion.EndRecordTrajectoryRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.motion.EndRecordTrajectoryRequest} EndRecordTrajectoryRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EndRecordTrajectoryRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EndRecordTrajectoryRequest message.
             * @function verify
             * @memberof lebai.motion.EndRecordTrajectoryRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EndRecordTrajectoryRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.dir != null && message.hasOwnProperty("dir"))
                    if (!$util.isString(message.dir))
                        return "dir: string expected";
                return null;
            };

            /**
             * Creates an EndRecordTrajectoryRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.motion.EndRecordTrajectoryRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.motion.EndRecordTrajectoryRequest} EndRecordTrajectoryRequest
             */
            EndRecordTrajectoryRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.motion.EndRecordTrajectoryRequest)
                    return object;
                var message = new $root.lebai.motion.EndRecordTrajectoryRequest();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.dir != null)
                    message.dir = String(object.dir);
                return message;
            };

            /**
             * Creates a plain object from an EndRecordTrajectoryRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.motion.EndRecordTrajectoryRequest
             * @static
             * @param {lebai.motion.EndRecordTrajectoryRequest} message EndRecordTrajectoryRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EndRecordTrajectoryRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.dir = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.dir != null && message.hasOwnProperty("dir"))
                    object.dir = message.dir;
                return object;
            };

            /**
             * Converts this EndRecordTrajectoryRequest to JSON.
             * @function toJSON
             * @memberof lebai.motion.EndRecordTrajectoryRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EndRecordTrajectoryRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for EndRecordTrajectoryRequest
             * @function getTypeUrl
             * @memberof lebai.motion.EndRecordTrajectoryRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            EndRecordTrajectoryRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.motion.EndRecordTrajectoryRequest";
            };

            return EndRecordTrajectoryRequest;
        })();

        motion.MoveTrajectoryRequest = (function() {

            /**
             * Properties of a MoveTrajectoryRequest.
             * @memberof lebai.motion
             * @interface IMoveTrajectoryRequest
             * @property {string|null} [name] MoveTrajectoryRequest name
             * @property {string|null} [dir] MoveTrajectoryRequest dir
             */

            /**
             * Constructs a new MoveTrajectoryRequest.
             * @memberof lebai.motion
             * @classdesc Represents a MoveTrajectoryRequest.
             * @implements IMoveTrajectoryRequest
             * @constructor
             * @param {lebai.motion.IMoveTrajectoryRequest=} [properties] Properties to set
             */
            function MoveTrajectoryRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MoveTrajectoryRequest name.
             * @member {string} name
             * @memberof lebai.motion.MoveTrajectoryRequest
             * @instance
             */
            MoveTrajectoryRequest.prototype.name = "";

            /**
             * MoveTrajectoryRequest dir.
             * @member {string} dir
             * @memberof lebai.motion.MoveTrajectoryRequest
             * @instance
             */
            MoveTrajectoryRequest.prototype.dir = "";

            /**
             * Creates a new MoveTrajectoryRequest instance using the specified properties.
             * @function create
             * @memberof lebai.motion.MoveTrajectoryRequest
             * @static
             * @param {lebai.motion.IMoveTrajectoryRequest=} [properties] Properties to set
             * @returns {lebai.motion.MoveTrajectoryRequest} MoveTrajectoryRequest instance
             */
            MoveTrajectoryRequest.create = function create(properties) {
                return new MoveTrajectoryRequest(properties);
            };

            /**
             * Encodes the specified MoveTrajectoryRequest message. Does not implicitly {@link lebai.motion.MoveTrajectoryRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.motion.MoveTrajectoryRequest
             * @static
             * @param {lebai.motion.IMoveTrajectoryRequest} message MoveTrajectoryRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MoveTrajectoryRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.dir != null && Object.hasOwnProperty.call(message, "dir"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.dir);
                return writer;
            };

            /**
             * Encodes the specified MoveTrajectoryRequest message, length delimited. Does not implicitly {@link lebai.motion.MoveTrajectoryRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.motion.MoveTrajectoryRequest
             * @static
             * @param {lebai.motion.IMoveTrajectoryRequest} message MoveTrajectoryRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MoveTrajectoryRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MoveTrajectoryRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.motion.MoveTrajectoryRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.motion.MoveTrajectoryRequest} MoveTrajectoryRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MoveTrajectoryRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.motion.MoveTrajectoryRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.name = reader.string();
                            break;
                        }
                    case 11: {
                            message.dir = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MoveTrajectoryRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.motion.MoveTrajectoryRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.motion.MoveTrajectoryRequest} MoveTrajectoryRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MoveTrajectoryRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MoveTrajectoryRequest message.
             * @function verify
             * @memberof lebai.motion.MoveTrajectoryRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MoveTrajectoryRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.dir != null && message.hasOwnProperty("dir"))
                    if (!$util.isString(message.dir))
                        return "dir: string expected";
                return null;
            };

            /**
             * Creates a MoveTrajectoryRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.motion.MoveTrajectoryRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.motion.MoveTrajectoryRequest} MoveTrajectoryRequest
             */
            MoveTrajectoryRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.motion.MoveTrajectoryRequest)
                    return object;
                var message = new $root.lebai.motion.MoveTrajectoryRequest();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.dir != null)
                    message.dir = String(object.dir);
                return message;
            };

            /**
             * Creates a plain object from a MoveTrajectoryRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.motion.MoveTrajectoryRequest
             * @static
             * @param {lebai.motion.MoveTrajectoryRequest} message MoveTrajectoryRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MoveTrajectoryRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.dir = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.dir != null && message.hasOwnProperty("dir"))
                    object.dir = message.dir;
                return object;
            };

            /**
             * Converts this MoveTrajectoryRequest to JSON.
             * @function toJSON
             * @memberof lebai.motion.MoveTrajectoryRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MoveTrajectoryRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MoveTrajectoryRequest
             * @function getTypeUrl
             * @memberof lebai.motion.MoveTrajectoryRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MoveTrajectoryRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.motion.MoveTrajectoryRequest";
            };

            return MoveTrajectoryRequest;
        })();

        motion.Wrench = (function() {

            /**
             * Properties of a Wrench.
             * @memberof lebai.motion
             * @interface IWrench
             * @property {lebai.posture.IPosition|null} [force] Wrench force
             * @property {lebai.posture.IPosition|null} [torque] Wrench torque
             */

            /**
             * Constructs a new Wrench.
             * @memberof lebai.motion
             * @classdesc Represents a Wrench.
             * @implements IWrench
             * @constructor
             * @param {lebai.motion.IWrench=} [properties] Properties to set
             */
            function Wrench(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Wrench force.
             * @member {lebai.posture.IPosition|null|undefined} force
             * @memberof lebai.motion.Wrench
             * @instance
             */
            Wrench.prototype.force = null;

            /**
             * Wrench torque.
             * @member {lebai.posture.IPosition|null|undefined} torque
             * @memberof lebai.motion.Wrench
             * @instance
             */
            Wrench.prototype.torque = null;

            /**
             * Creates a new Wrench instance using the specified properties.
             * @function create
             * @memberof lebai.motion.Wrench
             * @static
             * @param {lebai.motion.IWrench=} [properties] Properties to set
             * @returns {lebai.motion.Wrench} Wrench instance
             */
            Wrench.create = function create(properties) {
                return new Wrench(properties);
            };

            /**
             * Encodes the specified Wrench message. Does not implicitly {@link lebai.motion.Wrench.verify|verify} messages.
             * @function encode
             * @memberof lebai.motion.Wrench
             * @static
             * @param {lebai.motion.IWrench} message Wrench message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Wrench.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.force != null && Object.hasOwnProperty.call(message, "force"))
                    $root.lebai.posture.Position.encode(message.force, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.torque != null && Object.hasOwnProperty.call(message, "torque"))
                    $root.lebai.posture.Position.encode(message.torque, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Wrench message, length delimited. Does not implicitly {@link lebai.motion.Wrench.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.motion.Wrench
             * @static
             * @param {lebai.motion.IWrench} message Wrench message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Wrench.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Wrench message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.motion.Wrench
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.motion.Wrench} Wrench
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Wrench.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.motion.Wrench();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.force = $root.lebai.posture.Position.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.torque = $root.lebai.posture.Position.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Wrench message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.motion.Wrench
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.motion.Wrench} Wrench
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Wrench.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Wrench message.
             * @function verify
             * @memberof lebai.motion.Wrench
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Wrench.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.force != null && message.hasOwnProperty("force")) {
                    var error = $root.lebai.posture.Position.verify(message.force);
                    if (error)
                        return "force." + error;
                }
                if (message.torque != null && message.hasOwnProperty("torque")) {
                    var error = $root.lebai.posture.Position.verify(message.torque);
                    if (error)
                        return "torque." + error;
                }
                return null;
            };

            /**
             * Creates a Wrench message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.motion.Wrench
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.motion.Wrench} Wrench
             */
            Wrench.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.motion.Wrench)
                    return object;
                var message = new $root.lebai.motion.Wrench();
                if (object.force != null) {
                    if (typeof object.force !== "object")
                        throw TypeError(".lebai.motion.Wrench.force: object expected");
                    message.force = $root.lebai.posture.Position.fromObject(object.force);
                }
                if (object.torque != null) {
                    if (typeof object.torque !== "object")
                        throw TypeError(".lebai.motion.Wrench.torque: object expected");
                    message.torque = $root.lebai.posture.Position.fromObject(object.torque);
                }
                return message;
            };

            /**
             * Creates a plain object from a Wrench message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.motion.Wrench
             * @static
             * @param {lebai.motion.Wrench} message Wrench
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Wrench.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.force = null;
                    object.torque = null;
                }
                if (message.force != null && message.hasOwnProperty("force"))
                    object.force = $root.lebai.posture.Position.toObject(message.force, options);
                if (message.torque != null && message.hasOwnProperty("torque"))
                    object.torque = $root.lebai.posture.Position.toObject(message.torque, options);
                return object;
            };

            /**
             * Converts this Wrench to JSON.
             * @function toJSON
             * @memberof lebai.motion.Wrench
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Wrench.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Wrench
             * @function getTypeUrl
             * @memberof lebai.motion.Wrench
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Wrench.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.motion.Wrench";
            };

            return Wrench;
        })();

        /**
         * ForceSensor enum.
         * @name lebai.motion.ForceSensor
         * @enum {number}
         * @property {number} DISABLE=0 DISABLE value
         * @property {number} INSTANTANEOUS=1 INSTANTANEOUS value
         * @property {number} CONTINUOUS=2 CONTINUOUS value
         * @property {number} WEIGHT1=11 WEIGHT1 value
         */
        motion.ForceSensor = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "DISABLE"] = 0;
            values[valuesById[1] = "INSTANTANEOUS"] = 1;
            values[valuesById[2] = "CONTINUOUS"] = 2;
            values[valuesById[11] = "WEIGHT1"] = 11;
            return values;
        })();

        motion.SetForceSensorRequest = (function() {

            /**
             * Properties of a SetForceSensorRequest.
             * @memberof lebai.motion
             * @interface ISetForceSensorRequest
             * @property {lebai.motion.ForceSensor|null} [sensor] SetForceSensorRequest sensor
             */

            /**
             * Constructs a new SetForceSensorRequest.
             * @memberof lebai.motion
             * @classdesc Represents a SetForceSensorRequest.
             * @implements ISetForceSensorRequest
             * @constructor
             * @param {lebai.motion.ISetForceSensorRequest=} [properties] Properties to set
             */
            function SetForceSensorRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SetForceSensorRequest sensor.
             * @member {lebai.motion.ForceSensor} sensor
             * @memberof lebai.motion.SetForceSensorRequest
             * @instance
             */
            SetForceSensorRequest.prototype.sensor = 0;

            /**
             * Creates a new SetForceSensorRequest instance using the specified properties.
             * @function create
             * @memberof lebai.motion.SetForceSensorRequest
             * @static
             * @param {lebai.motion.ISetForceSensorRequest=} [properties] Properties to set
             * @returns {lebai.motion.SetForceSensorRequest} SetForceSensorRequest instance
             */
            SetForceSensorRequest.create = function create(properties) {
                return new SetForceSensorRequest(properties);
            };

            /**
             * Encodes the specified SetForceSensorRequest message. Does not implicitly {@link lebai.motion.SetForceSensorRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.motion.SetForceSensorRequest
             * @static
             * @param {lebai.motion.ISetForceSensorRequest} message SetForceSensorRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetForceSensorRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sensor != null && Object.hasOwnProperty.call(message, "sensor"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.sensor);
                return writer;
            };

            /**
             * Encodes the specified SetForceSensorRequest message, length delimited. Does not implicitly {@link lebai.motion.SetForceSensorRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.motion.SetForceSensorRequest
             * @static
             * @param {lebai.motion.ISetForceSensorRequest} message SetForceSensorRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetForceSensorRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetForceSensorRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.motion.SetForceSensorRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.motion.SetForceSensorRequest} SetForceSensorRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetForceSensorRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.motion.SetForceSensorRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.sensor = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetForceSensorRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.motion.SetForceSensorRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.motion.SetForceSensorRequest} SetForceSensorRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetForceSensorRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetForceSensorRequest message.
             * @function verify
             * @memberof lebai.motion.SetForceSensorRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetForceSensorRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sensor != null && message.hasOwnProperty("sensor"))
                    switch (message.sensor) {
                    default:
                        return "sensor: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 11:
                        break;
                    }
                return null;
            };

            /**
             * Creates a SetForceSensorRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.motion.SetForceSensorRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.motion.SetForceSensorRequest} SetForceSensorRequest
             */
            SetForceSensorRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.motion.SetForceSensorRequest)
                    return object;
                var message = new $root.lebai.motion.SetForceSensorRequest();
                switch (object.sensor) {
                default:
                    if (typeof object.sensor === "number") {
                        message.sensor = object.sensor;
                        break;
                    }
                    break;
                case "DISABLE":
                case 0:
                    message.sensor = 0;
                    break;
                case "INSTANTANEOUS":
                case 1:
                    message.sensor = 1;
                    break;
                case "CONTINUOUS":
                case 2:
                    message.sensor = 2;
                    break;
                case "WEIGHT1":
                case 11:
                    message.sensor = 11;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a SetForceSensorRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.motion.SetForceSensorRequest
             * @static
             * @param {lebai.motion.SetForceSensorRequest} message SetForceSensorRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetForceSensorRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.sensor = options.enums === String ? "DISABLE" : 0;
                if (message.sensor != null && message.hasOwnProperty("sensor"))
                    object.sensor = options.enums === String ? $root.lebai.motion.ForceSensor[message.sensor] === undefined ? message.sensor : $root.lebai.motion.ForceSensor[message.sensor] : message.sensor;
                return object;
            };

            /**
             * Converts this SetForceSensorRequest to JSON.
             * @function toJSON
             * @memberof lebai.motion.SetForceSensorRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetForceSensorRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetForceSensorRequest
             * @function getTypeUrl
             * @memberof lebai.motion.SetForceSensorRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetForceSensorRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.motion.SetForceSensorRequest";
            };

            return SetForceSensorRequest;
        })();

        motion.StartForceModeRequest = (function() {

            /**
             * Properties of a StartForceModeRequest.
             * @memberof lebai.motion
             * @interface IStartForceModeRequest
             * @property {lebai.posture.ICartesianPose|null} [limit] StartForceModeRequest limit
             * @property {lebai.motion.IWrench|null} [wrench] StartForceModeRequest wrench
             */

            /**
             * Constructs a new StartForceModeRequest.
             * @memberof lebai.motion
             * @classdesc Represents a StartForceModeRequest.
             * @implements IStartForceModeRequest
             * @constructor
             * @param {lebai.motion.IStartForceModeRequest=} [properties] Properties to set
             */
            function StartForceModeRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StartForceModeRequest limit.
             * @member {lebai.posture.ICartesianPose|null|undefined} limit
             * @memberof lebai.motion.StartForceModeRequest
             * @instance
             */
            StartForceModeRequest.prototype.limit = null;

            /**
             * StartForceModeRequest wrench.
             * @member {lebai.motion.IWrench|null|undefined} wrench
             * @memberof lebai.motion.StartForceModeRequest
             * @instance
             */
            StartForceModeRequest.prototype.wrench = null;

            /**
             * Creates a new StartForceModeRequest instance using the specified properties.
             * @function create
             * @memberof lebai.motion.StartForceModeRequest
             * @static
             * @param {lebai.motion.IStartForceModeRequest=} [properties] Properties to set
             * @returns {lebai.motion.StartForceModeRequest} StartForceModeRequest instance
             */
            StartForceModeRequest.create = function create(properties) {
                return new StartForceModeRequest(properties);
            };

            /**
             * Encodes the specified StartForceModeRequest message. Does not implicitly {@link lebai.motion.StartForceModeRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.motion.StartForceModeRequest
             * @static
             * @param {lebai.motion.IStartForceModeRequest} message StartForceModeRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StartForceModeRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.limit != null && Object.hasOwnProperty.call(message, "limit"))
                    $root.lebai.posture.CartesianPose.encode(message.limit, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.wrench != null && Object.hasOwnProperty.call(message, "wrench"))
                    $root.lebai.motion.Wrench.encode(message.wrench, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified StartForceModeRequest message, length delimited. Does not implicitly {@link lebai.motion.StartForceModeRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.motion.StartForceModeRequest
             * @static
             * @param {lebai.motion.IStartForceModeRequest} message StartForceModeRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StartForceModeRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StartForceModeRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.motion.StartForceModeRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.motion.StartForceModeRequest} StartForceModeRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StartForceModeRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.motion.StartForceModeRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.limit = $root.lebai.posture.CartesianPose.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.wrench = $root.lebai.motion.Wrench.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StartForceModeRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.motion.StartForceModeRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.motion.StartForceModeRequest} StartForceModeRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StartForceModeRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StartForceModeRequest message.
             * @function verify
             * @memberof lebai.motion.StartForceModeRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StartForceModeRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.limit != null && message.hasOwnProperty("limit")) {
                    var error = $root.lebai.posture.CartesianPose.verify(message.limit);
                    if (error)
                        return "limit." + error;
                }
                if (message.wrench != null && message.hasOwnProperty("wrench")) {
                    var error = $root.lebai.motion.Wrench.verify(message.wrench);
                    if (error)
                        return "wrench." + error;
                }
                return null;
            };

            /**
             * Creates a StartForceModeRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.motion.StartForceModeRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.motion.StartForceModeRequest} StartForceModeRequest
             */
            StartForceModeRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.motion.StartForceModeRequest)
                    return object;
                var message = new $root.lebai.motion.StartForceModeRequest();
                if (object.limit != null) {
                    if (typeof object.limit !== "object")
                        throw TypeError(".lebai.motion.StartForceModeRequest.limit: object expected");
                    message.limit = $root.lebai.posture.CartesianPose.fromObject(object.limit);
                }
                if (object.wrench != null) {
                    if (typeof object.wrench !== "object")
                        throw TypeError(".lebai.motion.StartForceModeRequest.wrench: object expected");
                    message.wrench = $root.lebai.motion.Wrench.fromObject(object.wrench);
                }
                return message;
            };

            /**
             * Creates a plain object from a StartForceModeRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.motion.StartForceModeRequest
             * @static
             * @param {lebai.motion.StartForceModeRequest} message StartForceModeRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StartForceModeRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.limit = null;
                    object.wrench = null;
                }
                if (message.limit != null && message.hasOwnProperty("limit"))
                    object.limit = $root.lebai.posture.CartesianPose.toObject(message.limit, options);
                if (message.wrench != null && message.hasOwnProperty("wrench"))
                    object.wrench = $root.lebai.motion.Wrench.toObject(message.wrench, options);
                return object;
            };

            /**
             * Converts this StartForceModeRequest to JSON.
             * @function toJSON
             * @memberof lebai.motion.StartForceModeRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StartForceModeRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for StartForceModeRequest
             * @function getTypeUrl
             * @memberof lebai.motion.StartForceModeRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            StartForceModeRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.motion.StartForceModeRequest";
            };

            return StartForceModeRequest;
        })();

        motion.ForceModeParam = (function() {

            /**
             * Properties of a ForceModeParam.
             * @memberof lebai.motion
             * @interface IForceModeParam
             * @property {number|null} [threshold] ForceModeParam threshold
             * @property {number|null} [damping] ForceModeParam damping
             * @property {number|null} [mass] ForceModeParam mass
             */

            /**
             * Constructs a new ForceModeParam.
             * @memberof lebai.motion
             * @classdesc Represents a ForceModeParam.
             * @implements IForceModeParam
             * @constructor
             * @param {lebai.motion.IForceModeParam=} [properties] Properties to set
             */
            function ForceModeParam(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ForceModeParam threshold.
             * @member {number} threshold
             * @memberof lebai.motion.ForceModeParam
             * @instance
             */
            ForceModeParam.prototype.threshold = 0;

            /**
             * ForceModeParam damping.
             * @member {number} damping
             * @memberof lebai.motion.ForceModeParam
             * @instance
             */
            ForceModeParam.prototype.damping = 0;

            /**
             * ForceModeParam mass.
             * @member {number} mass
             * @memberof lebai.motion.ForceModeParam
             * @instance
             */
            ForceModeParam.prototype.mass = 0;

            /**
             * Creates a new ForceModeParam instance using the specified properties.
             * @function create
             * @memberof lebai.motion.ForceModeParam
             * @static
             * @param {lebai.motion.IForceModeParam=} [properties] Properties to set
             * @returns {lebai.motion.ForceModeParam} ForceModeParam instance
             */
            ForceModeParam.create = function create(properties) {
                return new ForceModeParam(properties);
            };

            /**
             * Encodes the specified ForceModeParam message. Does not implicitly {@link lebai.motion.ForceModeParam.verify|verify} messages.
             * @function encode
             * @memberof lebai.motion.ForceModeParam
             * @static
             * @param {lebai.motion.IForceModeParam} message ForceModeParam message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ForceModeParam.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.threshold != null && Object.hasOwnProperty.call(message, "threshold"))
                    writer.uint32(/* id 1, wireType 1 =*/9).double(message.threshold);
                if (message.damping != null && Object.hasOwnProperty.call(message, "damping"))
                    writer.uint32(/* id 2, wireType 1 =*/17).double(message.damping);
                if (message.mass != null && Object.hasOwnProperty.call(message, "mass"))
                    writer.uint32(/* id 3, wireType 1 =*/25).double(message.mass);
                return writer;
            };

            /**
             * Encodes the specified ForceModeParam message, length delimited. Does not implicitly {@link lebai.motion.ForceModeParam.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.motion.ForceModeParam
             * @static
             * @param {lebai.motion.IForceModeParam} message ForceModeParam message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ForceModeParam.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ForceModeParam message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.motion.ForceModeParam
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.motion.ForceModeParam} ForceModeParam
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ForceModeParam.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.motion.ForceModeParam();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.threshold = reader.double();
                            break;
                        }
                    case 2: {
                            message.damping = reader.double();
                            break;
                        }
                    case 3: {
                            message.mass = reader.double();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ForceModeParam message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.motion.ForceModeParam
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.motion.ForceModeParam} ForceModeParam
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ForceModeParam.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ForceModeParam message.
             * @function verify
             * @memberof lebai.motion.ForceModeParam
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ForceModeParam.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.threshold != null && message.hasOwnProperty("threshold"))
                    if (typeof message.threshold !== "number")
                        return "threshold: number expected";
                if (message.damping != null && message.hasOwnProperty("damping"))
                    if (typeof message.damping !== "number")
                        return "damping: number expected";
                if (message.mass != null && message.hasOwnProperty("mass"))
                    if (typeof message.mass !== "number")
                        return "mass: number expected";
                return null;
            };

            /**
             * Creates a ForceModeParam message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.motion.ForceModeParam
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.motion.ForceModeParam} ForceModeParam
             */
            ForceModeParam.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.motion.ForceModeParam)
                    return object;
                var message = new $root.lebai.motion.ForceModeParam();
                if (object.threshold != null)
                    message.threshold = Number(object.threshold);
                if (object.damping != null)
                    message.damping = Number(object.damping);
                if (object.mass != null)
                    message.mass = Number(object.mass);
                return message;
            };

            /**
             * Creates a plain object from a ForceModeParam message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.motion.ForceModeParam
             * @static
             * @param {lebai.motion.ForceModeParam} message ForceModeParam
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ForceModeParam.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.threshold = 0;
                    object.damping = 0;
                    object.mass = 0;
                }
                if (message.threshold != null && message.hasOwnProperty("threshold"))
                    object.threshold = options.json && !isFinite(message.threshold) ? String(message.threshold) : message.threshold;
                if (message.damping != null && message.hasOwnProperty("damping"))
                    object.damping = options.json && !isFinite(message.damping) ? String(message.damping) : message.damping;
                if (message.mass != null && message.hasOwnProperty("mass"))
                    object.mass = options.json && !isFinite(message.mass) ? String(message.mass) : message.mass;
                return object;
            };

            /**
             * Converts this ForceModeParam to JSON.
             * @function toJSON
             * @memberof lebai.motion.ForceModeParam
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ForceModeParam.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ForceModeParam
             * @function getTypeUrl
             * @memberof lebai.motion.ForceModeParam
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ForceModeParam.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.motion.ForceModeParam";
            };

            return ForceModeParam;
        })();

        motion.SetForceModeParamRequest = (function() {

            /**
             * Properties of a SetForceModeParamRequest.
             * @memberof lebai.motion
             * @interface ISetForceModeParamRequest
             * @property {number|null} [threshold] SetForceModeParamRequest threshold
             * @property {number|null} [damping] SetForceModeParamRequest damping
             * @property {number|null} [mass] SetForceModeParamRequest mass
             */

            /**
             * Constructs a new SetForceModeParamRequest.
             * @memberof lebai.motion
             * @classdesc Represents a SetForceModeParamRequest.
             * @implements ISetForceModeParamRequest
             * @constructor
             * @param {lebai.motion.ISetForceModeParamRequest=} [properties] Properties to set
             */
            function SetForceModeParamRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SetForceModeParamRequest threshold.
             * @member {number|null|undefined} threshold
             * @memberof lebai.motion.SetForceModeParamRequest
             * @instance
             */
            SetForceModeParamRequest.prototype.threshold = null;

            /**
             * SetForceModeParamRequest damping.
             * @member {number|null|undefined} damping
             * @memberof lebai.motion.SetForceModeParamRequest
             * @instance
             */
            SetForceModeParamRequest.prototype.damping = null;

            /**
             * SetForceModeParamRequest mass.
             * @member {number|null|undefined} mass
             * @memberof lebai.motion.SetForceModeParamRequest
             * @instance
             */
            SetForceModeParamRequest.prototype.mass = null;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * SetForceModeParamRequest _threshold.
             * @member {"threshold"|undefined} _threshold
             * @memberof lebai.motion.SetForceModeParamRequest
             * @instance
             */
            Object.defineProperty(SetForceModeParamRequest.prototype, "_threshold", {
                get: $util.oneOfGetter($oneOfFields = ["threshold"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * SetForceModeParamRequest _damping.
             * @member {"damping"|undefined} _damping
             * @memberof lebai.motion.SetForceModeParamRequest
             * @instance
             */
            Object.defineProperty(SetForceModeParamRequest.prototype, "_damping", {
                get: $util.oneOfGetter($oneOfFields = ["damping"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * SetForceModeParamRequest _mass.
             * @member {"mass"|undefined} _mass
             * @memberof lebai.motion.SetForceModeParamRequest
             * @instance
             */
            Object.defineProperty(SetForceModeParamRequest.prototype, "_mass", {
                get: $util.oneOfGetter($oneOfFields = ["mass"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new SetForceModeParamRequest instance using the specified properties.
             * @function create
             * @memberof lebai.motion.SetForceModeParamRequest
             * @static
             * @param {lebai.motion.ISetForceModeParamRequest=} [properties] Properties to set
             * @returns {lebai.motion.SetForceModeParamRequest} SetForceModeParamRequest instance
             */
            SetForceModeParamRequest.create = function create(properties) {
                return new SetForceModeParamRequest(properties);
            };

            /**
             * Encodes the specified SetForceModeParamRequest message. Does not implicitly {@link lebai.motion.SetForceModeParamRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.motion.SetForceModeParamRequest
             * @static
             * @param {lebai.motion.ISetForceModeParamRequest} message SetForceModeParamRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetForceModeParamRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.threshold != null && Object.hasOwnProperty.call(message, "threshold"))
                    writer.uint32(/* id 1, wireType 1 =*/9).double(message.threshold);
                if (message.damping != null && Object.hasOwnProperty.call(message, "damping"))
                    writer.uint32(/* id 2, wireType 1 =*/17).double(message.damping);
                if (message.mass != null && Object.hasOwnProperty.call(message, "mass"))
                    writer.uint32(/* id 3, wireType 1 =*/25).double(message.mass);
                return writer;
            };

            /**
             * Encodes the specified SetForceModeParamRequest message, length delimited. Does not implicitly {@link lebai.motion.SetForceModeParamRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.motion.SetForceModeParamRequest
             * @static
             * @param {lebai.motion.ISetForceModeParamRequest} message SetForceModeParamRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetForceModeParamRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetForceModeParamRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.motion.SetForceModeParamRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.motion.SetForceModeParamRequest} SetForceModeParamRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetForceModeParamRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.motion.SetForceModeParamRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.threshold = reader.double();
                            break;
                        }
                    case 2: {
                            message.damping = reader.double();
                            break;
                        }
                    case 3: {
                            message.mass = reader.double();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetForceModeParamRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.motion.SetForceModeParamRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.motion.SetForceModeParamRequest} SetForceModeParamRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetForceModeParamRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetForceModeParamRequest message.
             * @function verify
             * @memberof lebai.motion.SetForceModeParamRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetForceModeParamRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.threshold != null && message.hasOwnProperty("threshold")) {
                    properties._threshold = 1;
                    if (typeof message.threshold !== "number")
                        return "threshold: number expected";
                }
                if (message.damping != null && message.hasOwnProperty("damping")) {
                    properties._damping = 1;
                    if (typeof message.damping !== "number")
                        return "damping: number expected";
                }
                if (message.mass != null && message.hasOwnProperty("mass")) {
                    properties._mass = 1;
                    if (typeof message.mass !== "number")
                        return "mass: number expected";
                }
                return null;
            };

            /**
             * Creates a SetForceModeParamRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.motion.SetForceModeParamRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.motion.SetForceModeParamRequest} SetForceModeParamRequest
             */
            SetForceModeParamRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.motion.SetForceModeParamRequest)
                    return object;
                var message = new $root.lebai.motion.SetForceModeParamRequest();
                if (object.threshold != null)
                    message.threshold = Number(object.threshold);
                if (object.damping != null)
                    message.damping = Number(object.damping);
                if (object.mass != null)
                    message.mass = Number(object.mass);
                return message;
            };

            /**
             * Creates a plain object from a SetForceModeParamRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.motion.SetForceModeParamRequest
             * @static
             * @param {lebai.motion.SetForceModeParamRequest} message SetForceModeParamRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetForceModeParamRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.threshold != null && message.hasOwnProperty("threshold")) {
                    object.threshold = options.json && !isFinite(message.threshold) ? String(message.threshold) : message.threshold;
                    if (options.oneofs)
                        object._threshold = "threshold";
                }
                if (message.damping != null && message.hasOwnProperty("damping")) {
                    object.damping = options.json && !isFinite(message.damping) ? String(message.damping) : message.damping;
                    if (options.oneofs)
                        object._damping = "damping";
                }
                if (message.mass != null && message.hasOwnProperty("mass")) {
                    object.mass = options.json && !isFinite(message.mass) ? String(message.mass) : message.mass;
                    if (options.oneofs)
                        object._mass = "mass";
                }
                return object;
            };

            /**
             * Converts this SetForceModeParamRequest to JSON.
             * @function toJSON
             * @memberof lebai.motion.SetForceModeParamRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetForceModeParamRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetForceModeParamRequest
             * @function getTypeUrl
             * @memberof lebai.motion.SetForceModeParamRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetForceModeParamRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.motion.SetForceModeParamRequest";
            };

            return SetForceModeParamRequest;
        })();

        motion.MotionService = (function() {

            /**
             * Constructs a new MotionService service.
             * @memberof lebai.motion
             * @classdesc Represents a MotionService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function MotionService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (MotionService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = MotionService;

            /**
             * Creates new MotionService service using the specified rpc implementation.
             * @function create
             * @memberof lebai.motion.MotionService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {MotionService} RPC service. Useful where requests and/or responses are streamed.
             */
            MotionService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link lebai.motion.MotionService#pauseMove}.
             * @memberof lebai.motion.MotionService
             * @typedef PauseMoveCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls PauseMove.
             * @function pauseMove
             * @memberof lebai.motion.MotionService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {lebai.motion.MotionService.PauseMoveCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MotionService.prototype.pauseMove = function pauseMove(request, callback) {
                return this.rpcCall(pauseMove, $root.google.protobuf.Empty, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "PauseMove" });

            /**
             * Calls PauseMove.
             * @function pauseMove
             * @memberof lebai.motion.MotionService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.motion.MotionService#resumeMove}.
             * @memberof lebai.motion.MotionService
             * @typedef ResumeMoveCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls ResumeMove.
             * @function resumeMove
             * @memberof lebai.motion.MotionService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {lebai.motion.MotionService.ResumeMoveCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MotionService.prototype.resumeMove = function resumeMove(request, callback) {
                return this.rpcCall(resumeMove, $root.google.protobuf.Empty, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "ResumeMove" });

            /**
             * Calls ResumeMove.
             * @function resumeMove
             * @memberof lebai.motion.MotionService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.motion.MotionService#stopMove}.
             * @memberof lebai.motion.MotionService
             * @typedef StopMoveCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls StopMove.
             * @function stopMove
             * @memberof lebai.motion.MotionService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {lebai.motion.MotionService.StopMoveCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MotionService.prototype.stopMove = function stopMove(request, callback) {
                return this.rpcCall(stopMove, $root.google.protobuf.Empty, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "StopMove" });

            /**
             * Calls StopMove.
             * @function stopMove
             * @memberof lebai.motion.MotionService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.motion.MotionService#skipMove}.
             * @memberof lebai.motion.MotionService
             * @typedef SkipMoveCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls SkipMove.
             * @function skipMove
             * @memberof lebai.motion.MotionService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {lebai.motion.MotionService.SkipMoveCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MotionService.prototype.skipMove = function skipMove(request, callback) {
                return this.rpcCall(skipMove, $root.google.protobuf.Empty, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "SkipMove" });

            /**
             * Calls SkipMove.
             * @function skipMove
             * @memberof lebai.motion.MotionService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.motion.MotionService#waitMove}.
             * @memberof lebai.motion.MotionService
             * @typedef WaitMoveCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls WaitMove.
             * @function waitMove
             * @memberof lebai.motion.MotionService
             * @instance
             * @param {lebai.motion.IMotionIndex} request MotionIndex message or plain object
             * @param {lebai.motion.MotionService.WaitMoveCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MotionService.prototype.waitMove = function waitMove(request, callback) {
                return this.rpcCall(waitMove, $root.lebai.motion.MotionIndex, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "WaitMove" });

            /**
             * Calls WaitMove.
             * @function waitMove
             * @memberof lebai.motion.MotionService
             * @instance
             * @param {lebai.motion.IMotionIndex} request MotionIndex message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.motion.MotionService#getRunningMotion}.
             * @memberof lebai.motion.MotionService
             * @typedef GetRunningMotionCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.motion.MotionIndex} [response] MotionIndex
             */

            /**
             * Calls GetRunningMotion.
             * @function getRunningMotion
             * @memberof lebai.motion.MotionService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {lebai.motion.MotionService.GetRunningMotionCallback} callback Node-style callback called with the error, if any, and MotionIndex
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MotionService.prototype.getRunningMotion = function getRunningMotion(request, callback) {
                return this.rpcCall(getRunningMotion, $root.google.protobuf.Empty, $root.lebai.motion.MotionIndex, request, callback);
            }, "name", { value: "GetRunningMotion" });

            /**
             * Calls GetRunningMotion.
             * @function getRunningMotion
             * @memberof lebai.motion.MotionService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<lebai.motion.MotionIndex>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.motion.MotionService#getMotionState}.
             * @memberof lebai.motion.MotionService
             * @typedef GetMotionStateCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.motion.GetMotionStateResponse} [response] GetMotionStateResponse
             */

            /**
             * Calls GetMotionState.
             * @function getMotionState
             * @memberof lebai.motion.MotionService
             * @instance
             * @param {lebai.motion.IMotionIndex} request MotionIndex message or plain object
             * @param {lebai.motion.MotionService.GetMotionStateCallback} callback Node-style callback called with the error, if any, and GetMotionStateResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MotionService.prototype.getMotionState = function getMotionState(request, callback) {
                return this.rpcCall(getMotionState, $root.lebai.motion.MotionIndex, $root.lebai.motion.GetMotionStateResponse, request, callback);
            }, "name", { value: "GetMotionState" });

            /**
             * Calls GetMotionState.
             * @function getMotionState
             * @memberof lebai.motion.MotionService
             * @instance
             * @param {lebai.motion.IMotionIndex} request MotionIndex message or plain object
             * @returns {Promise<lebai.motion.GetMotionStateResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.motion.MotionService#towardJoint}.
             * @memberof lebai.motion.MotionService
             * @typedef TowardJointCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.motion.MotionIndex} [response] MotionIndex
             */

            /**
             * Calls TowardJoint.
             * @function towardJoint
             * @memberof lebai.motion.MotionService
             * @instance
             * @param {lebai.motion.IMoveRequest} request MoveRequest message or plain object
             * @param {lebai.motion.MotionService.TowardJointCallback} callback Node-style callback called with the error, if any, and MotionIndex
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MotionService.prototype.towardJoint = function towardJoint(request, callback) {
                return this.rpcCall(towardJoint, $root.lebai.motion.MoveRequest, $root.lebai.motion.MotionIndex, request, callback);
            }, "name", { value: "TowardJoint" });

            /**
             * Calls TowardJoint.
             * @function towardJoint
             * @memberof lebai.motion.MotionService
             * @instance
             * @param {lebai.motion.IMoveRequest} request MoveRequest message or plain object
             * @returns {Promise<lebai.motion.MotionIndex>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.motion.MotionService#moveJoint}.
             * @memberof lebai.motion.MotionService
             * @typedef MoveJointCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.motion.MotionIndex} [response] MotionIndex
             */

            /**
             * Calls MoveJoint.
             * @function moveJoint
             * @memberof lebai.motion.MotionService
             * @instance
             * @param {lebai.motion.IMoveRequest} request MoveRequest message or plain object
             * @param {lebai.motion.MotionService.MoveJointCallback} callback Node-style callback called with the error, if any, and MotionIndex
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MotionService.prototype.moveJoint = function moveJoint(request, callback) {
                return this.rpcCall(moveJoint, $root.lebai.motion.MoveRequest, $root.lebai.motion.MotionIndex, request, callback);
            }, "name", { value: "MoveJoint" });

            /**
             * Calls MoveJoint.
             * @function moveJoint
             * @memberof lebai.motion.MotionService
             * @instance
             * @param {lebai.motion.IMoveRequest} request MoveRequest message or plain object
             * @returns {Promise<lebai.motion.MotionIndex>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.motion.MotionService#moveLinear}.
             * @memberof lebai.motion.MotionService
             * @typedef MoveLinearCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.motion.MotionIndex} [response] MotionIndex
             */

            /**
             * Calls MoveLinear.
             * @function moveLinear
             * @memberof lebai.motion.MotionService
             * @instance
             * @param {lebai.motion.IMoveRequest} request MoveRequest message or plain object
             * @param {lebai.motion.MotionService.MoveLinearCallback} callback Node-style callback called with the error, if any, and MotionIndex
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MotionService.prototype.moveLinear = function moveLinear(request, callback) {
                return this.rpcCall(moveLinear, $root.lebai.motion.MoveRequest, $root.lebai.motion.MotionIndex, request, callback);
            }, "name", { value: "MoveLinear" });

            /**
             * Calls MoveLinear.
             * @function moveLinear
             * @memberof lebai.motion.MotionService
             * @instance
             * @param {lebai.motion.IMoveRequest} request MoveRequest message or plain object
             * @returns {Promise<lebai.motion.MotionIndex>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.motion.MotionService#moveCircular}.
             * @memberof lebai.motion.MotionService
             * @typedef MoveCircularCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.motion.MotionIndex} [response] MotionIndex
             */

            /**
             * Calls MoveCircular.
             * @function moveCircular
             * @memberof lebai.motion.MotionService
             * @instance
             * @param {lebai.motion.IMovecRequest} request MovecRequest message or plain object
             * @param {lebai.motion.MotionService.MoveCircularCallback} callback Node-style callback called with the error, if any, and MotionIndex
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MotionService.prototype.moveCircular = function moveCircular(request, callback) {
                return this.rpcCall(moveCircular, $root.lebai.motion.MovecRequest, $root.lebai.motion.MotionIndex, request, callback);
            }, "name", { value: "MoveCircular" });

            /**
             * Calls MoveCircular.
             * @function moveCircular
             * @memberof lebai.motion.MotionService
             * @instance
             * @param {lebai.motion.IMovecRequest} request MovecRequest message or plain object
             * @returns {Promise<lebai.motion.MotionIndex>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.motion.MotionService#movePvat}.
             * @memberof lebai.motion.MotionService
             * @typedef MovePvatCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls MovePvat.
             * @function movePvat
             * @memberof lebai.motion.MotionService
             * @instance
             * @param {lebai.motion.IMovePvatRequest} request MovePvatRequest message or plain object
             * @param {lebai.motion.MotionService.MovePvatCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MotionService.prototype.movePvat = function movePvat(request, callback) {
                return this.rpcCall(movePvat, $root.lebai.motion.MovePvatRequest, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "MovePvat" });

            /**
             * Calls MovePvat.
             * @function movePvat
             * @memberof lebai.motion.MotionService
             * @instance
             * @param {lebai.motion.IMovePvatRequest} request MovePvatRequest message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.motion.MotionService#speedJoint}.
             * @memberof lebai.motion.MotionService
             * @typedef SpeedJointCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.motion.MotionIndex} [response] MotionIndex
             */

            /**
             * Calls SpeedJoint.
             * @function speedJoint
             * @memberof lebai.motion.MotionService
             * @instance
             * @param {lebai.motion.ISpeedJRequest} request SpeedJRequest message or plain object
             * @param {lebai.motion.MotionService.SpeedJointCallback} callback Node-style callback called with the error, if any, and MotionIndex
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MotionService.prototype.speedJoint = function speedJoint(request, callback) {
                return this.rpcCall(speedJoint, $root.lebai.motion.SpeedJRequest, $root.lebai.motion.MotionIndex, request, callback);
            }, "name", { value: "SpeedJoint" });

            /**
             * Calls SpeedJoint.
             * @function speedJoint
             * @memberof lebai.motion.MotionService
             * @instance
             * @param {lebai.motion.ISpeedJRequest} request SpeedJRequest message or plain object
             * @returns {Promise<lebai.motion.MotionIndex>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.motion.MotionService#speedLinear}.
             * @memberof lebai.motion.MotionService
             * @typedef SpeedLinearCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.motion.MotionIndex} [response] MotionIndex
             */

            /**
             * Calls SpeedLinear.
             * @function speedLinear
             * @memberof lebai.motion.MotionService
             * @instance
             * @param {lebai.motion.ISpeedLRequest} request SpeedLRequest message or plain object
             * @param {lebai.motion.MotionService.SpeedLinearCallback} callback Node-style callback called with the error, if any, and MotionIndex
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MotionService.prototype.speedLinear = function speedLinear(request, callback) {
                return this.rpcCall(speedLinear, $root.lebai.motion.SpeedLRequest, $root.lebai.motion.MotionIndex, request, callback);
            }, "name", { value: "SpeedLinear" });

            /**
             * Calls SpeedLinear.
             * @function speedLinear
             * @memberof lebai.motion.MotionService
             * @instance
             * @param {lebai.motion.ISpeedLRequest} request SpeedLRequest message or plain object
             * @returns {Promise<lebai.motion.MotionIndex>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.motion.MotionService#saveTrajectory}.
             * @memberof lebai.motion.MotionService
             * @typedef SaveTrajectoryCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls SaveTrajectory.
             * @function saveTrajectory
             * @memberof lebai.motion.MotionService
             * @instance
             * @param {lebai.motion.ISaveTrajectoryRequest} request SaveTrajectoryRequest message or plain object
             * @param {lebai.motion.MotionService.SaveTrajectoryCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MotionService.prototype.saveTrajectory = function saveTrajectory(request, callback) {
                return this.rpcCall(saveTrajectory, $root.lebai.motion.SaveTrajectoryRequest, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "SaveTrajectory" });

            /**
             * Calls SaveTrajectory.
             * @function saveTrajectory
             * @memberof lebai.motion.MotionService
             * @instance
             * @param {lebai.motion.ISaveTrajectoryRequest} request SaveTrajectoryRequest message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.motion.MotionService#loadTrajectory}.
             * @memberof lebai.motion.MotionService
             * @typedef LoadTrajectoryCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.motion.Trajectory} [response] Trajectory
             */

            /**
             * Calls LoadTrajectory.
             * @function loadTrajectory
             * @memberof lebai.motion.MotionService
             * @instance
             * @param {lebai.db.ILoadRequest} request LoadRequest message or plain object
             * @param {lebai.motion.MotionService.LoadTrajectoryCallback} callback Node-style callback called with the error, if any, and Trajectory
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MotionService.prototype.loadTrajectory = function loadTrajectory(request, callback) {
                return this.rpcCall(loadTrajectory, $root.lebai.db.LoadRequest, $root.lebai.motion.Trajectory, request, callback);
            }, "name", { value: "LoadTrajectory" });

            /**
             * Calls LoadTrajectory.
             * @function loadTrajectory
             * @memberof lebai.motion.MotionService
             * @instance
             * @param {lebai.db.ILoadRequest} request LoadRequest message or plain object
             * @returns {Promise<lebai.motion.Trajectory>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.motion.MotionService#loadTrajectoryList}.
             * @memberof lebai.motion.MotionService
             * @typedef LoadTrajectoryListCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.db.LoadListResponse} [response] LoadListResponse
             */

            /**
             * Calls LoadTrajectoryList.
             * @function loadTrajectoryList
             * @memberof lebai.motion.MotionService
             * @instance
             * @param {lebai.db.ILoadListRequest} request LoadListRequest message or plain object
             * @param {lebai.motion.MotionService.LoadTrajectoryListCallback} callback Node-style callback called with the error, if any, and LoadListResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MotionService.prototype.loadTrajectoryList = function loadTrajectoryList(request, callback) {
                return this.rpcCall(loadTrajectoryList, $root.lebai.db.LoadListRequest, $root.lebai.db.LoadListResponse, request, callback);
            }, "name", { value: "LoadTrajectoryList" });

            /**
             * Calls LoadTrajectoryList.
             * @function loadTrajectoryList
             * @memberof lebai.motion.MotionService
             * @instance
             * @param {lebai.db.ILoadListRequest} request LoadListRequest message or plain object
             * @returns {Promise<lebai.db.LoadListResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.motion.MotionService#startRecordTrajectory}.
             * @memberof lebai.motion.MotionService
             * @typedef StartRecordTrajectoryCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls StartRecordTrajectory.
             * @function startRecordTrajectory
             * @memberof lebai.motion.MotionService
             * @instance
             * @param {lebai.motion.IStartRecordTrajectoryRequest} request StartRecordTrajectoryRequest message or plain object
             * @param {lebai.motion.MotionService.StartRecordTrajectoryCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MotionService.prototype.startRecordTrajectory = function startRecordTrajectory(request, callback) {
                return this.rpcCall(startRecordTrajectory, $root.lebai.motion.StartRecordTrajectoryRequest, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "StartRecordTrajectory" });

            /**
             * Calls StartRecordTrajectory.
             * @function startRecordTrajectory
             * @memberof lebai.motion.MotionService
             * @instance
             * @param {lebai.motion.IStartRecordTrajectoryRequest} request StartRecordTrajectoryRequest message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.motion.MotionService#endRecordTrajectory}.
             * @memberof lebai.motion.MotionService
             * @typedef EndRecordTrajectoryCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls EndRecordTrajectory.
             * @function endRecordTrajectory
             * @memberof lebai.motion.MotionService
             * @instance
             * @param {lebai.motion.IEndRecordTrajectoryRequest} request EndRecordTrajectoryRequest message or plain object
             * @param {lebai.motion.MotionService.EndRecordTrajectoryCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MotionService.prototype.endRecordTrajectory = function endRecordTrajectory(request, callback) {
                return this.rpcCall(endRecordTrajectory, $root.lebai.motion.EndRecordTrajectoryRequest, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "EndRecordTrajectory" });

            /**
             * Calls EndRecordTrajectory.
             * @function endRecordTrajectory
             * @memberof lebai.motion.MotionService
             * @instance
             * @param {lebai.motion.IEndRecordTrajectoryRequest} request EndRecordTrajectoryRequest message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.motion.MotionService#moveTrajectory}.
             * @memberof lebai.motion.MotionService
             * @typedef MoveTrajectoryCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.motion.MotionIndex} [response] MotionIndex
             */

            /**
             * Calls MoveTrajectory.
             * @function moveTrajectory
             * @memberof lebai.motion.MotionService
             * @instance
             * @param {lebai.db.ILoadRequest} request LoadRequest message or plain object
             * @param {lebai.motion.MotionService.MoveTrajectoryCallback} callback Node-style callback called with the error, if any, and MotionIndex
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MotionService.prototype.moveTrajectory = function moveTrajectory(request, callback) {
                return this.rpcCall(moveTrajectory, $root.lebai.db.LoadRequest, $root.lebai.motion.MotionIndex, request, callback);
            }, "name", { value: "MoveTrajectory" });

            /**
             * Calls MoveTrajectory.
             * @function moveTrajectory
             * @memberof lebai.motion.MotionService
             * @instance
             * @param {lebai.db.ILoadRequest} request LoadRequest message or plain object
             * @returns {Promise<lebai.motion.MotionIndex>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.motion.MotionService#startTeachMode}.
             * @memberof lebai.motion.MotionService
             * @typedef StartTeachModeCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls StartTeachMode.
             * @function startTeachMode
             * @memberof lebai.motion.MotionService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {lebai.motion.MotionService.StartTeachModeCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MotionService.prototype.startTeachMode = function startTeachMode(request, callback) {
                return this.rpcCall(startTeachMode, $root.google.protobuf.Empty, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "StartTeachMode" });

            /**
             * Calls StartTeachMode.
             * @function startTeachMode
             * @memberof lebai.motion.MotionService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.motion.MotionService#endTeachMode}.
             * @memberof lebai.motion.MotionService
             * @typedef EndTeachModeCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls EndTeachMode.
             * @function endTeachMode
             * @memberof lebai.motion.MotionService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {lebai.motion.MotionService.EndTeachModeCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MotionService.prototype.endTeachMode = function endTeachMode(request, callback) {
                return this.rpcCall(endTeachMode, $root.google.protobuf.Empty, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "EndTeachMode" });

            /**
             * Calls EndTeachMode.
             * @function endTeachMode
             * @memberof lebai.motion.MotionService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.motion.MotionService#setTcpForce}.
             * @memberof lebai.motion.MotionService
             * @typedef SetTcpForceCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls SetTcpForce.
             * @function setTcpForce
             * @memberof lebai.motion.MotionService
             * @instance
             * @param {lebai.motion.IWrench} request Wrench message or plain object
             * @param {lebai.motion.MotionService.SetTcpForceCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MotionService.prototype.setTcpForce = function setTcpForce(request, callback) {
                return this.rpcCall(setTcpForce, $root.lebai.motion.Wrench, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "SetTcpForce" });

            /**
             * Calls SetTcpForce.
             * @function setTcpForce
             * @memberof lebai.motion.MotionService
             * @instance
             * @param {lebai.motion.IWrench} request Wrench message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.motion.MotionService#getTcpForce}.
             * @memberof lebai.motion.MotionService
             * @typedef GetTcpForceCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.motion.Wrench} [response] Wrench
             */

            /**
             * Calls GetTcpForce.
             * @function getTcpForce
             * @memberof lebai.motion.MotionService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {lebai.motion.MotionService.GetTcpForceCallback} callback Node-style callback called with the error, if any, and Wrench
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MotionService.prototype.getTcpForce = function getTcpForce(request, callback) {
                return this.rpcCall(getTcpForce, $root.google.protobuf.Empty, $root.lebai.motion.Wrench, request, callback);
            }, "name", { value: "GetTcpForce" });

            /**
             * Calls GetTcpForce.
             * @function getTcpForce
             * @memberof lebai.motion.MotionService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<lebai.motion.Wrench>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.motion.MotionService#setForceModeSensor}.
             * @memberof lebai.motion.MotionService
             * @typedef SetForceModeSensorCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls SetForceModeSensor.
             * @function setForceModeSensor
             * @memberof lebai.motion.MotionService
             * @instance
             * @param {lebai.motion.ISetForceSensorRequest} request SetForceSensorRequest message or plain object
             * @param {lebai.motion.MotionService.SetForceModeSensorCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MotionService.prototype.setForceModeSensor = function setForceModeSensor(request, callback) {
                return this.rpcCall(setForceModeSensor, $root.lebai.motion.SetForceSensorRequest, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "SetForceModeSensor" });

            /**
             * Calls SetForceModeSensor.
             * @function setForceModeSensor
             * @memberof lebai.motion.MotionService
             * @instance
             * @param {lebai.motion.ISetForceSensorRequest} request SetForceSensorRequest message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.motion.MotionService#setForceModeParam}.
             * @memberof lebai.motion.MotionService
             * @typedef SetForceModeParamCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls SetForceModeParam.
             * @function setForceModeParam
             * @memberof lebai.motion.MotionService
             * @instance
             * @param {lebai.motion.ISetForceModeParamRequest} request SetForceModeParamRequest message or plain object
             * @param {lebai.motion.MotionService.SetForceModeParamCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MotionService.prototype.setForceModeParam = function setForceModeParam(request, callback) {
                return this.rpcCall(setForceModeParam, $root.lebai.motion.SetForceModeParamRequest, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "SetForceModeParam" });

            /**
             * Calls SetForceModeParam.
             * @function setForceModeParam
             * @memberof lebai.motion.MotionService
             * @instance
             * @param {lebai.motion.ISetForceModeParamRequest} request SetForceModeParamRequest message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.motion.MotionService#startForceMode}.
             * @memberof lebai.motion.MotionService
             * @typedef StartForceModeCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls StartForceMode.
             * @function startForceMode
             * @memberof lebai.motion.MotionService
             * @instance
             * @param {lebai.motion.IStartForceModeRequest} request StartForceModeRequest message or plain object
             * @param {lebai.motion.MotionService.StartForceModeCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MotionService.prototype.startForceMode = function startForceMode(request, callback) {
                return this.rpcCall(startForceMode, $root.lebai.motion.StartForceModeRequest, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "StartForceMode" });

            /**
             * Calls StartForceMode.
             * @function startForceMode
             * @memberof lebai.motion.MotionService
             * @instance
             * @param {lebai.motion.IStartForceModeRequest} request StartForceModeRequest message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.motion.MotionService#endForceMode}.
             * @memberof lebai.motion.MotionService
             * @typedef EndForceModeCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls EndForceMode.
             * @function endForceMode
             * @memberof lebai.motion.MotionService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {lebai.motion.MotionService.EndForceModeCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MotionService.prototype.endForceMode = function endForceMode(request, callback) {
                return this.rpcCall(endForceMode, $root.google.protobuf.Empty, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "EndForceMode" });

            /**
             * Calls EndForceMode.
             * @function endForceMode
             * @memberof lebai.motion.MotionService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            return MotionService;
        })();

        return motion;
    })();

    lebai.motor = (function() {

        /**
         * Namespace motor.
         * @memberof lebai
         * @namespace
         */
        var motor = {};

        /**
         * MotorMode enum.
         * @name lebai.motor.MotorMode
         * @enum {number}
         * @property {number} POSITION=0 POSITION value
         * @property {number} TORQUE=1 TORQUE value
         * @property {number} SPEED=2 SPEED value
         */
        motor.MotorMode = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "POSITION"] = 0;
            values[valuesById[1] = "TORQUE"] = 1;
            values[valuesById[2] = "SPEED"] = 2;
            return values;
        })();

        motor.ServoParam = (function() {

            /**
             * Properties of a ServoParam.
             * @memberof lebai.motor
             * @interface IServoParam
             * @property {number|null} [positionKp] ServoParam positionKp
             * @property {number|null} [speedKp] ServoParam speedKp
             * @property {number|null} [speedIt] ServoParam speedIt
             * @property {number|null} [torqueCmdFilter] ServoParam torqueCmdFilter
             */

            /**
             * Constructs a new ServoParam.
             * @memberof lebai.motor
             * @classdesc Represents a ServoParam.
             * @implements IServoParam
             * @constructor
             * @param {lebai.motor.IServoParam=} [properties] Properties to set
             */
            function ServoParam(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ServoParam positionKp.
             * @member {number} positionKp
             * @memberof lebai.motor.ServoParam
             * @instance
             */
            ServoParam.prototype.positionKp = 0;

            /**
             * ServoParam speedKp.
             * @member {number} speedKp
             * @memberof lebai.motor.ServoParam
             * @instance
             */
            ServoParam.prototype.speedKp = 0;

            /**
             * ServoParam speedIt.
             * @member {number} speedIt
             * @memberof lebai.motor.ServoParam
             * @instance
             */
            ServoParam.prototype.speedIt = 0;

            /**
             * ServoParam torqueCmdFilter.
             * @member {number} torqueCmdFilter
             * @memberof lebai.motor.ServoParam
             * @instance
             */
            ServoParam.prototype.torqueCmdFilter = 0;

            /**
             * Creates a new ServoParam instance using the specified properties.
             * @function create
             * @memberof lebai.motor.ServoParam
             * @static
             * @param {lebai.motor.IServoParam=} [properties] Properties to set
             * @returns {lebai.motor.ServoParam} ServoParam instance
             */
            ServoParam.create = function create(properties) {
                return new ServoParam(properties);
            };

            /**
             * Encodes the specified ServoParam message. Does not implicitly {@link lebai.motor.ServoParam.verify|verify} messages.
             * @function encode
             * @memberof lebai.motor.ServoParam
             * @static
             * @param {lebai.motor.IServoParam} message ServoParam message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServoParam.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.positionKp != null && Object.hasOwnProperty.call(message, "positionKp"))
                    writer.uint32(/* id 1, wireType 1 =*/9).double(message.positionKp);
                if (message.speedKp != null && Object.hasOwnProperty.call(message, "speedKp"))
                    writer.uint32(/* id 2, wireType 1 =*/17).double(message.speedKp);
                if (message.speedIt != null && Object.hasOwnProperty.call(message, "speedIt"))
                    writer.uint32(/* id 3, wireType 1 =*/25).double(message.speedIt);
                if (message.torqueCmdFilter != null && Object.hasOwnProperty.call(message, "torqueCmdFilter"))
                    writer.uint32(/* id 4, wireType 1 =*/33).double(message.torqueCmdFilter);
                return writer;
            };

            /**
             * Encodes the specified ServoParam message, length delimited. Does not implicitly {@link lebai.motor.ServoParam.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.motor.ServoParam
             * @static
             * @param {lebai.motor.IServoParam} message ServoParam message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServoParam.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ServoParam message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.motor.ServoParam
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.motor.ServoParam} ServoParam
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServoParam.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.motor.ServoParam();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.positionKp = reader.double();
                            break;
                        }
                    case 2: {
                            message.speedKp = reader.double();
                            break;
                        }
                    case 3: {
                            message.speedIt = reader.double();
                            break;
                        }
                    case 4: {
                            message.torqueCmdFilter = reader.double();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ServoParam message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.motor.ServoParam
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.motor.ServoParam} ServoParam
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServoParam.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ServoParam message.
             * @function verify
             * @memberof lebai.motor.ServoParam
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ServoParam.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.positionKp != null && message.hasOwnProperty("positionKp"))
                    if (typeof message.positionKp !== "number")
                        return "positionKp: number expected";
                if (message.speedKp != null && message.hasOwnProperty("speedKp"))
                    if (typeof message.speedKp !== "number")
                        return "speedKp: number expected";
                if (message.speedIt != null && message.hasOwnProperty("speedIt"))
                    if (typeof message.speedIt !== "number")
                        return "speedIt: number expected";
                if (message.torqueCmdFilter != null && message.hasOwnProperty("torqueCmdFilter"))
                    if (typeof message.torqueCmdFilter !== "number")
                        return "torqueCmdFilter: number expected";
                return null;
            };

            /**
             * Creates a ServoParam message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.motor.ServoParam
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.motor.ServoParam} ServoParam
             */
            ServoParam.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.motor.ServoParam)
                    return object;
                var message = new $root.lebai.motor.ServoParam();
                if (object.positionKp != null)
                    message.positionKp = Number(object.positionKp);
                if (object.speedKp != null)
                    message.speedKp = Number(object.speedKp);
                if (object.speedIt != null)
                    message.speedIt = Number(object.speedIt);
                if (object.torqueCmdFilter != null)
                    message.torqueCmdFilter = Number(object.torqueCmdFilter);
                return message;
            };

            /**
             * Creates a plain object from a ServoParam message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.motor.ServoParam
             * @static
             * @param {lebai.motor.ServoParam} message ServoParam
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ServoParam.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.positionKp = 0;
                    object.speedKp = 0;
                    object.speedIt = 0;
                    object.torqueCmdFilter = 0;
                }
                if (message.positionKp != null && message.hasOwnProperty("positionKp"))
                    object.positionKp = options.json && !isFinite(message.positionKp) ? String(message.positionKp) : message.positionKp;
                if (message.speedKp != null && message.hasOwnProperty("speedKp"))
                    object.speedKp = options.json && !isFinite(message.speedKp) ? String(message.speedKp) : message.speedKp;
                if (message.speedIt != null && message.hasOwnProperty("speedIt"))
                    object.speedIt = options.json && !isFinite(message.speedIt) ? String(message.speedIt) : message.speedIt;
                if (message.torqueCmdFilter != null && message.hasOwnProperty("torqueCmdFilter"))
                    object.torqueCmdFilter = options.json && !isFinite(message.torqueCmdFilter) ? String(message.torqueCmdFilter) : message.torqueCmdFilter;
                return object;
            };

            /**
             * Converts this ServoParam to JSON.
             * @function toJSON
             * @memberof lebai.motor.ServoParam
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ServoParam.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ServoParam
             * @function getTypeUrl
             * @memberof lebai.motor.ServoParam
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ServoParam.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.motor.ServoParam";
            };

            return ServoParam;
        })();

        motor.ServoParams = (function() {

            /**
             * Properties of a ServoParams.
             * @memberof lebai.motor
             * @interface IServoParams
             * @property {Array.<lebai.motor.IServoParam>|null} [params] ServoParams params
             */

            /**
             * Constructs a new ServoParams.
             * @memberof lebai.motor
             * @classdesc Represents a ServoParams.
             * @implements IServoParams
             * @constructor
             * @param {lebai.motor.IServoParams=} [properties] Properties to set
             */
            function ServoParams(properties) {
                this.params = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ServoParams params.
             * @member {Array.<lebai.motor.IServoParam>} params
             * @memberof lebai.motor.ServoParams
             * @instance
             */
            ServoParams.prototype.params = $util.emptyArray;

            /**
             * Creates a new ServoParams instance using the specified properties.
             * @function create
             * @memberof lebai.motor.ServoParams
             * @static
             * @param {lebai.motor.IServoParams=} [properties] Properties to set
             * @returns {lebai.motor.ServoParams} ServoParams instance
             */
            ServoParams.create = function create(properties) {
                return new ServoParams(properties);
            };

            /**
             * Encodes the specified ServoParams message. Does not implicitly {@link lebai.motor.ServoParams.verify|verify} messages.
             * @function encode
             * @memberof lebai.motor.ServoParams
             * @static
             * @param {lebai.motor.IServoParams} message ServoParams message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServoParams.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.params != null && message.params.length)
                    for (var i = 0; i < message.params.length; ++i)
                        $root.lebai.motor.ServoParam.encode(message.params[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ServoParams message, length delimited. Does not implicitly {@link lebai.motor.ServoParams.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.motor.ServoParams
             * @static
             * @param {lebai.motor.IServoParams} message ServoParams message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServoParams.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ServoParams message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.motor.ServoParams
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.motor.ServoParams} ServoParams
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServoParams.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.motor.ServoParams();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.params && message.params.length))
                                message.params = [];
                            message.params.push($root.lebai.motor.ServoParam.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ServoParams message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.motor.ServoParams
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.motor.ServoParams} ServoParams
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServoParams.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ServoParams message.
             * @function verify
             * @memberof lebai.motor.ServoParams
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ServoParams.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.params != null && message.hasOwnProperty("params")) {
                    if (!Array.isArray(message.params))
                        return "params: array expected";
                    for (var i = 0; i < message.params.length; ++i) {
                        var error = $root.lebai.motor.ServoParam.verify(message.params[i]);
                        if (error)
                            return "params." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a ServoParams message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.motor.ServoParams
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.motor.ServoParams} ServoParams
             */
            ServoParams.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.motor.ServoParams)
                    return object;
                var message = new $root.lebai.motor.ServoParams();
                if (object.params) {
                    if (!Array.isArray(object.params))
                        throw TypeError(".lebai.motor.ServoParams.params: array expected");
                    message.params = [];
                    for (var i = 0; i < object.params.length; ++i) {
                        if (typeof object.params[i] !== "object")
                            throw TypeError(".lebai.motor.ServoParams.params: object expected");
                        message.params[i] = $root.lebai.motor.ServoParam.fromObject(object.params[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a ServoParams message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.motor.ServoParams
             * @static
             * @param {lebai.motor.ServoParams} message ServoParams
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ServoParams.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.params = [];
                if (message.params && message.params.length) {
                    object.params = [];
                    for (var j = 0; j < message.params.length; ++j)
                        object.params[j] = $root.lebai.motor.ServoParam.toObject(message.params[j], options);
                }
                return object;
            };

            /**
             * Converts this ServoParams to JSON.
             * @function toJSON
             * @memberof lebai.motor.ServoParams
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ServoParams.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ServoParams
             * @function getTypeUrl
             * @memberof lebai.motor.ServoParams
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ServoParams.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.motor.ServoParams";
            };

            return ServoParams;
        })();

        motor.SetZeroRequest = (function() {

            /**
             * Properties of a SetZeroRequest.
             * @memberof lebai.motor
             * @interface ISetZeroRequest
             * @property {Array.<number>|null} [pose] SetZeroRequest pose
             * @property {Array.<boolean>|null} [valids] SetZeroRequest valids
             */

            /**
             * Constructs a new SetZeroRequest.
             * @memberof lebai.motor
             * @classdesc Represents a SetZeroRequest.
             * @implements ISetZeroRequest
             * @constructor
             * @param {lebai.motor.ISetZeroRequest=} [properties] Properties to set
             */
            function SetZeroRequest(properties) {
                this.pose = [];
                this.valids = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SetZeroRequest pose.
             * @member {Array.<number>} pose
             * @memberof lebai.motor.SetZeroRequest
             * @instance
             */
            SetZeroRequest.prototype.pose = $util.emptyArray;

            /**
             * SetZeroRequest valids.
             * @member {Array.<boolean>} valids
             * @memberof lebai.motor.SetZeroRequest
             * @instance
             */
            SetZeroRequest.prototype.valids = $util.emptyArray;

            /**
             * Creates a new SetZeroRequest instance using the specified properties.
             * @function create
             * @memberof lebai.motor.SetZeroRequest
             * @static
             * @param {lebai.motor.ISetZeroRequest=} [properties] Properties to set
             * @returns {lebai.motor.SetZeroRequest} SetZeroRequest instance
             */
            SetZeroRequest.create = function create(properties) {
                return new SetZeroRequest(properties);
            };

            /**
             * Encodes the specified SetZeroRequest message. Does not implicitly {@link lebai.motor.SetZeroRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.motor.SetZeroRequest
             * @static
             * @param {lebai.motor.ISetZeroRequest} message SetZeroRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetZeroRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.pose != null && message.pose.length) {
                    writer.uint32(/* id 1, wireType 2 =*/10).fork();
                    for (var i = 0; i < message.pose.length; ++i)
                        writer.double(message.pose[i]);
                    writer.ldelim();
                }
                if (message.valids != null && message.valids.length) {
                    writer.uint32(/* id 2, wireType 2 =*/18).fork();
                    for (var i = 0; i < message.valids.length; ++i)
                        writer.bool(message.valids[i]);
                    writer.ldelim();
                }
                return writer;
            };

            /**
             * Encodes the specified SetZeroRequest message, length delimited. Does not implicitly {@link lebai.motor.SetZeroRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.motor.SetZeroRequest
             * @static
             * @param {lebai.motor.ISetZeroRequest} message SetZeroRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetZeroRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetZeroRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.motor.SetZeroRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.motor.SetZeroRequest} SetZeroRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetZeroRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.motor.SetZeroRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.pose && message.pose.length))
                                message.pose = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.pose.push(reader.double());
                            } else
                                message.pose.push(reader.double());
                            break;
                        }
                    case 2: {
                            if (!(message.valids && message.valids.length))
                                message.valids = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.valids.push(reader.bool());
                            } else
                                message.valids.push(reader.bool());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetZeroRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.motor.SetZeroRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.motor.SetZeroRequest} SetZeroRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetZeroRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetZeroRequest message.
             * @function verify
             * @memberof lebai.motor.SetZeroRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetZeroRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.pose != null && message.hasOwnProperty("pose")) {
                    if (!Array.isArray(message.pose))
                        return "pose: array expected";
                    for (var i = 0; i < message.pose.length; ++i)
                        if (typeof message.pose[i] !== "number")
                            return "pose: number[] expected";
                }
                if (message.valids != null && message.hasOwnProperty("valids")) {
                    if (!Array.isArray(message.valids))
                        return "valids: array expected";
                    for (var i = 0; i < message.valids.length; ++i)
                        if (typeof message.valids[i] !== "boolean")
                            return "valids: boolean[] expected";
                }
                return null;
            };

            /**
             * Creates a SetZeroRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.motor.SetZeroRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.motor.SetZeroRequest} SetZeroRequest
             */
            SetZeroRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.motor.SetZeroRequest)
                    return object;
                var message = new $root.lebai.motor.SetZeroRequest();
                if (object.pose) {
                    if (!Array.isArray(object.pose))
                        throw TypeError(".lebai.motor.SetZeroRequest.pose: array expected");
                    message.pose = [];
                    for (var i = 0; i < object.pose.length; ++i)
                        message.pose[i] = Number(object.pose[i]);
                }
                if (object.valids) {
                    if (!Array.isArray(object.valids))
                        throw TypeError(".lebai.motor.SetZeroRequest.valids: array expected");
                    message.valids = [];
                    for (var i = 0; i < object.valids.length; ++i)
                        message.valids[i] = Boolean(object.valids[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a SetZeroRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.motor.SetZeroRequest
             * @static
             * @param {lebai.motor.SetZeroRequest} message SetZeroRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetZeroRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.pose = [];
                    object.valids = [];
                }
                if (message.pose && message.pose.length) {
                    object.pose = [];
                    for (var j = 0; j < message.pose.length; ++j)
                        object.pose[j] = options.json && !isFinite(message.pose[j]) ? String(message.pose[j]) : message.pose[j];
                }
                if (message.valids && message.valids.length) {
                    object.valids = [];
                    for (var j = 0; j < message.valids.length; ++j)
                        object.valids[j] = message.valids[j];
                }
                return object;
            };

            /**
             * Converts this SetZeroRequest to JSON.
             * @function toJSON
             * @memberof lebai.motor.SetZeroRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetZeroRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetZeroRequest
             * @function getTypeUrl
             * @memberof lebai.motor.SetZeroRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetZeroRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.motor.SetZeroRequest";
            };

            return SetZeroRequest;
        })();

        motor.ExtraServoParam = (function() {

            /**
             * Properties of an ExtraServoParam.
             * @memberof lebai.motor
             * @interface IExtraServoParam
             * @property {number|null} [accPositionKp] ExtraServoParam accPositionKp
             * @property {number|null} [accSpeedKp] ExtraServoParam accSpeedKp
             * @property {number|null} [accSpeedIt] ExtraServoParam accSpeedIt
             * @property {number|null} [uniPositionKp] ExtraServoParam uniPositionKp
             * @property {number|null} [uniSpeedKp] ExtraServoParam uniSpeedKp
             * @property {number|null} [uniSpeedIt] ExtraServoParam uniSpeedIt
             * @property {number|null} [decPositionKp] ExtraServoParam decPositionKp
             * @property {number|null} [decSpeedKp] ExtraServoParam decSpeedKp
             * @property {number|null} [decSpeedIt] ExtraServoParam decSpeedIt
             */

            /**
             * Constructs a new ExtraServoParam.
             * @memberof lebai.motor
             * @classdesc Represents an ExtraServoParam.
             * @implements IExtraServoParam
             * @constructor
             * @param {lebai.motor.IExtraServoParam=} [properties] Properties to set
             */
            function ExtraServoParam(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExtraServoParam accPositionKp.
             * @member {number} accPositionKp
             * @memberof lebai.motor.ExtraServoParam
             * @instance
             */
            ExtraServoParam.prototype.accPositionKp = 0;

            /**
             * ExtraServoParam accSpeedKp.
             * @member {number} accSpeedKp
             * @memberof lebai.motor.ExtraServoParam
             * @instance
             */
            ExtraServoParam.prototype.accSpeedKp = 0;

            /**
             * ExtraServoParam accSpeedIt.
             * @member {number} accSpeedIt
             * @memberof lebai.motor.ExtraServoParam
             * @instance
             */
            ExtraServoParam.prototype.accSpeedIt = 0;

            /**
             * ExtraServoParam uniPositionKp.
             * @member {number} uniPositionKp
             * @memberof lebai.motor.ExtraServoParam
             * @instance
             */
            ExtraServoParam.prototype.uniPositionKp = 0;

            /**
             * ExtraServoParam uniSpeedKp.
             * @member {number} uniSpeedKp
             * @memberof lebai.motor.ExtraServoParam
             * @instance
             */
            ExtraServoParam.prototype.uniSpeedKp = 0;

            /**
             * ExtraServoParam uniSpeedIt.
             * @member {number} uniSpeedIt
             * @memberof lebai.motor.ExtraServoParam
             * @instance
             */
            ExtraServoParam.prototype.uniSpeedIt = 0;

            /**
             * ExtraServoParam decPositionKp.
             * @member {number} decPositionKp
             * @memberof lebai.motor.ExtraServoParam
             * @instance
             */
            ExtraServoParam.prototype.decPositionKp = 0;

            /**
             * ExtraServoParam decSpeedKp.
             * @member {number} decSpeedKp
             * @memberof lebai.motor.ExtraServoParam
             * @instance
             */
            ExtraServoParam.prototype.decSpeedKp = 0;

            /**
             * ExtraServoParam decSpeedIt.
             * @member {number} decSpeedIt
             * @memberof lebai.motor.ExtraServoParam
             * @instance
             */
            ExtraServoParam.prototype.decSpeedIt = 0;

            /**
             * Creates a new ExtraServoParam instance using the specified properties.
             * @function create
             * @memberof lebai.motor.ExtraServoParam
             * @static
             * @param {lebai.motor.IExtraServoParam=} [properties] Properties to set
             * @returns {lebai.motor.ExtraServoParam} ExtraServoParam instance
             */
            ExtraServoParam.create = function create(properties) {
                return new ExtraServoParam(properties);
            };

            /**
             * Encodes the specified ExtraServoParam message. Does not implicitly {@link lebai.motor.ExtraServoParam.verify|verify} messages.
             * @function encode
             * @memberof lebai.motor.ExtraServoParam
             * @static
             * @param {lebai.motor.IExtraServoParam} message ExtraServoParam message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExtraServoParam.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.accPositionKp != null && Object.hasOwnProperty.call(message, "accPositionKp"))
                    writer.uint32(/* id 1, wireType 1 =*/9).double(message.accPositionKp);
                if (message.accSpeedKp != null && Object.hasOwnProperty.call(message, "accSpeedKp"))
                    writer.uint32(/* id 2, wireType 1 =*/17).double(message.accSpeedKp);
                if (message.accSpeedIt != null && Object.hasOwnProperty.call(message, "accSpeedIt"))
                    writer.uint32(/* id 3, wireType 1 =*/25).double(message.accSpeedIt);
                if (message.uniPositionKp != null && Object.hasOwnProperty.call(message, "uniPositionKp"))
                    writer.uint32(/* id 4, wireType 1 =*/33).double(message.uniPositionKp);
                if (message.uniSpeedKp != null && Object.hasOwnProperty.call(message, "uniSpeedKp"))
                    writer.uint32(/* id 5, wireType 1 =*/41).double(message.uniSpeedKp);
                if (message.uniSpeedIt != null && Object.hasOwnProperty.call(message, "uniSpeedIt"))
                    writer.uint32(/* id 6, wireType 1 =*/49).double(message.uniSpeedIt);
                if (message.decPositionKp != null && Object.hasOwnProperty.call(message, "decPositionKp"))
                    writer.uint32(/* id 7, wireType 1 =*/57).double(message.decPositionKp);
                if (message.decSpeedKp != null && Object.hasOwnProperty.call(message, "decSpeedKp"))
                    writer.uint32(/* id 8, wireType 1 =*/65).double(message.decSpeedKp);
                if (message.decSpeedIt != null && Object.hasOwnProperty.call(message, "decSpeedIt"))
                    writer.uint32(/* id 9, wireType 1 =*/73).double(message.decSpeedIt);
                return writer;
            };

            /**
             * Encodes the specified ExtraServoParam message, length delimited. Does not implicitly {@link lebai.motor.ExtraServoParam.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.motor.ExtraServoParam
             * @static
             * @param {lebai.motor.IExtraServoParam} message ExtraServoParam message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExtraServoParam.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExtraServoParam message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.motor.ExtraServoParam
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.motor.ExtraServoParam} ExtraServoParam
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExtraServoParam.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.motor.ExtraServoParam();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.accPositionKp = reader.double();
                            break;
                        }
                    case 2: {
                            message.accSpeedKp = reader.double();
                            break;
                        }
                    case 3: {
                            message.accSpeedIt = reader.double();
                            break;
                        }
                    case 4: {
                            message.uniPositionKp = reader.double();
                            break;
                        }
                    case 5: {
                            message.uniSpeedKp = reader.double();
                            break;
                        }
                    case 6: {
                            message.uniSpeedIt = reader.double();
                            break;
                        }
                    case 7: {
                            message.decPositionKp = reader.double();
                            break;
                        }
                    case 8: {
                            message.decSpeedKp = reader.double();
                            break;
                        }
                    case 9: {
                            message.decSpeedIt = reader.double();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExtraServoParam message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.motor.ExtraServoParam
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.motor.ExtraServoParam} ExtraServoParam
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExtraServoParam.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExtraServoParam message.
             * @function verify
             * @memberof lebai.motor.ExtraServoParam
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExtraServoParam.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.accPositionKp != null && message.hasOwnProperty("accPositionKp"))
                    if (typeof message.accPositionKp !== "number")
                        return "accPositionKp: number expected";
                if (message.accSpeedKp != null && message.hasOwnProperty("accSpeedKp"))
                    if (typeof message.accSpeedKp !== "number")
                        return "accSpeedKp: number expected";
                if (message.accSpeedIt != null && message.hasOwnProperty("accSpeedIt"))
                    if (typeof message.accSpeedIt !== "number")
                        return "accSpeedIt: number expected";
                if (message.uniPositionKp != null && message.hasOwnProperty("uniPositionKp"))
                    if (typeof message.uniPositionKp !== "number")
                        return "uniPositionKp: number expected";
                if (message.uniSpeedKp != null && message.hasOwnProperty("uniSpeedKp"))
                    if (typeof message.uniSpeedKp !== "number")
                        return "uniSpeedKp: number expected";
                if (message.uniSpeedIt != null && message.hasOwnProperty("uniSpeedIt"))
                    if (typeof message.uniSpeedIt !== "number")
                        return "uniSpeedIt: number expected";
                if (message.decPositionKp != null && message.hasOwnProperty("decPositionKp"))
                    if (typeof message.decPositionKp !== "number")
                        return "decPositionKp: number expected";
                if (message.decSpeedKp != null && message.hasOwnProperty("decSpeedKp"))
                    if (typeof message.decSpeedKp !== "number")
                        return "decSpeedKp: number expected";
                if (message.decSpeedIt != null && message.hasOwnProperty("decSpeedIt"))
                    if (typeof message.decSpeedIt !== "number")
                        return "decSpeedIt: number expected";
                return null;
            };

            /**
             * Creates an ExtraServoParam message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.motor.ExtraServoParam
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.motor.ExtraServoParam} ExtraServoParam
             */
            ExtraServoParam.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.motor.ExtraServoParam)
                    return object;
                var message = new $root.lebai.motor.ExtraServoParam();
                if (object.accPositionKp != null)
                    message.accPositionKp = Number(object.accPositionKp);
                if (object.accSpeedKp != null)
                    message.accSpeedKp = Number(object.accSpeedKp);
                if (object.accSpeedIt != null)
                    message.accSpeedIt = Number(object.accSpeedIt);
                if (object.uniPositionKp != null)
                    message.uniPositionKp = Number(object.uniPositionKp);
                if (object.uniSpeedKp != null)
                    message.uniSpeedKp = Number(object.uniSpeedKp);
                if (object.uniSpeedIt != null)
                    message.uniSpeedIt = Number(object.uniSpeedIt);
                if (object.decPositionKp != null)
                    message.decPositionKp = Number(object.decPositionKp);
                if (object.decSpeedKp != null)
                    message.decSpeedKp = Number(object.decSpeedKp);
                if (object.decSpeedIt != null)
                    message.decSpeedIt = Number(object.decSpeedIt);
                return message;
            };

            /**
             * Creates a plain object from an ExtraServoParam message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.motor.ExtraServoParam
             * @static
             * @param {lebai.motor.ExtraServoParam} message ExtraServoParam
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExtraServoParam.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.accPositionKp = 0;
                    object.accSpeedKp = 0;
                    object.accSpeedIt = 0;
                    object.uniPositionKp = 0;
                    object.uniSpeedKp = 0;
                    object.uniSpeedIt = 0;
                    object.decPositionKp = 0;
                    object.decSpeedKp = 0;
                    object.decSpeedIt = 0;
                }
                if (message.accPositionKp != null && message.hasOwnProperty("accPositionKp"))
                    object.accPositionKp = options.json && !isFinite(message.accPositionKp) ? String(message.accPositionKp) : message.accPositionKp;
                if (message.accSpeedKp != null && message.hasOwnProperty("accSpeedKp"))
                    object.accSpeedKp = options.json && !isFinite(message.accSpeedKp) ? String(message.accSpeedKp) : message.accSpeedKp;
                if (message.accSpeedIt != null && message.hasOwnProperty("accSpeedIt"))
                    object.accSpeedIt = options.json && !isFinite(message.accSpeedIt) ? String(message.accSpeedIt) : message.accSpeedIt;
                if (message.uniPositionKp != null && message.hasOwnProperty("uniPositionKp"))
                    object.uniPositionKp = options.json && !isFinite(message.uniPositionKp) ? String(message.uniPositionKp) : message.uniPositionKp;
                if (message.uniSpeedKp != null && message.hasOwnProperty("uniSpeedKp"))
                    object.uniSpeedKp = options.json && !isFinite(message.uniSpeedKp) ? String(message.uniSpeedKp) : message.uniSpeedKp;
                if (message.uniSpeedIt != null && message.hasOwnProperty("uniSpeedIt"))
                    object.uniSpeedIt = options.json && !isFinite(message.uniSpeedIt) ? String(message.uniSpeedIt) : message.uniSpeedIt;
                if (message.decPositionKp != null && message.hasOwnProperty("decPositionKp"))
                    object.decPositionKp = options.json && !isFinite(message.decPositionKp) ? String(message.decPositionKp) : message.decPositionKp;
                if (message.decSpeedKp != null && message.hasOwnProperty("decSpeedKp"))
                    object.decSpeedKp = options.json && !isFinite(message.decSpeedKp) ? String(message.decSpeedKp) : message.decSpeedKp;
                if (message.decSpeedIt != null && message.hasOwnProperty("decSpeedIt"))
                    object.decSpeedIt = options.json && !isFinite(message.decSpeedIt) ? String(message.decSpeedIt) : message.decSpeedIt;
                return object;
            };

            /**
             * Converts this ExtraServoParam to JSON.
             * @function toJSON
             * @memberof lebai.motor.ExtraServoParam
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExtraServoParam.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ExtraServoParam
             * @function getTypeUrl
             * @memberof lebai.motor.ExtraServoParam
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ExtraServoParam.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.motor.ExtraServoParam";
            };

            return ExtraServoParam;
        })();

        motor.SetExtraServoParamsRequest = (function() {

            /**
             * Properties of a SetExtraServoParamsRequest.
             * @memberof lebai.motor
             * @interface ISetExtraServoParamsRequest
             * @property {Array.<lebai.motor.IExtraServoParam>|null} [params] SetExtraServoParamsRequest params
             * @property {Array.<boolean>|null} [valids] SetExtraServoParamsRequest valids
             */

            /**
             * Constructs a new SetExtraServoParamsRequest.
             * @memberof lebai.motor
             * @classdesc Represents a SetExtraServoParamsRequest.
             * @implements ISetExtraServoParamsRequest
             * @constructor
             * @param {lebai.motor.ISetExtraServoParamsRequest=} [properties] Properties to set
             */
            function SetExtraServoParamsRequest(properties) {
                this.params = [];
                this.valids = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SetExtraServoParamsRequest params.
             * @member {Array.<lebai.motor.IExtraServoParam>} params
             * @memberof lebai.motor.SetExtraServoParamsRequest
             * @instance
             */
            SetExtraServoParamsRequest.prototype.params = $util.emptyArray;

            /**
             * SetExtraServoParamsRequest valids.
             * @member {Array.<boolean>} valids
             * @memberof lebai.motor.SetExtraServoParamsRequest
             * @instance
             */
            SetExtraServoParamsRequest.prototype.valids = $util.emptyArray;

            /**
             * Creates a new SetExtraServoParamsRequest instance using the specified properties.
             * @function create
             * @memberof lebai.motor.SetExtraServoParamsRequest
             * @static
             * @param {lebai.motor.ISetExtraServoParamsRequest=} [properties] Properties to set
             * @returns {lebai.motor.SetExtraServoParamsRequest} SetExtraServoParamsRequest instance
             */
            SetExtraServoParamsRequest.create = function create(properties) {
                return new SetExtraServoParamsRequest(properties);
            };

            /**
             * Encodes the specified SetExtraServoParamsRequest message. Does not implicitly {@link lebai.motor.SetExtraServoParamsRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.motor.SetExtraServoParamsRequest
             * @static
             * @param {lebai.motor.ISetExtraServoParamsRequest} message SetExtraServoParamsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetExtraServoParamsRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.params != null && message.params.length)
                    for (var i = 0; i < message.params.length; ++i)
                        $root.lebai.motor.ExtraServoParam.encode(message.params[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.valids != null && message.valids.length) {
                    writer.uint32(/* id 2, wireType 2 =*/18).fork();
                    for (var i = 0; i < message.valids.length; ++i)
                        writer.bool(message.valids[i]);
                    writer.ldelim();
                }
                return writer;
            };

            /**
             * Encodes the specified SetExtraServoParamsRequest message, length delimited. Does not implicitly {@link lebai.motor.SetExtraServoParamsRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.motor.SetExtraServoParamsRequest
             * @static
             * @param {lebai.motor.ISetExtraServoParamsRequest} message SetExtraServoParamsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetExtraServoParamsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetExtraServoParamsRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.motor.SetExtraServoParamsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.motor.SetExtraServoParamsRequest} SetExtraServoParamsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetExtraServoParamsRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.motor.SetExtraServoParamsRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.params && message.params.length))
                                message.params = [];
                            message.params.push($root.lebai.motor.ExtraServoParam.decode(reader, reader.uint32()));
                            break;
                        }
                    case 2: {
                            if (!(message.valids && message.valids.length))
                                message.valids = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.valids.push(reader.bool());
                            } else
                                message.valids.push(reader.bool());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetExtraServoParamsRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.motor.SetExtraServoParamsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.motor.SetExtraServoParamsRequest} SetExtraServoParamsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetExtraServoParamsRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetExtraServoParamsRequest message.
             * @function verify
             * @memberof lebai.motor.SetExtraServoParamsRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetExtraServoParamsRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.params != null && message.hasOwnProperty("params")) {
                    if (!Array.isArray(message.params))
                        return "params: array expected";
                    for (var i = 0; i < message.params.length; ++i) {
                        var error = $root.lebai.motor.ExtraServoParam.verify(message.params[i]);
                        if (error)
                            return "params." + error;
                    }
                }
                if (message.valids != null && message.hasOwnProperty("valids")) {
                    if (!Array.isArray(message.valids))
                        return "valids: array expected";
                    for (var i = 0; i < message.valids.length; ++i)
                        if (typeof message.valids[i] !== "boolean")
                            return "valids: boolean[] expected";
                }
                return null;
            };

            /**
             * Creates a SetExtraServoParamsRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.motor.SetExtraServoParamsRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.motor.SetExtraServoParamsRequest} SetExtraServoParamsRequest
             */
            SetExtraServoParamsRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.motor.SetExtraServoParamsRequest)
                    return object;
                var message = new $root.lebai.motor.SetExtraServoParamsRequest();
                if (object.params) {
                    if (!Array.isArray(object.params))
                        throw TypeError(".lebai.motor.SetExtraServoParamsRequest.params: array expected");
                    message.params = [];
                    for (var i = 0; i < object.params.length; ++i) {
                        if (typeof object.params[i] !== "object")
                            throw TypeError(".lebai.motor.SetExtraServoParamsRequest.params: object expected");
                        message.params[i] = $root.lebai.motor.ExtraServoParam.fromObject(object.params[i]);
                    }
                }
                if (object.valids) {
                    if (!Array.isArray(object.valids))
                        throw TypeError(".lebai.motor.SetExtraServoParamsRequest.valids: array expected");
                    message.valids = [];
                    for (var i = 0; i < object.valids.length; ++i)
                        message.valids[i] = Boolean(object.valids[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a SetExtraServoParamsRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.motor.SetExtraServoParamsRequest
             * @static
             * @param {lebai.motor.SetExtraServoParamsRequest} message SetExtraServoParamsRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetExtraServoParamsRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.params = [];
                    object.valids = [];
                }
                if (message.params && message.params.length) {
                    object.params = [];
                    for (var j = 0; j < message.params.length; ++j)
                        object.params[j] = $root.lebai.motor.ExtraServoParam.toObject(message.params[j], options);
                }
                if (message.valids && message.valids.length) {
                    object.valids = [];
                    for (var j = 0; j < message.valids.length; ++j)
                        object.valids[j] = message.valids[j];
                }
                return object;
            };

            /**
             * Converts this SetExtraServoParamsRequest to JSON.
             * @function toJSON
             * @memberof lebai.motor.SetExtraServoParamsRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetExtraServoParamsRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetExtraServoParamsRequest
             * @function getTypeUrl
             * @memberof lebai.motor.SetExtraServoParamsRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetExtraServoParamsRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.motor.SetExtraServoParamsRequest";
            };

            return SetExtraServoParamsRequest;
        })();

        motor.ResetExtraServoParamsRequest = (function() {

            /**
             * Properties of a ResetExtraServoParamsRequest.
             * @memberof lebai.motor
             * @interface IResetExtraServoParamsRequest
             * @property {Array.<boolean>|null} [valids] ResetExtraServoParamsRequest valids
             */

            /**
             * Constructs a new ResetExtraServoParamsRequest.
             * @memberof lebai.motor
             * @classdesc Represents a ResetExtraServoParamsRequest.
             * @implements IResetExtraServoParamsRequest
             * @constructor
             * @param {lebai.motor.IResetExtraServoParamsRequest=} [properties] Properties to set
             */
            function ResetExtraServoParamsRequest(properties) {
                this.valids = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ResetExtraServoParamsRequest valids.
             * @member {Array.<boolean>} valids
             * @memberof lebai.motor.ResetExtraServoParamsRequest
             * @instance
             */
            ResetExtraServoParamsRequest.prototype.valids = $util.emptyArray;

            /**
             * Creates a new ResetExtraServoParamsRequest instance using the specified properties.
             * @function create
             * @memberof lebai.motor.ResetExtraServoParamsRequest
             * @static
             * @param {lebai.motor.IResetExtraServoParamsRequest=} [properties] Properties to set
             * @returns {lebai.motor.ResetExtraServoParamsRequest} ResetExtraServoParamsRequest instance
             */
            ResetExtraServoParamsRequest.create = function create(properties) {
                return new ResetExtraServoParamsRequest(properties);
            };

            /**
             * Encodes the specified ResetExtraServoParamsRequest message. Does not implicitly {@link lebai.motor.ResetExtraServoParamsRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.motor.ResetExtraServoParamsRequest
             * @static
             * @param {lebai.motor.IResetExtraServoParamsRequest} message ResetExtraServoParamsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ResetExtraServoParamsRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.valids != null && message.valids.length) {
                    writer.uint32(/* id 1, wireType 2 =*/10).fork();
                    for (var i = 0; i < message.valids.length; ++i)
                        writer.bool(message.valids[i]);
                    writer.ldelim();
                }
                return writer;
            };

            /**
             * Encodes the specified ResetExtraServoParamsRequest message, length delimited. Does not implicitly {@link lebai.motor.ResetExtraServoParamsRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.motor.ResetExtraServoParamsRequest
             * @static
             * @param {lebai.motor.IResetExtraServoParamsRequest} message ResetExtraServoParamsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ResetExtraServoParamsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ResetExtraServoParamsRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.motor.ResetExtraServoParamsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.motor.ResetExtraServoParamsRequest} ResetExtraServoParamsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ResetExtraServoParamsRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.motor.ResetExtraServoParamsRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.valids && message.valids.length))
                                message.valids = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.valids.push(reader.bool());
                            } else
                                message.valids.push(reader.bool());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ResetExtraServoParamsRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.motor.ResetExtraServoParamsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.motor.ResetExtraServoParamsRequest} ResetExtraServoParamsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ResetExtraServoParamsRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ResetExtraServoParamsRequest message.
             * @function verify
             * @memberof lebai.motor.ResetExtraServoParamsRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ResetExtraServoParamsRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.valids != null && message.hasOwnProperty("valids")) {
                    if (!Array.isArray(message.valids))
                        return "valids: array expected";
                    for (var i = 0; i < message.valids.length; ++i)
                        if (typeof message.valids[i] !== "boolean")
                            return "valids: boolean[] expected";
                }
                return null;
            };

            /**
             * Creates a ResetExtraServoParamsRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.motor.ResetExtraServoParamsRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.motor.ResetExtraServoParamsRequest} ResetExtraServoParamsRequest
             */
            ResetExtraServoParamsRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.motor.ResetExtraServoParamsRequest)
                    return object;
                var message = new $root.lebai.motor.ResetExtraServoParamsRequest();
                if (object.valids) {
                    if (!Array.isArray(object.valids))
                        throw TypeError(".lebai.motor.ResetExtraServoParamsRequest.valids: array expected");
                    message.valids = [];
                    for (var i = 0; i < object.valids.length; ++i)
                        message.valids[i] = Boolean(object.valids[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a ResetExtraServoParamsRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.motor.ResetExtraServoParamsRequest
             * @static
             * @param {lebai.motor.ResetExtraServoParamsRequest} message ResetExtraServoParamsRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ResetExtraServoParamsRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.valids = [];
                if (message.valids && message.valids.length) {
                    object.valids = [];
                    for (var j = 0; j < message.valids.length; ++j)
                        object.valids[j] = message.valids[j];
                }
                return object;
            };

            /**
             * Converts this ResetExtraServoParamsRequest to JSON.
             * @function toJSON
             * @memberof lebai.motor.ResetExtraServoParamsRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ResetExtraServoParamsRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ResetExtraServoParamsRequest
             * @function getTypeUrl
             * @memberof lebai.motor.ResetExtraServoParamsRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ResetExtraServoParamsRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.motor.ResetExtraServoParamsRequest";
            };

            return ResetExtraServoParamsRequest;
        })();

        motor.MotorService = (function() {

            /**
             * Constructs a new MotorService service.
             * @memberof lebai.motor
             * @classdesc Represents a MotorService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function MotorService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (MotorService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = MotorService;

            /**
             * Creates new MotorService service using the specified rpc implementation.
             * @function create
             * @memberof lebai.motor.MotorService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {MotorService} RPC service. Useful where requests and/or responses are streamed.
             */
            MotorService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link lebai.motor.MotorService#setServoParams}.
             * @memberof lebai.motor.MotorService
             * @typedef SetServoParamsCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls SetServoParams.
             * @function setServoParams
             * @memberof lebai.motor.MotorService
             * @instance
             * @param {lebai.motor.IServoParams} request ServoParams message or plain object
             * @param {lebai.motor.MotorService.SetServoParamsCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MotorService.prototype.setServoParams = function setServoParams(request, callback) {
                return this.rpcCall(setServoParams, $root.lebai.motor.ServoParams, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "SetServoParams" });

            /**
             * Calls SetServoParams.
             * @function setServoParams
             * @memberof lebai.motor.MotorService
             * @instance
             * @param {lebai.motor.IServoParams} request ServoParams message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.motor.MotorService#getServoParams}.
             * @memberof lebai.motor.MotorService
             * @typedef GetServoParamsCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.motor.ServoParams} [response] ServoParams
             */

            /**
             * Calls GetServoParams.
             * @function getServoParams
             * @memberof lebai.motor.MotorService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {lebai.motor.MotorService.GetServoParamsCallback} callback Node-style callback called with the error, if any, and ServoParams
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MotorService.prototype.getServoParams = function getServoParams(request, callback) {
                return this.rpcCall(getServoParams, $root.google.protobuf.Empty, $root.lebai.motor.ServoParams, request, callback);
            }, "name", { value: "GetServoParams" });

            /**
             * Calls GetServoParams.
             * @function getServoParams
             * @memberof lebai.motor.MotorService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<lebai.motor.ServoParams>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.motor.MotorService#setZero}.
             * @memberof lebai.motor.MotorService
             * @typedef SetZeroCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls SetZero.
             * @function setZero
             * @memberof lebai.motor.MotorService
             * @instance
             * @param {lebai.motor.ISetZeroRequest} request SetZeroRequest message or plain object
             * @param {lebai.motor.MotorService.SetZeroCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MotorService.prototype.setZero = function setZero(request, callback) {
                return this.rpcCall(setZero, $root.lebai.motor.SetZeroRequest, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "SetZero" });

            /**
             * Calls SetZero.
             * @function setZero
             * @memberof lebai.motor.MotorService
             * @instance
             * @param {lebai.motor.ISetZeroRequest} request SetZeroRequest message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.motor.MotorService#setExtraServoParams}.
             * @memberof lebai.motor.MotorService
             * @typedef SetExtraServoParamsCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls SetExtraServoParams.
             * @function setExtraServoParams
             * @memberof lebai.motor.MotorService
             * @instance
             * @param {lebai.motor.ISetExtraServoParamsRequest} request SetExtraServoParamsRequest message or plain object
             * @param {lebai.motor.MotorService.SetExtraServoParamsCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MotorService.prototype.setExtraServoParams = function setExtraServoParams(request, callback) {
                return this.rpcCall(setExtraServoParams, $root.lebai.motor.SetExtraServoParamsRequest, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "SetExtraServoParams" });

            /**
             * Calls SetExtraServoParams.
             * @function setExtraServoParams
             * @memberof lebai.motor.MotorService
             * @instance
             * @param {lebai.motor.ISetExtraServoParamsRequest} request SetExtraServoParamsRequest message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.motor.MotorService#resetExtraServoParams}.
             * @memberof lebai.motor.MotorService
             * @typedef ResetExtraServoParamsCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls ResetExtraServoParams.
             * @function resetExtraServoParams
             * @memberof lebai.motor.MotorService
             * @instance
             * @param {lebai.motor.IResetExtraServoParamsRequest} request ResetExtraServoParamsRequest message or plain object
             * @param {lebai.motor.MotorService.ResetExtraServoParamsCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MotorService.prototype.resetExtraServoParams = function resetExtraServoParams(request, callback) {
                return this.rpcCall(resetExtraServoParams, $root.lebai.motor.ResetExtraServoParamsRequest, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "ResetExtraServoParams" });

            /**
             * Calls ResetExtraServoParams.
             * @function resetExtraServoParams
             * @memberof lebai.motor.MotorService
             * @instance
             * @param {lebai.motor.IResetExtraServoParamsRequest} request ResetExtraServoParamsRequest message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            return MotorService;
        })();

        return motor;
    })();

    lebai.multi_devices = (function() {

        /**
         * Namespace multi_devices.
         * @memberof lebai
         * @namespace
         */
        var multi_devices = {};

        multi_devices.DeviceInfo = (function() {

            /**
             * Properties of a DeviceInfo.
             * @memberof lebai.multi_devices
             * @interface IDeviceInfo
             * @property {string|null} [name] DeviceInfo name
             * @property {string|null} [mac] DeviceInfo mac
             * @property {string|null} [ip] DeviceInfo ip
             * @property {boolean|null} [online] DeviceInfo online
             */

            /**
             * Constructs a new DeviceInfo.
             * @memberof lebai.multi_devices
             * @classdesc Represents a DeviceInfo.
             * @implements IDeviceInfo
             * @constructor
             * @param {lebai.multi_devices.IDeviceInfo=} [properties] Properties to set
             */
            function DeviceInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DeviceInfo name.
             * @member {string} name
             * @memberof lebai.multi_devices.DeviceInfo
             * @instance
             */
            DeviceInfo.prototype.name = "";

            /**
             * DeviceInfo mac.
             * @member {string} mac
             * @memberof lebai.multi_devices.DeviceInfo
             * @instance
             */
            DeviceInfo.prototype.mac = "";

            /**
             * DeviceInfo ip.
             * @member {string} ip
             * @memberof lebai.multi_devices.DeviceInfo
             * @instance
             */
            DeviceInfo.prototype.ip = "";

            /**
             * DeviceInfo online.
             * @member {boolean} online
             * @memberof lebai.multi_devices.DeviceInfo
             * @instance
             */
            DeviceInfo.prototype.online = false;

            /**
             * Creates a new DeviceInfo instance using the specified properties.
             * @function create
             * @memberof lebai.multi_devices.DeviceInfo
             * @static
             * @param {lebai.multi_devices.IDeviceInfo=} [properties] Properties to set
             * @returns {lebai.multi_devices.DeviceInfo} DeviceInfo instance
             */
            DeviceInfo.create = function create(properties) {
                return new DeviceInfo(properties);
            };

            /**
             * Encodes the specified DeviceInfo message. Does not implicitly {@link lebai.multi_devices.DeviceInfo.verify|verify} messages.
             * @function encode
             * @memberof lebai.multi_devices.DeviceInfo
             * @static
             * @param {lebai.multi_devices.IDeviceInfo} message DeviceInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeviceInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.mac != null && Object.hasOwnProperty.call(message, "mac"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.mac);
                if (message.ip != null && Object.hasOwnProperty.call(message, "ip"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.ip);
                if (message.online != null && Object.hasOwnProperty.call(message, "online"))
                    writer.uint32(/* id 11, wireType 0 =*/88).bool(message.online);
                return writer;
            };

            /**
             * Encodes the specified DeviceInfo message, length delimited. Does not implicitly {@link lebai.multi_devices.DeviceInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.multi_devices.DeviceInfo
             * @static
             * @param {lebai.multi_devices.IDeviceInfo} message DeviceInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeviceInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeviceInfo message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.multi_devices.DeviceInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.multi_devices.DeviceInfo} DeviceInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeviceInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.multi_devices.DeviceInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.name = reader.string();
                            break;
                        }
                    case 2: {
                            message.mac = reader.string();
                            break;
                        }
                    case 3: {
                            message.ip = reader.string();
                            break;
                        }
                    case 11: {
                            message.online = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeviceInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.multi_devices.DeviceInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.multi_devices.DeviceInfo} DeviceInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeviceInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeviceInfo message.
             * @function verify
             * @memberof lebai.multi_devices.DeviceInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeviceInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.mac != null && message.hasOwnProperty("mac"))
                    if (!$util.isString(message.mac))
                        return "mac: string expected";
                if (message.ip != null && message.hasOwnProperty("ip"))
                    if (!$util.isString(message.ip))
                        return "ip: string expected";
                if (message.online != null && message.hasOwnProperty("online"))
                    if (typeof message.online !== "boolean")
                        return "online: boolean expected";
                return null;
            };

            /**
             * Creates a DeviceInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.multi_devices.DeviceInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.multi_devices.DeviceInfo} DeviceInfo
             */
            DeviceInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.multi_devices.DeviceInfo)
                    return object;
                var message = new $root.lebai.multi_devices.DeviceInfo();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.mac != null)
                    message.mac = String(object.mac);
                if (object.ip != null)
                    message.ip = String(object.ip);
                if (object.online != null)
                    message.online = Boolean(object.online);
                return message;
            };

            /**
             * Creates a plain object from a DeviceInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.multi_devices.DeviceInfo
             * @static
             * @param {lebai.multi_devices.DeviceInfo} message DeviceInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeviceInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.mac = "";
                    object.ip = "";
                    object.online = false;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.mac != null && message.hasOwnProperty("mac"))
                    object.mac = message.mac;
                if (message.ip != null && message.hasOwnProperty("ip"))
                    object.ip = message.ip;
                if (message.online != null && message.hasOwnProperty("online"))
                    object.online = message.online;
                return object;
            };

            /**
             * Converts this DeviceInfo to JSON.
             * @function toJSON
             * @memberof lebai.multi_devices.DeviceInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeviceInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DeviceInfo
             * @function getTypeUrl
             * @memberof lebai.multi_devices.DeviceInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DeviceInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.multi_devices.DeviceInfo";
            };

            return DeviceInfo;
        })();

        multi_devices.DiscoverRobotsResponse = (function() {

            /**
             * Properties of a DiscoverRobotsResponse.
             * @memberof lebai.multi_devices
             * @interface IDiscoverRobotsResponse
             * @property {Array.<lebai.multi_devices.IDeviceInfo>|null} [devices] DiscoverRobotsResponse devices
             */

            /**
             * Constructs a new DiscoverRobotsResponse.
             * @memberof lebai.multi_devices
             * @classdesc Represents a DiscoverRobotsResponse.
             * @implements IDiscoverRobotsResponse
             * @constructor
             * @param {lebai.multi_devices.IDiscoverRobotsResponse=} [properties] Properties to set
             */
            function DiscoverRobotsResponse(properties) {
                this.devices = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DiscoverRobotsResponse devices.
             * @member {Array.<lebai.multi_devices.IDeviceInfo>} devices
             * @memberof lebai.multi_devices.DiscoverRobotsResponse
             * @instance
             */
            DiscoverRobotsResponse.prototype.devices = $util.emptyArray;

            /**
             * Creates a new DiscoverRobotsResponse instance using the specified properties.
             * @function create
             * @memberof lebai.multi_devices.DiscoverRobotsResponse
             * @static
             * @param {lebai.multi_devices.IDiscoverRobotsResponse=} [properties] Properties to set
             * @returns {lebai.multi_devices.DiscoverRobotsResponse} DiscoverRobotsResponse instance
             */
            DiscoverRobotsResponse.create = function create(properties) {
                return new DiscoverRobotsResponse(properties);
            };

            /**
             * Encodes the specified DiscoverRobotsResponse message. Does not implicitly {@link lebai.multi_devices.DiscoverRobotsResponse.verify|verify} messages.
             * @function encode
             * @memberof lebai.multi_devices.DiscoverRobotsResponse
             * @static
             * @param {lebai.multi_devices.IDiscoverRobotsResponse} message DiscoverRobotsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DiscoverRobotsResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.devices != null && message.devices.length)
                    for (var i = 0; i < message.devices.length; ++i)
                        $root.lebai.multi_devices.DeviceInfo.encode(message.devices[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DiscoverRobotsResponse message, length delimited. Does not implicitly {@link lebai.multi_devices.DiscoverRobotsResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.multi_devices.DiscoverRobotsResponse
             * @static
             * @param {lebai.multi_devices.IDiscoverRobotsResponse} message DiscoverRobotsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DiscoverRobotsResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DiscoverRobotsResponse message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.multi_devices.DiscoverRobotsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.multi_devices.DiscoverRobotsResponse} DiscoverRobotsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DiscoverRobotsResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.multi_devices.DiscoverRobotsResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.devices && message.devices.length))
                                message.devices = [];
                            message.devices.push($root.lebai.multi_devices.DeviceInfo.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DiscoverRobotsResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.multi_devices.DiscoverRobotsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.multi_devices.DiscoverRobotsResponse} DiscoverRobotsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DiscoverRobotsResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DiscoverRobotsResponse message.
             * @function verify
             * @memberof lebai.multi_devices.DiscoverRobotsResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DiscoverRobotsResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.devices != null && message.hasOwnProperty("devices")) {
                    if (!Array.isArray(message.devices))
                        return "devices: array expected";
                    for (var i = 0; i < message.devices.length; ++i) {
                        var error = $root.lebai.multi_devices.DeviceInfo.verify(message.devices[i]);
                        if (error)
                            return "devices." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a DiscoverRobotsResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.multi_devices.DiscoverRobotsResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.multi_devices.DiscoverRobotsResponse} DiscoverRobotsResponse
             */
            DiscoverRobotsResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.multi_devices.DiscoverRobotsResponse)
                    return object;
                var message = new $root.lebai.multi_devices.DiscoverRobotsResponse();
                if (object.devices) {
                    if (!Array.isArray(object.devices))
                        throw TypeError(".lebai.multi_devices.DiscoverRobotsResponse.devices: array expected");
                    message.devices = [];
                    for (var i = 0; i < object.devices.length; ++i) {
                        if (typeof object.devices[i] !== "object")
                            throw TypeError(".lebai.multi_devices.DiscoverRobotsResponse.devices: object expected");
                        message.devices[i] = $root.lebai.multi_devices.DeviceInfo.fromObject(object.devices[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a DiscoverRobotsResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.multi_devices.DiscoverRobotsResponse
             * @static
             * @param {lebai.multi_devices.DiscoverRobotsResponse} message DiscoverRobotsResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DiscoverRobotsResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.devices = [];
                if (message.devices && message.devices.length) {
                    object.devices = [];
                    for (var j = 0; j < message.devices.length; ++j)
                        object.devices[j] = $root.lebai.multi_devices.DeviceInfo.toObject(message.devices[j], options);
                }
                return object;
            };

            /**
             * Converts this DiscoverRobotsResponse to JSON.
             * @function toJSON
             * @memberof lebai.multi_devices.DiscoverRobotsResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DiscoverRobotsResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DiscoverRobotsResponse
             * @function getTypeUrl
             * @memberof lebai.multi_devices.DiscoverRobotsResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DiscoverRobotsResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.multi_devices.DiscoverRobotsResponse";
            };

            return DiscoverRobotsResponse;
        })();

        multi_devices.MultiDevicesService = (function() {

            /**
             * Constructs a new MultiDevicesService service.
             * @memberof lebai.multi_devices
             * @classdesc Represents a MultiDevicesService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function MultiDevicesService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (MultiDevicesService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = MultiDevicesService;

            /**
             * Creates new MultiDevicesService service using the specified rpc implementation.
             * @function create
             * @memberof lebai.multi_devices.MultiDevicesService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {MultiDevicesService} RPC service. Useful where requests and/or responses are streamed.
             */
            MultiDevicesService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link lebai.multi_devices.MultiDevicesService#discoverRobots}.
             * @memberof lebai.multi_devices.MultiDevicesService
             * @typedef DiscoverRobotsCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.multi_devices.DiscoverRobotsResponse} [response] DiscoverRobotsResponse
             */

            /**
             * Calls DiscoverRobots.
             * @function discoverRobots
             * @memberof lebai.multi_devices.MultiDevicesService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {lebai.multi_devices.MultiDevicesService.DiscoverRobotsCallback} callback Node-style callback called with the error, if any, and DiscoverRobotsResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MultiDevicesService.prototype.discoverRobots = function discoverRobots(request, callback) {
                return this.rpcCall(discoverRobots, $root.google.protobuf.Empty, $root.lebai.multi_devices.DiscoverRobotsResponse, request, callback);
            }, "name", { value: "DiscoverRobots" });

            /**
             * Calls DiscoverRobots.
             * @function discoverRobots
             * @memberof lebai.multi_devices.MultiDevicesService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<lebai.multi_devices.DiscoverRobotsResponse>} Promise
             * @variation 2
             */

            return MultiDevicesService;
        })();

        return multi_devices;
    })();

    lebai.plugin = (function() {

        /**
         * Namespace plugin.
         * @memberof lebai
         * @namespace
         */
        var plugin = {};

        plugin.PluginInfo = (function() {

            /**
             * Properties of a PluginInfo.
             * @memberof lebai.plugin
             * @interface IPluginInfo
             * @property {string|null} [name] PluginInfo name
             * @property {string|null} [description] PluginInfo description
             * @property {string|null} [homepage] PluginInfo homepage
             * @property {boolean|null} [web] PluginInfo web
             * @property {boolean|null} [daemon] PluginInfo daemon
             * @property {boolean|null} [cmd] PluginInfo cmd
             * @property {boolean|null} [enable] PluginInfo enable
             */

            /**
             * Constructs a new PluginInfo.
             * @memberof lebai.plugin
             * @classdesc Represents a PluginInfo.
             * @implements IPluginInfo
             * @constructor
             * @param {lebai.plugin.IPluginInfo=} [properties] Properties to set
             */
            function PluginInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PluginInfo name.
             * @member {string} name
             * @memberof lebai.plugin.PluginInfo
             * @instance
             */
            PluginInfo.prototype.name = "";

            /**
             * PluginInfo description.
             * @member {string} description
             * @memberof lebai.plugin.PluginInfo
             * @instance
             */
            PluginInfo.prototype.description = "";

            /**
             * PluginInfo homepage.
             * @member {string} homepage
             * @memberof lebai.plugin.PluginInfo
             * @instance
             */
            PluginInfo.prototype.homepage = "";

            /**
             * PluginInfo web.
             * @member {boolean} web
             * @memberof lebai.plugin.PluginInfo
             * @instance
             */
            PluginInfo.prototype.web = false;

            /**
             * PluginInfo daemon.
             * @member {boolean} daemon
             * @memberof lebai.plugin.PluginInfo
             * @instance
             */
            PluginInfo.prototype.daemon = false;

            /**
             * PluginInfo cmd.
             * @member {boolean} cmd
             * @memberof lebai.plugin.PluginInfo
             * @instance
             */
            PluginInfo.prototype.cmd = false;

            /**
             * PluginInfo enable.
             * @member {boolean} enable
             * @memberof lebai.plugin.PluginInfo
             * @instance
             */
            PluginInfo.prototype.enable = false;

            /**
             * Creates a new PluginInfo instance using the specified properties.
             * @function create
             * @memberof lebai.plugin.PluginInfo
             * @static
             * @param {lebai.plugin.IPluginInfo=} [properties] Properties to set
             * @returns {lebai.plugin.PluginInfo} PluginInfo instance
             */
            PluginInfo.create = function create(properties) {
                return new PluginInfo(properties);
            };

            /**
             * Encodes the specified PluginInfo message. Does not implicitly {@link lebai.plugin.PluginInfo.verify|verify} messages.
             * @function encode
             * @memberof lebai.plugin.PluginInfo
             * @static
             * @param {lebai.plugin.IPluginInfo} message PluginInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PluginInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.description);
                if (message.homepage != null && Object.hasOwnProperty.call(message, "homepage"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.homepage);
                if (message.web != null && Object.hasOwnProperty.call(message, "web"))
                    writer.uint32(/* id 12, wireType 0 =*/96).bool(message.web);
                if (message.daemon != null && Object.hasOwnProperty.call(message, "daemon"))
                    writer.uint32(/* id 13, wireType 0 =*/104).bool(message.daemon);
                if (message.cmd != null && Object.hasOwnProperty.call(message, "cmd"))
                    writer.uint32(/* id 14, wireType 0 =*/112).bool(message.cmd);
                if (message.enable != null && Object.hasOwnProperty.call(message, "enable"))
                    writer.uint32(/* id 91, wireType 0 =*/728).bool(message.enable);
                return writer;
            };

            /**
             * Encodes the specified PluginInfo message, length delimited. Does not implicitly {@link lebai.plugin.PluginInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.plugin.PluginInfo
             * @static
             * @param {lebai.plugin.IPluginInfo} message PluginInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PluginInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PluginInfo message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.plugin.PluginInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.plugin.PluginInfo} PluginInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PluginInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.plugin.PluginInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.name = reader.string();
                            break;
                        }
                    case 6: {
                            message.description = reader.string();
                            break;
                        }
                    case 7: {
                            message.homepage = reader.string();
                            break;
                        }
                    case 12: {
                            message.web = reader.bool();
                            break;
                        }
                    case 13: {
                            message.daemon = reader.bool();
                            break;
                        }
                    case 14: {
                            message.cmd = reader.bool();
                            break;
                        }
                    case 91: {
                            message.enable = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PluginInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.plugin.PluginInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.plugin.PluginInfo} PluginInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PluginInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PluginInfo message.
             * @function verify
             * @memberof lebai.plugin.PluginInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PluginInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.description != null && message.hasOwnProperty("description"))
                    if (!$util.isString(message.description))
                        return "description: string expected";
                if (message.homepage != null && message.hasOwnProperty("homepage"))
                    if (!$util.isString(message.homepage))
                        return "homepage: string expected";
                if (message.web != null && message.hasOwnProperty("web"))
                    if (typeof message.web !== "boolean")
                        return "web: boolean expected";
                if (message.daemon != null && message.hasOwnProperty("daemon"))
                    if (typeof message.daemon !== "boolean")
                        return "daemon: boolean expected";
                if (message.cmd != null && message.hasOwnProperty("cmd"))
                    if (typeof message.cmd !== "boolean")
                        return "cmd: boolean expected";
                if (message.enable != null && message.hasOwnProperty("enable"))
                    if (typeof message.enable !== "boolean")
                        return "enable: boolean expected";
                return null;
            };

            /**
             * Creates a PluginInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.plugin.PluginInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.plugin.PluginInfo} PluginInfo
             */
            PluginInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.plugin.PluginInfo)
                    return object;
                var message = new $root.lebai.plugin.PluginInfo();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.description != null)
                    message.description = String(object.description);
                if (object.homepage != null)
                    message.homepage = String(object.homepage);
                if (object.web != null)
                    message.web = Boolean(object.web);
                if (object.daemon != null)
                    message.daemon = Boolean(object.daemon);
                if (object.cmd != null)
                    message.cmd = Boolean(object.cmd);
                if (object.enable != null)
                    message.enable = Boolean(object.enable);
                return message;
            };

            /**
             * Creates a plain object from a PluginInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.plugin.PluginInfo
             * @static
             * @param {lebai.plugin.PluginInfo} message PluginInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PluginInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.description = "";
                    object.homepage = "";
                    object.web = false;
                    object.daemon = false;
                    object.cmd = false;
                    object.enable = false;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.description != null && message.hasOwnProperty("description"))
                    object.description = message.description;
                if (message.homepage != null && message.hasOwnProperty("homepage"))
                    object.homepage = message.homepage;
                if (message.web != null && message.hasOwnProperty("web"))
                    object.web = message.web;
                if (message.daemon != null && message.hasOwnProperty("daemon"))
                    object.daemon = message.daemon;
                if (message.cmd != null && message.hasOwnProperty("cmd"))
                    object.cmd = message.cmd;
                if (message.enable != null && message.hasOwnProperty("enable"))
                    object.enable = message.enable;
                return object;
            };

            /**
             * Converts this PluginInfo to JSON.
             * @function toJSON
             * @memberof lebai.plugin.PluginInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PluginInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for PluginInfo
             * @function getTypeUrl
             * @memberof lebai.plugin.PluginInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            PluginInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.plugin.PluginInfo";
            };

            return PluginInfo;
        })();

        plugin.PluginIndex = (function() {

            /**
             * Properties of a PluginIndex.
             * @memberof lebai.plugin
             * @interface IPluginIndex
             * @property {string|null} [name] PluginIndex name
             */

            /**
             * Constructs a new PluginIndex.
             * @memberof lebai.plugin
             * @classdesc Represents a PluginIndex.
             * @implements IPluginIndex
             * @constructor
             * @param {lebai.plugin.IPluginIndex=} [properties] Properties to set
             */
            function PluginIndex(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PluginIndex name.
             * @member {string} name
             * @memberof lebai.plugin.PluginIndex
             * @instance
             */
            PluginIndex.prototype.name = "";

            /**
             * Creates a new PluginIndex instance using the specified properties.
             * @function create
             * @memberof lebai.plugin.PluginIndex
             * @static
             * @param {lebai.plugin.IPluginIndex=} [properties] Properties to set
             * @returns {lebai.plugin.PluginIndex} PluginIndex instance
             */
            PluginIndex.create = function create(properties) {
                return new PluginIndex(properties);
            };

            /**
             * Encodes the specified PluginIndex message. Does not implicitly {@link lebai.plugin.PluginIndex.verify|verify} messages.
             * @function encode
             * @memberof lebai.plugin.PluginIndex
             * @static
             * @param {lebai.plugin.IPluginIndex} message PluginIndex message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PluginIndex.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                return writer;
            };

            /**
             * Encodes the specified PluginIndex message, length delimited. Does not implicitly {@link lebai.plugin.PluginIndex.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.plugin.PluginIndex
             * @static
             * @param {lebai.plugin.IPluginIndex} message PluginIndex message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PluginIndex.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PluginIndex message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.plugin.PluginIndex
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.plugin.PluginIndex} PluginIndex
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PluginIndex.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.plugin.PluginIndex();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.name = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PluginIndex message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.plugin.PluginIndex
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.plugin.PluginIndex} PluginIndex
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PluginIndex.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PluginIndex message.
             * @function verify
             * @memberof lebai.plugin.PluginIndex
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PluginIndex.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                return null;
            };

            /**
             * Creates a PluginIndex message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.plugin.PluginIndex
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.plugin.PluginIndex} PluginIndex
             */
            PluginIndex.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.plugin.PluginIndex)
                    return object;
                var message = new $root.lebai.plugin.PluginIndex();
                if (object.name != null)
                    message.name = String(object.name);
                return message;
            };

            /**
             * Creates a plain object from a PluginIndex message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.plugin.PluginIndex
             * @static
             * @param {lebai.plugin.PluginIndex} message PluginIndex
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PluginIndex.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.name = "";
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                return object;
            };

            /**
             * Converts this PluginIndex to JSON.
             * @function toJSON
             * @memberof lebai.plugin.PluginIndex
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PluginIndex.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for PluginIndex
             * @function getTypeUrl
             * @memberof lebai.plugin.PluginIndex
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            PluginIndex.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.plugin.PluginIndex";
            };

            return PluginIndex;
        })();

        plugin.Plugins = (function() {

            /**
             * Properties of a Plugins.
             * @memberof lebai.plugin
             * @interface IPlugins
             * @property {Array.<lebai.plugin.IPluginInfo>|null} [plugins] Plugins plugins
             */

            /**
             * Constructs a new Plugins.
             * @memberof lebai.plugin
             * @classdesc Represents a Plugins.
             * @implements IPlugins
             * @constructor
             * @param {lebai.plugin.IPlugins=} [properties] Properties to set
             */
            function Plugins(properties) {
                this.plugins = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Plugins plugins.
             * @member {Array.<lebai.plugin.IPluginInfo>} plugins
             * @memberof lebai.plugin.Plugins
             * @instance
             */
            Plugins.prototype.plugins = $util.emptyArray;

            /**
             * Creates a new Plugins instance using the specified properties.
             * @function create
             * @memberof lebai.plugin.Plugins
             * @static
             * @param {lebai.plugin.IPlugins=} [properties] Properties to set
             * @returns {lebai.plugin.Plugins} Plugins instance
             */
            Plugins.create = function create(properties) {
                return new Plugins(properties);
            };

            /**
             * Encodes the specified Plugins message. Does not implicitly {@link lebai.plugin.Plugins.verify|verify} messages.
             * @function encode
             * @memberof lebai.plugin.Plugins
             * @static
             * @param {lebai.plugin.IPlugins} message Plugins message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Plugins.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.plugins != null && message.plugins.length)
                    for (var i = 0; i < message.plugins.length; ++i)
                        $root.lebai.plugin.PluginInfo.encode(message.plugins[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Plugins message, length delimited. Does not implicitly {@link lebai.plugin.Plugins.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.plugin.Plugins
             * @static
             * @param {lebai.plugin.IPlugins} message Plugins message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Plugins.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Plugins message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.plugin.Plugins
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.plugin.Plugins} Plugins
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Plugins.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.plugin.Plugins();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.plugins && message.plugins.length))
                                message.plugins = [];
                            message.plugins.push($root.lebai.plugin.PluginInfo.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Plugins message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.plugin.Plugins
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.plugin.Plugins} Plugins
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Plugins.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Plugins message.
             * @function verify
             * @memberof lebai.plugin.Plugins
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Plugins.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.plugins != null && message.hasOwnProperty("plugins")) {
                    if (!Array.isArray(message.plugins))
                        return "plugins: array expected";
                    for (var i = 0; i < message.plugins.length; ++i) {
                        var error = $root.lebai.plugin.PluginInfo.verify(message.plugins[i]);
                        if (error)
                            return "plugins." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Plugins message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.plugin.Plugins
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.plugin.Plugins} Plugins
             */
            Plugins.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.plugin.Plugins)
                    return object;
                var message = new $root.lebai.plugin.Plugins();
                if (object.plugins) {
                    if (!Array.isArray(object.plugins))
                        throw TypeError(".lebai.plugin.Plugins.plugins: array expected");
                    message.plugins = [];
                    for (var i = 0; i < object.plugins.length; ++i) {
                        if (typeof object.plugins[i] !== "object")
                            throw TypeError(".lebai.plugin.Plugins.plugins: object expected");
                        message.plugins[i] = $root.lebai.plugin.PluginInfo.fromObject(object.plugins[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a Plugins message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.plugin.Plugins
             * @static
             * @param {lebai.plugin.Plugins} message Plugins
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Plugins.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.plugins = [];
                if (message.plugins && message.plugins.length) {
                    object.plugins = [];
                    for (var j = 0; j < message.plugins.length; ++j)
                        object.plugins[j] = $root.lebai.plugin.PluginInfo.toObject(message.plugins[j], options);
                }
                return object;
            };

            /**
             * Converts this Plugins to JSON.
             * @function toJSON
             * @memberof lebai.plugin.Plugins
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Plugins.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Plugins
             * @function getTypeUrl
             * @memberof lebai.plugin.Plugins
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Plugins.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.plugin.Plugins";
            };

            return Plugins;
        })();

        plugin.RunPluginCmdRequest = (function() {

            /**
             * Properties of a RunPluginCmdRequest.
             * @memberof lebai.plugin
             * @interface IRunPluginCmdRequest
             * @property {string|null} [name] RunPluginCmdRequest name
             * @property {Array.<string>|null} [params] RunPluginCmdRequest params
             */

            /**
             * Constructs a new RunPluginCmdRequest.
             * @memberof lebai.plugin
             * @classdesc Represents a RunPluginCmdRequest.
             * @implements IRunPluginCmdRequest
             * @constructor
             * @param {lebai.plugin.IRunPluginCmdRequest=} [properties] Properties to set
             */
            function RunPluginCmdRequest(properties) {
                this.params = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RunPluginCmdRequest name.
             * @member {string} name
             * @memberof lebai.plugin.RunPluginCmdRequest
             * @instance
             */
            RunPluginCmdRequest.prototype.name = "";

            /**
             * RunPluginCmdRequest params.
             * @member {Array.<string>} params
             * @memberof lebai.plugin.RunPluginCmdRequest
             * @instance
             */
            RunPluginCmdRequest.prototype.params = $util.emptyArray;

            /**
             * Creates a new RunPluginCmdRequest instance using the specified properties.
             * @function create
             * @memberof lebai.plugin.RunPluginCmdRequest
             * @static
             * @param {lebai.plugin.IRunPluginCmdRequest=} [properties] Properties to set
             * @returns {lebai.plugin.RunPluginCmdRequest} RunPluginCmdRequest instance
             */
            RunPluginCmdRequest.create = function create(properties) {
                return new RunPluginCmdRequest(properties);
            };

            /**
             * Encodes the specified RunPluginCmdRequest message. Does not implicitly {@link lebai.plugin.RunPluginCmdRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.plugin.RunPluginCmdRequest
             * @static
             * @param {lebai.plugin.IRunPluginCmdRequest} message RunPluginCmdRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RunPluginCmdRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.params != null && message.params.length)
                    for (var i = 0; i < message.params.length; ++i)
                        writer.uint32(/* id 22, wireType 2 =*/178).string(message.params[i]);
                return writer;
            };

            /**
             * Encodes the specified RunPluginCmdRequest message, length delimited. Does not implicitly {@link lebai.plugin.RunPluginCmdRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.plugin.RunPluginCmdRequest
             * @static
             * @param {lebai.plugin.IRunPluginCmdRequest} message RunPluginCmdRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RunPluginCmdRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RunPluginCmdRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.plugin.RunPluginCmdRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.plugin.RunPluginCmdRequest} RunPluginCmdRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RunPluginCmdRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.plugin.RunPluginCmdRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.name = reader.string();
                            break;
                        }
                    case 22: {
                            if (!(message.params && message.params.length))
                                message.params = [];
                            message.params.push(reader.string());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RunPluginCmdRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.plugin.RunPluginCmdRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.plugin.RunPluginCmdRequest} RunPluginCmdRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RunPluginCmdRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RunPluginCmdRequest message.
             * @function verify
             * @memberof lebai.plugin.RunPluginCmdRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RunPluginCmdRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.params != null && message.hasOwnProperty("params")) {
                    if (!Array.isArray(message.params))
                        return "params: array expected";
                    for (var i = 0; i < message.params.length; ++i)
                        if (!$util.isString(message.params[i]))
                            return "params: string[] expected";
                }
                return null;
            };

            /**
             * Creates a RunPluginCmdRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.plugin.RunPluginCmdRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.plugin.RunPluginCmdRequest} RunPluginCmdRequest
             */
            RunPluginCmdRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.plugin.RunPluginCmdRequest)
                    return object;
                var message = new $root.lebai.plugin.RunPluginCmdRequest();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.params) {
                    if (!Array.isArray(object.params))
                        throw TypeError(".lebai.plugin.RunPluginCmdRequest.params: array expected");
                    message.params = [];
                    for (var i = 0; i < object.params.length; ++i)
                        message.params[i] = String(object.params[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a RunPluginCmdRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.plugin.RunPluginCmdRequest
             * @static
             * @param {lebai.plugin.RunPluginCmdRequest} message RunPluginCmdRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RunPluginCmdRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.params = [];
                if (options.defaults)
                    object.name = "";
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.params && message.params.length) {
                    object.params = [];
                    for (var j = 0; j < message.params.length; ++j)
                        object.params[j] = message.params[j];
                }
                return object;
            };

            /**
             * Converts this RunPluginCmdRequest to JSON.
             * @function toJSON
             * @memberof lebai.plugin.RunPluginCmdRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RunPluginCmdRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for RunPluginCmdRequest
             * @function getTypeUrl
             * @memberof lebai.plugin.RunPluginCmdRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            RunPluginCmdRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.plugin.RunPluginCmdRequest";
            };

            return RunPluginCmdRequest;
        })();

        plugin.PluginService = (function() {

            /**
             * Constructs a new PluginService service.
             * @memberof lebai.plugin
             * @classdesc Represents a PluginService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function PluginService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (PluginService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = PluginService;

            /**
             * Creates new PluginService service using the specified rpc implementation.
             * @function create
             * @memberof lebai.plugin.PluginService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {PluginService} RPC service. Useful where requests and/or responses are streamed.
             */
            PluginService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link lebai.plugin.PluginService#loadPlugin}.
             * @memberof lebai.plugin.PluginService
             * @typedef LoadPluginCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.plugin.PluginInfo} [response] PluginInfo
             */

            /**
             * Calls LoadPlugin.
             * @function loadPlugin
             * @memberof lebai.plugin.PluginService
             * @instance
             * @param {lebai.plugin.IPluginIndex} request PluginIndex message or plain object
             * @param {lebai.plugin.PluginService.LoadPluginCallback} callback Node-style callback called with the error, if any, and PluginInfo
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(PluginService.prototype.loadPlugin = function loadPlugin(request, callback) {
                return this.rpcCall(loadPlugin, $root.lebai.plugin.PluginIndex, $root.lebai.plugin.PluginInfo, request, callback);
            }, "name", { value: "LoadPlugin" });

            /**
             * Calls LoadPlugin.
             * @function loadPlugin
             * @memberof lebai.plugin.PluginService
             * @instance
             * @param {lebai.plugin.IPluginIndex} request PluginIndex message or plain object
             * @returns {Promise<lebai.plugin.PluginInfo>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.plugin.PluginService#loadPlugins}.
             * @memberof lebai.plugin.PluginService
             * @typedef LoadPluginsCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.plugin.Plugins} [response] Plugins
             */

            /**
             * Calls LoadPlugins.
             * @function loadPlugins
             * @memberof lebai.plugin.PluginService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {lebai.plugin.PluginService.LoadPluginsCallback} callback Node-style callback called with the error, if any, and Plugins
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(PluginService.prototype.loadPlugins = function loadPlugins(request, callback) {
                return this.rpcCall(loadPlugins, $root.google.protobuf.Empty, $root.lebai.plugin.Plugins, request, callback);
            }, "name", { value: "LoadPlugins" });

            /**
             * Calls LoadPlugins.
             * @function loadPlugins
             * @memberof lebai.plugin.PluginService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<lebai.plugin.Plugins>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.plugin.PluginService#enablePlugin}.
             * @memberof lebai.plugin.PluginService
             * @typedef EnablePluginCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.CommandStdout} [response] CommandStdout
             */

            /**
             * Calls EnablePlugin.
             * @function enablePlugin
             * @memberof lebai.plugin.PluginService
             * @instance
             * @param {lebai.plugin.IPluginIndex} request PluginIndex message or plain object
             * @param {lebai.plugin.PluginService.EnablePluginCallback} callback Node-style callback called with the error, if any, and CommandStdout
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(PluginService.prototype.enablePlugin = function enablePlugin(request, callback) {
                return this.rpcCall(enablePlugin, $root.lebai.plugin.PluginIndex, $root.lebai.CommandStdout, request, callback);
            }, "name", { value: "EnablePlugin" });

            /**
             * Calls EnablePlugin.
             * @function enablePlugin
             * @memberof lebai.plugin.PluginService
             * @instance
             * @param {lebai.plugin.IPluginIndex} request PluginIndex message or plain object
             * @returns {Promise<lebai.CommandStdout>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.plugin.PluginService#disablePlugin}.
             * @memberof lebai.plugin.PluginService
             * @typedef DisablePluginCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.CommandStdout} [response] CommandStdout
             */

            /**
             * Calls DisablePlugin.
             * @function disablePlugin
             * @memberof lebai.plugin.PluginService
             * @instance
             * @param {lebai.plugin.IPluginIndex} request PluginIndex message or plain object
             * @param {lebai.plugin.PluginService.DisablePluginCallback} callback Node-style callback called with the error, if any, and CommandStdout
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(PluginService.prototype.disablePlugin = function disablePlugin(request, callback) {
                return this.rpcCall(disablePlugin, $root.lebai.plugin.PluginIndex, $root.lebai.CommandStdout, request, callback);
            }, "name", { value: "DisablePlugin" });

            /**
             * Calls DisablePlugin.
             * @function disablePlugin
             * @memberof lebai.plugin.PluginService
             * @instance
             * @param {lebai.plugin.IPluginIndex} request PluginIndex message or plain object
             * @returns {Promise<lebai.CommandStdout>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.plugin.PluginService#getPluginDaemonStdout}.
             * @memberof lebai.plugin.PluginService
             * @typedef GetPluginDaemonStdoutCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.CommandStdout} [response] CommandStdout
             */

            /**
             * Calls GetPluginDaemonStdout.
             * @function getPluginDaemonStdout
             * @memberof lebai.plugin.PluginService
             * @instance
             * @param {lebai.plugin.IPluginIndex} request PluginIndex message or plain object
             * @param {lebai.plugin.PluginService.GetPluginDaemonStdoutCallback} callback Node-style callback called with the error, if any, and CommandStdout
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(PluginService.prototype.getPluginDaemonStdout = function getPluginDaemonStdout(request, callback) {
                return this.rpcCall(getPluginDaemonStdout, $root.lebai.plugin.PluginIndex, $root.lebai.CommandStdout, request, callback);
            }, "name", { value: "GetPluginDaemonStdout" });

            /**
             * Calls GetPluginDaemonStdout.
             * @function getPluginDaemonStdout
             * @memberof lebai.plugin.PluginService
             * @instance
             * @param {lebai.plugin.IPluginIndex} request PluginIndex message or plain object
             * @returns {Promise<lebai.CommandStdout>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.plugin.PluginService#runPluginCmd}.
             * @memberof lebai.plugin.PluginService
             * @typedef RunPluginCmdCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.CommandStdout} [response] CommandStdout
             */

            /**
             * Calls RunPluginCmd.
             * @function runPluginCmd
             * @memberof lebai.plugin.PluginService
             * @instance
             * @param {lebai.plugin.IRunPluginCmdRequest} request RunPluginCmdRequest message or plain object
             * @param {lebai.plugin.PluginService.RunPluginCmdCallback} callback Node-style callback called with the error, if any, and CommandStdout
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(PluginService.prototype.runPluginCmd = function runPluginCmd(request, callback) {
                return this.rpcCall(runPluginCmd, $root.lebai.plugin.RunPluginCmdRequest, $root.lebai.CommandStdout, request, callback);
            }, "name", { value: "RunPluginCmd" });

            /**
             * Calls RunPluginCmd.
             * @function runPluginCmd
             * @memberof lebai.plugin.PluginService
             * @instance
             * @param {lebai.plugin.IRunPluginCmdRequest} request RunPluginCmdRequest message or plain object
             * @returns {Promise<lebai.CommandStdout>} Promise
             * @variation 2
             */

            return PluginService;
        })();

        return plugin;
    })();

    lebai.quality = (function() {

        /**
         * Namespace quality.
         * @memberof lebai
         * @namespace
         */
        var quality = {};

        quality.Auth = (function() {

            /**
             * Properties of an Auth.
             * @memberof lebai.quality
             * @interface IAuth
             * @property {string|null} [time] Auth time
             * @property {string|null} [auth] Auth auth
             */

            /**
             * Constructs a new Auth.
             * @memberof lebai.quality
             * @classdesc Represents an Auth.
             * @implements IAuth
             * @constructor
             * @param {lebai.quality.IAuth=} [properties] Properties to set
             */
            function Auth(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Auth time.
             * @member {string} time
             * @memberof lebai.quality.Auth
             * @instance
             */
            Auth.prototype.time = "";

            /**
             * Auth auth.
             * @member {string} auth
             * @memberof lebai.quality.Auth
             * @instance
             */
            Auth.prototype.auth = "";

            /**
             * Creates a new Auth instance using the specified properties.
             * @function create
             * @memberof lebai.quality.Auth
             * @static
             * @param {lebai.quality.IAuth=} [properties] Properties to set
             * @returns {lebai.quality.Auth} Auth instance
             */
            Auth.create = function create(properties) {
                return new Auth(properties);
            };

            /**
             * Encodes the specified Auth message. Does not implicitly {@link lebai.quality.Auth.verify|verify} messages.
             * @function encode
             * @memberof lebai.quality.Auth
             * @static
             * @param {lebai.quality.IAuth} message Auth message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Auth.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.time);
                if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.auth);
                return writer;
            };

            /**
             * Encodes the specified Auth message, length delimited. Does not implicitly {@link lebai.quality.Auth.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.quality.Auth
             * @static
             * @param {lebai.quality.IAuth} message Auth message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Auth.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Auth message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.quality.Auth
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.quality.Auth} Auth
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Auth.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.quality.Auth();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.time = reader.string();
                            break;
                        }
                    case 2: {
                            message.auth = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Auth message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.quality.Auth
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.quality.Auth} Auth
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Auth.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Auth message.
             * @function verify
             * @memberof lebai.quality.Auth
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Auth.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.time != null && message.hasOwnProperty("time"))
                    if (!$util.isString(message.time))
                        return "time: string expected";
                if (message.auth != null && message.hasOwnProperty("auth"))
                    if (!$util.isString(message.auth))
                        return "auth: string expected";
                return null;
            };

            /**
             * Creates an Auth message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.quality.Auth
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.quality.Auth} Auth
             */
            Auth.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.quality.Auth)
                    return object;
                var message = new $root.lebai.quality.Auth();
                if (object.time != null)
                    message.time = String(object.time);
                if (object.auth != null)
                    message.auth = String(object.auth);
                return message;
            };

            /**
             * Creates a plain object from an Auth message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.quality.Auth
             * @static
             * @param {lebai.quality.Auth} message Auth
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Auth.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.time = "";
                    object.auth = "";
                }
                if (message.time != null && message.hasOwnProperty("time"))
                    object.time = message.time;
                if (message.auth != null && message.hasOwnProperty("auth"))
                    object.auth = message.auth;
                return object;
            };

            /**
             * Converts this Auth to JSON.
             * @function toJSON
             * @memberof lebai.quality.Auth
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Auth.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Auth
             * @function getTypeUrl
             * @memberof lebai.quality.Auth
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Auth.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.quality.Auth";
            };

            return Auth;
        })();

        quality.EmptyRequest = (function() {

            /**
             * Properties of an EmptyRequest.
             * @memberof lebai.quality
             * @interface IEmptyRequest
             * @property {lebai.quality.IAuth|null} [auth] EmptyRequest auth
             */

            /**
             * Constructs a new EmptyRequest.
             * @memberof lebai.quality
             * @classdesc Represents an EmptyRequest.
             * @implements IEmptyRequest
             * @constructor
             * @param {lebai.quality.IEmptyRequest=} [properties] Properties to set
             */
            function EmptyRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EmptyRequest auth.
             * @member {lebai.quality.IAuth|null|undefined} auth
             * @memberof lebai.quality.EmptyRequest
             * @instance
             */
            EmptyRequest.prototype.auth = null;

            /**
             * Creates a new EmptyRequest instance using the specified properties.
             * @function create
             * @memberof lebai.quality.EmptyRequest
             * @static
             * @param {lebai.quality.IEmptyRequest=} [properties] Properties to set
             * @returns {lebai.quality.EmptyRequest} EmptyRequest instance
             */
            EmptyRequest.create = function create(properties) {
                return new EmptyRequest(properties);
            };

            /**
             * Encodes the specified EmptyRequest message. Does not implicitly {@link lebai.quality.EmptyRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.quality.EmptyRequest
             * @static
             * @param {lebai.quality.IEmptyRequest} message EmptyRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EmptyRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                    $root.lebai.quality.Auth.encode(message.auth, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified EmptyRequest message, length delimited. Does not implicitly {@link lebai.quality.EmptyRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.quality.EmptyRequest
             * @static
             * @param {lebai.quality.IEmptyRequest} message EmptyRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EmptyRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EmptyRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.quality.EmptyRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.quality.EmptyRequest} EmptyRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EmptyRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.quality.EmptyRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.auth = $root.lebai.quality.Auth.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EmptyRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.quality.EmptyRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.quality.EmptyRequest} EmptyRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EmptyRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EmptyRequest message.
             * @function verify
             * @memberof lebai.quality.EmptyRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EmptyRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.auth != null && message.hasOwnProperty("auth")) {
                    var error = $root.lebai.quality.Auth.verify(message.auth);
                    if (error)
                        return "auth." + error;
                }
                return null;
            };

            /**
             * Creates an EmptyRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.quality.EmptyRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.quality.EmptyRequest} EmptyRequest
             */
            EmptyRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.quality.EmptyRequest)
                    return object;
                var message = new $root.lebai.quality.EmptyRequest();
                if (object.auth != null) {
                    if (typeof object.auth !== "object")
                        throw TypeError(".lebai.quality.EmptyRequest.auth: object expected");
                    message.auth = $root.lebai.quality.Auth.fromObject(object.auth);
                }
                return message;
            };

            /**
             * Creates a plain object from an EmptyRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.quality.EmptyRequest
             * @static
             * @param {lebai.quality.EmptyRequest} message EmptyRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EmptyRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.auth = null;
                if (message.auth != null && message.hasOwnProperty("auth"))
                    object.auth = $root.lebai.quality.Auth.toObject(message.auth, options);
                return object;
            };

            /**
             * Converts this EmptyRequest to JSON.
             * @function toJSON
             * @memberof lebai.quality.EmptyRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EmptyRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for EmptyRequest
             * @function getTypeUrl
             * @memberof lebai.quality.EmptyRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            EmptyRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.quality.EmptyRequest";
            };

            return EmptyRequest;
        })();

        quality.BoxTestResponse = (function() {

            /**
             * Properties of a BoxTestResponse.
             * @memberof lebai.quality
             * @interface IBoxTestResponse
             * @property {number|null} [status] BoxTestResponse status
             */

            /**
             * Constructs a new BoxTestResponse.
             * @memberof lebai.quality
             * @classdesc Represents a BoxTestResponse.
             * @implements IBoxTestResponse
             * @constructor
             * @param {lebai.quality.IBoxTestResponse=} [properties] Properties to set
             */
            function BoxTestResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BoxTestResponse status.
             * @member {number} status
             * @memberof lebai.quality.BoxTestResponse
             * @instance
             */
            BoxTestResponse.prototype.status = 0;

            /**
             * Creates a new BoxTestResponse instance using the specified properties.
             * @function create
             * @memberof lebai.quality.BoxTestResponse
             * @static
             * @param {lebai.quality.IBoxTestResponse=} [properties] Properties to set
             * @returns {lebai.quality.BoxTestResponse} BoxTestResponse instance
             */
            BoxTestResponse.create = function create(properties) {
                return new BoxTestResponse(properties);
            };

            /**
             * Encodes the specified BoxTestResponse message. Does not implicitly {@link lebai.quality.BoxTestResponse.verify|verify} messages.
             * @function encode
             * @memberof lebai.quality.BoxTestResponse
             * @static
             * @param {lebai.quality.IBoxTestResponse} message BoxTestResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BoxTestResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                return writer;
            };

            /**
             * Encodes the specified BoxTestResponse message, length delimited. Does not implicitly {@link lebai.quality.BoxTestResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.quality.BoxTestResponse
             * @static
             * @param {lebai.quality.IBoxTestResponse} message BoxTestResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BoxTestResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BoxTestResponse message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.quality.BoxTestResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.quality.BoxTestResponse} BoxTestResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BoxTestResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.quality.BoxTestResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.status = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BoxTestResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.quality.BoxTestResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.quality.BoxTestResponse} BoxTestResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BoxTestResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BoxTestResponse message.
             * @function verify
             * @memberof lebai.quality.BoxTestResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BoxTestResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.status != null && message.hasOwnProperty("status"))
                    if (!$util.isInteger(message.status))
                        return "status: integer expected";
                return null;
            };

            /**
             * Creates a BoxTestResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.quality.BoxTestResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.quality.BoxTestResponse} BoxTestResponse
             */
            BoxTestResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.quality.BoxTestResponse)
                    return object;
                var message = new $root.lebai.quality.BoxTestResponse();
                if (object.status != null)
                    message.status = object.status | 0;
                return message;
            };

            /**
             * Creates a plain object from a BoxTestResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.quality.BoxTestResponse
             * @static
             * @param {lebai.quality.BoxTestResponse} message BoxTestResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BoxTestResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.status = 0;
                if (message.status != null && message.hasOwnProperty("status"))
                    object.status = message.status;
                return object;
            };

            /**
             * Converts this BoxTestResponse to JSON.
             * @function toJSON
             * @memberof lebai.quality.BoxTestResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BoxTestResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for BoxTestResponse
             * @function getTypeUrl
             * @memberof lebai.quality.BoxTestResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            BoxTestResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.quality.BoxTestResponse";
            };

            return BoxTestResponse;
        })();

        quality.InitRobotRequest = (function() {

            /**
             * Properties of an InitRobotRequest.
             * @memberof lebai.quality
             * @interface IInitRobotRequest
             * @property {lebai.quality.IAuth|null} [auth] InitRobotRequest auth
             * @property {lebai.system.IRobotInfo|null} [info] InitRobotRequest info
             */

            /**
             * Constructs a new InitRobotRequest.
             * @memberof lebai.quality
             * @classdesc Represents an InitRobotRequest.
             * @implements IInitRobotRequest
             * @constructor
             * @param {lebai.quality.IInitRobotRequest=} [properties] Properties to set
             */
            function InitRobotRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * InitRobotRequest auth.
             * @member {lebai.quality.IAuth|null|undefined} auth
             * @memberof lebai.quality.InitRobotRequest
             * @instance
             */
            InitRobotRequest.prototype.auth = null;

            /**
             * InitRobotRequest info.
             * @member {lebai.system.IRobotInfo|null|undefined} info
             * @memberof lebai.quality.InitRobotRequest
             * @instance
             */
            InitRobotRequest.prototype.info = null;

            /**
             * Creates a new InitRobotRequest instance using the specified properties.
             * @function create
             * @memberof lebai.quality.InitRobotRequest
             * @static
             * @param {lebai.quality.IInitRobotRequest=} [properties] Properties to set
             * @returns {lebai.quality.InitRobotRequest} InitRobotRequest instance
             */
            InitRobotRequest.create = function create(properties) {
                return new InitRobotRequest(properties);
            };

            /**
             * Encodes the specified InitRobotRequest message. Does not implicitly {@link lebai.quality.InitRobotRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.quality.InitRobotRequest
             * @static
             * @param {lebai.quality.IInitRobotRequest} message InitRobotRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            InitRobotRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.auth != null && Object.hasOwnProperty.call(message, "auth"))
                    $root.lebai.quality.Auth.encode(message.auth, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.info != null && Object.hasOwnProperty.call(message, "info"))
                    $root.lebai.system.RobotInfo.encode(message.info, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified InitRobotRequest message, length delimited. Does not implicitly {@link lebai.quality.InitRobotRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.quality.InitRobotRequest
             * @static
             * @param {lebai.quality.IInitRobotRequest} message InitRobotRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            InitRobotRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an InitRobotRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.quality.InitRobotRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.quality.InitRobotRequest} InitRobotRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            InitRobotRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.quality.InitRobotRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.auth = $root.lebai.quality.Auth.decode(reader, reader.uint32());
                            break;
                        }
                    case 11: {
                            message.info = $root.lebai.system.RobotInfo.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an InitRobotRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.quality.InitRobotRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.quality.InitRobotRequest} InitRobotRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            InitRobotRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an InitRobotRequest message.
             * @function verify
             * @memberof lebai.quality.InitRobotRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            InitRobotRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.auth != null && message.hasOwnProperty("auth")) {
                    var error = $root.lebai.quality.Auth.verify(message.auth);
                    if (error)
                        return "auth." + error;
                }
                if (message.info != null && message.hasOwnProperty("info")) {
                    var error = $root.lebai.system.RobotInfo.verify(message.info);
                    if (error)
                        return "info." + error;
                }
                return null;
            };

            /**
             * Creates an InitRobotRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.quality.InitRobotRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.quality.InitRobotRequest} InitRobotRequest
             */
            InitRobotRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.quality.InitRobotRequest)
                    return object;
                var message = new $root.lebai.quality.InitRobotRequest();
                if (object.auth != null) {
                    if (typeof object.auth !== "object")
                        throw TypeError(".lebai.quality.InitRobotRequest.auth: object expected");
                    message.auth = $root.lebai.quality.Auth.fromObject(object.auth);
                }
                if (object.info != null) {
                    if (typeof object.info !== "object")
                        throw TypeError(".lebai.quality.InitRobotRequest.info: object expected");
                    message.info = $root.lebai.system.RobotInfo.fromObject(object.info);
                }
                return message;
            };

            /**
             * Creates a plain object from an InitRobotRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.quality.InitRobotRequest
             * @static
             * @param {lebai.quality.InitRobotRequest} message InitRobotRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            InitRobotRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.auth = null;
                    object.info = null;
                }
                if (message.auth != null && message.hasOwnProperty("auth"))
                    object.auth = $root.lebai.quality.Auth.toObject(message.auth, options);
                if (message.info != null && message.hasOwnProperty("info"))
                    object.info = $root.lebai.system.RobotInfo.toObject(message.info, options);
                return object;
            };

            /**
             * Converts this InitRobotRequest to JSON.
             * @function toJSON
             * @memberof lebai.quality.InitRobotRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            InitRobotRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for InitRobotRequest
             * @function getTypeUrl
             * @memberof lebai.quality.InitRobotRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            InitRobotRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.quality.InitRobotRequest";
            };

            return InitRobotRequest;
        })();

        quality.InitRobotResponse = (function() {

            /**
             * Properties of an InitRobotResponse.
             * @memberof lebai.quality
             * @interface IInitRobotResponse
             * @property {string|null} [cup] InitRobotResponse cup
             */

            /**
             * Constructs a new InitRobotResponse.
             * @memberof lebai.quality
             * @classdesc Represents an InitRobotResponse.
             * @implements IInitRobotResponse
             * @constructor
             * @param {lebai.quality.IInitRobotResponse=} [properties] Properties to set
             */
            function InitRobotResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * InitRobotResponse cup.
             * @member {string} cup
             * @memberof lebai.quality.InitRobotResponse
             * @instance
             */
            InitRobotResponse.prototype.cup = "";

            /**
             * Creates a new InitRobotResponse instance using the specified properties.
             * @function create
             * @memberof lebai.quality.InitRobotResponse
             * @static
             * @param {lebai.quality.IInitRobotResponse=} [properties] Properties to set
             * @returns {lebai.quality.InitRobotResponse} InitRobotResponse instance
             */
            InitRobotResponse.create = function create(properties) {
                return new InitRobotResponse(properties);
            };

            /**
             * Encodes the specified InitRobotResponse message. Does not implicitly {@link lebai.quality.InitRobotResponse.verify|verify} messages.
             * @function encode
             * @memberof lebai.quality.InitRobotResponse
             * @static
             * @param {lebai.quality.IInitRobotResponse} message InitRobotResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            InitRobotResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.cup != null && Object.hasOwnProperty.call(message, "cup"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.cup);
                return writer;
            };

            /**
             * Encodes the specified InitRobotResponse message, length delimited. Does not implicitly {@link lebai.quality.InitRobotResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.quality.InitRobotResponse
             * @static
             * @param {lebai.quality.IInitRobotResponse} message InitRobotResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            InitRobotResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an InitRobotResponse message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.quality.InitRobotResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.quality.InitRobotResponse} InitRobotResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            InitRobotResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.quality.InitRobotResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.cup = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an InitRobotResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.quality.InitRobotResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.quality.InitRobotResponse} InitRobotResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            InitRobotResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an InitRobotResponse message.
             * @function verify
             * @memberof lebai.quality.InitRobotResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            InitRobotResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.cup != null && message.hasOwnProperty("cup"))
                    if (!$util.isString(message.cup))
                        return "cup: string expected";
                return null;
            };

            /**
             * Creates an InitRobotResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.quality.InitRobotResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.quality.InitRobotResponse} InitRobotResponse
             */
            InitRobotResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.quality.InitRobotResponse)
                    return object;
                var message = new $root.lebai.quality.InitRobotResponse();
                if (object.cup != null)
                    message.cup = String(object.cup);
                return message;
            };

            /**
             * Creates a plain object from an InitRobotResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.quality.InitRobotResponse
             * @static
             * @param {lebai.quality.InitRobotResponse} message InitRobotResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            InitRobotResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.cup = "";
                if (message.cup != null && message.hasOwnProperty("cup"))
                    object.cup = message.cup;
                return object;
            };

            /**
             * Converts this InitRobotResponse to JSON.
             * @function toJSON
             * @memberof lebai.quality.InitRobotResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            InitRobotResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for InitRobotResponse
             * @function getTypeUrl
             * @memberof lebai.quality.InitRobotResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            InitRobotResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.quality.InitRobotResponse";
            };

            return InitRobotResponse;
        })();

        quality.QualityService = (function() {

            /**
             * Constructs a new QualityService service.
             * @memberof lebai.quality
             * @classdesc Represents a QualityService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function QualityService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (QualityService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = QualityService;

            /**
             * Creates new QualityService service using the specified rpc implementation.
             * @function create
             * @memberof lebai.quality.QualityService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {QualityService} RPC service. Useful where requests and/or responses are streamed.
             */
            QualityService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link lebai.quality.QualityService#boxTest}.
             * @memberof lebai.quality.QualityService
             * @typedef BoxTestCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.quality.BoxTestResponse} [response] BoxTestResponse
             */

            /**
             * Calls BoxTest.
             * @function boxTest
             * @memberof lebai.quality.QualityService
             * @instance
             * @param {lebai.quality.IEmptyRequest} request EmptyRequest message or plain object
             * @param {lebai.quality.QualityService.BoxTestCallback} callback Node-style callback called with the error, if any, and BoxTestResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(QualityService.prototype.boxTest = function boxTest(request, callback) {
                return this.rpcCall(boxTest, $root.lebai.quality.EmptyRequest, $root.lebai.quality.BoxTestResponse, request, callback);
            }, "name", { value: "BoxTest" });

            /**
             * Calls BoxTest.
             * @function boxTest
             * @memberof lebai.quality.QualityService
             * @instance
             * @param {lebai.quality.IEmptyRequest} request EmptyRequest message or plain object
             * @returns {Promise<lebai.quality.BoxTestResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.quality.QualityService#initRobot}.
             * @memberof lebai.quality.QualityService
             * @typedef InitRobotCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.quality.InitRobotResponse} [response] InitRobotResponse
             */

            /**
             * Calls InitRobot.
             * @function initRobot
             * @memberof lebai.quality.QualityService
             * @instance
             * @param {lebai.quality.IInitRobotRequest} request InitRobotRequest message or plain object
             * @param {lebai.quality.QualityService.InitRobotCallback} callback Node-style callback called with the error, if any, and InitRobotResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(QualityService.prototype.initRobot = function initRobot(request, callback) {
                return this.rpcCall(initRobot, $root.lebai.quality.InitRobotRequest, $root.lebai.quality.InitRobotResponse, request, callback);
            }, "name", { value: "InitRobot" });

            /**
             * Calls InitRobot.
             * @function initRobot
             * @memberof lebai.quality.QualityService
             * @instance
             * @param {lebai.quality.IInitRobotRequest} request InitRobotRequest message or plain object
             * @returns {Promise<lebai.quality.InitRobotResponse>} Promise
             * @variation 2
             */

            return QualityService;
        })();

        return quality;
    })();

    lebai.safety = (function() {

        /**
         * Namespace safety.
         * @memberof lebai
         * @namespace
         */
        var safety = {};

        safety.CollisionTorqueDiff = (function() {

            /**
             * Properties of a CollisionTorqueDiff.
             * @memberof lebai.safety
             * @interface ICollisionTorqueDiff
             * @property {Array.<number>|null} [diffs] CollisionTorqueDiff diffs
             */

            /**
             * Constructs a new CollisionTorqueDiff.
             * @memberof lebai.safety
             * @classdesc Represents a CollisionTorqueDiff.
             * @implements ICollisionTorqueDiff
             * @constructor
             * @param {lebai.safety.ICollisionTorqueDiff=} [properties] Properties to set
             */
            function CollisionTorqueDiff(properties) {
                this.diffs = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CollisionTorqueDiff diffs.
             * @member {Array.<number>} diffs
             * @memberof lebai.safety.CollisionTorqueDiff
             * @instance
             */
            CollisionTorqueDiff.prototype.diffs = $util.emptyArray;

            /**
             * Creates a new CollisionTorqueDiff instance using the specified properties.
             * @function create
             * @memberof lebai.safety.CollisionTorqueDiff
             * @static
             * @param {lebai.safety.ICollisionTorqueDiff=} [properties] Properties to set
             * @returns {lebai.safety.CollisionTorqueDiff} CollisionTorqueDiff instance
             */
            CollisionTorqueDiff.create = function create(properties) {
                return new CollisionTorqueDiff(properties);
            };

            /**
             * Encodes the specified CollisionTorqueDiff message. Does not implicitly {@link lebai.safety.CollisionTorqueDiff.verify|verify} messages.
             * @function encode
             * @memberof lebai.safety.CollisionTorqueDiff
             * @static
             * @param {lebai.safety.ICollisionTorqueDiff} message CollisionTorqueDiff message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CollisionTorqueDiff.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.diffs != null && message.diffs.length) {
                    writer.uint32(/* id 1, wireType 2 =*/10).fork();
                    for (var i = 0; i < message.diffs.length; ++i)
                        writer.double(message.diffs[i]);
                    writer.ldelim();
                }
                return writer;
            };

            /**
             * Encodes the specified CollisionTorqueDiff message, length delimited. Does not implicitly {@link lebai.safety.CollisionTorqueDiff.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.safety.CollisionTorqueDiff
             * @static
             * @param {lebai.safety.ICollisionTorqueDiff} message CollisionTorqueDiff message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CollisionTorqueDiff.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CollisionTorqueDiff message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.safety.CollisionTorqueDiff
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.safety.CollisionTorqueDiff} CollisionTorqueDiff
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CollisionTorqueDiff.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.safety.CollisionTorqueDiff();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.diffs && message.diffs.length))
                                message.diffs = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.diffs.push(reader.double());
                            } else
                                message.diffs.push(reader.double());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CollisionTorqueDiff message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.safety.CollisionTorqueDiff
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.safety.CollisionTorqueDiff} CollisionTorqueDiff
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CollisionTorqueDiff.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CollisionTorqueDiff message.
             * @function verify
             * @memberof lebai.safety.CollisionTorqueDiff
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CollisionTorqueDiff.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.diffs != null && message.hasOwnProperty("diffs")) {
                    if (!Array.isArray(message.diffs))
                        return "diffs: array expected";
                    for (var i = 0; i < message.diffs.length; ++i)
                        if (typeof message.diffs[i] !== "number")
                            return "diffs: number[] expected";
                }
                return null;
            };

            /**
             * Creates a CollisionTorqueDiff message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.safety.CollisionTorqueDiff
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.safety.CollisionTorqueDiff} CollisionTorqueDiff
             */
            CollisionTorqueDiff.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.safety.CollisionTorqueDiff)
                    return object;
                var message = new $root.lebai.safety.CollisionTorqueDiff();
                if (object.diffs) {
                    if (!Array.isArray(object.diffs))
                        throw TypeError(".lebai.safety.CollisionTorqueDiff.diffs: array expected");
                    message.diffs = [];
                    for (var i = 0; i < object.diffs.length; ++i)
                        message.diffs[i] = Number(object.diffs[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a CollisionTorqueDiff message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.safety.CollisionTorqueDiff
             * @static
             * @param {lebai.safety.CollisionTorqueDiff} message CollisionTorqueDiff
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CollisionTorqueDiff.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.diffs = [];
                if (message.diffs && message.diffs.length) {
                    object.diffs = [];
                    for (var j = 0; j < message.diffs.length; ++j)
                        object.diffs[j] = options.json && !isFinite(message.diffs[j]) ? String(message.diffs[j]) : message.diffs[j];
                }
                return object;
            };

            /**
             * Converts this CollisionTorqueDiff to JSON.
             * @function toJSON
             * @memberof lebai.safety.CollisionTorqueDiff
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CollisionTorqueDiff.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for CollisionTorqueDiff
             * @function getTypeUrl
             * @memberof lebai.safety.CollisionTorqueDiff
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            CollisionTorqueDiff.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.safety.CollisionTorqueDiff";
            };

            return CollisionTorqueDiff;
        })();

        /**
         * CollisionDetectorAction enum.
         * @name lebai.safety.CollisionDetectorAction
         * @enum {number}
         * @property {number} ESTOP=0 ESTOP value
         * @property {number} PAUSE=1 PAUSE value
         * @property {number} STOP_MOVE=2 STOP_MOVE value
         * @property {number} NONE=99 NONE value
         */
        safety.CollisionDetectorAction = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "ESTOP"] = 0;
            values[valuesById[1] = "PAUSE"] = 1;
            values[valuesById[2] = "STOP_MOVE"] = 2;
            values[valuesById[99] = "NONE"] = 99;
            return values;
        })();

        safety.CollisionDetector = (function() {

            /**
             * Properties of a CollisionDetector.
             * @memberof lebai.safety
             * @interface ICollisionDetector
             * @property {lebai.safety.CollisionDetectorAction|null} [action] CollisionDetector action
             * @property {number|null} [pauseTime] CollisionDetector pauseTime
             * @property {number|null} [sensitivity] CollisionDetector sensitivity
             */

            /**
             * Constructs a new CollisionDetector.
             * @memberof lebai.safety
             * @classdesc Represents a CollisionDetector.
             * @implements ICollisionDetector
             * @constructor
             * @param {lebai.safety.ICollisionDetector=} [properties] Properties to set
             */
            function CollisionDetector(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CollisionDetector action.
             * @member {lebai.safety.CollisionDetectorAction} action
             * @memberof lebai.safety.CollisionDetector
             * @instance
             */
            CollisionDetector.prototype.action = 0;

            /**
             * CollisionDetector pauseTime.
             * @member {number} pauseTime
             * @memberof lebai.safety.CollisionDetector
             * @instance
             */
            CollisionDetector.prototype.pauseTime = 0;

            /**
             * CollisionDetector sensitivity.
             * @member {number} sensitivity
             * @memberof lebai.safety.CollisionDetector
             * @instance
             */
            CollisionDetector.prototype.sensitivity = 0;

            /**
             * Creates a new CollisionDetector instance using the specified properties.
             * @function create
             * @memberof lebai.safety.CollisionDetector
             * @static
             * @param {lebai.safety.ICollisionDetector=} [properties] Properties to set
             * @returns {lebai.safety.CollisionDetector} CollisionDetector instance
             */
            CollisionDetector.create = function create(properties) {
                return new CollisionDetector(properties);
            };

            /**
             * Encodes the specified CollisionDetector message. Does not implicitly {@link lebai.safety.CollisionDetector.verify|verify} messages.
             * @function encode
             * @memberof lebai.safety.CollisionDetector
             * @static
             * @param {lebai.safety.ICollisionDetector} message CollisionDetector message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CollisionDetector.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.action != null && Object.hasOwnProperty.call(message, "action"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.action);
                if (message.pauseTime != null && Object.hasOwnProperty.call(message, "pauseTime"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.pauseTime);
                if (message.sensitivity != null && Object.hasOwnProperty.call(message, "sensitivity"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.sensitivity);
                return writer;
            };

            /**
             * Encodes the specified CollisionDetector message, length delimited. Does not implicitly {@link lebai.safety.CollisionDetector.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.safety.CollisionDetector
             * @static
             * @param {lebai.safety.ICollisionDetector} message CollisionDetector message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CollisionDetector.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CollisionDetector message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.safety.CollisionDetector
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.safety.CollisionDetector} CollisionDetector
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CollisionDetector.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.safety.CollisionDetector();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.action = reader.int32();
                            break;
                        }
                    case 2: {
                            message.pauseTime = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.sensitivity = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CollisionDetector message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.safety.CollisionDetector
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.safety.CollisionDetector} CollisionDetector
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CollisionDetector.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CollisionDetector message.
             * @function verify
             * @memberof lebai.safety.CollisionDetector
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CollisionDetector.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.action != null && message.hasOwnProperty("action"))
                    switch (message.action) {
                    default:
                        return "action: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 99:
                        break;
                    }
                if (message.pauseTime != null && message.hasOwnProperty("pauseTime"))
                    if (!$util.isInteger(message.pauseTime))
                        return "pauseTime: integer expected";
                if (message.sensitivity != null && message.hasOwnProperty("sensitivity"))
                    if (!$util.isInteger(message.sensitivity))
                        return "sensitivity: integer expected";
                return null;
            };

            /**
             * Creates a CollisionDetector message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.safety.CollisionDetector
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.safety.CollisionDetector} CollisionDetector
             */
            CollisionDetector.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.safety.CollisionDetector)
                    return object;
                var message = new $root.lebai.safety.CollisionDetector();
                switch (object.action) {
                default:
                    if (typeof object.action === "number") {
                        message.action = object.action;
                        break;
                    }
                    break;
                case "ESTOP":
                case 0:
                    message.action = 0;
                    break;
                case "PAUSE":
                case 1:
                    message.action = 1;
                    break;
                case "STOP_MOVE":
                case 2:
                    message.action = 2;
                    break;
                case "NONE":
                case 99:
                    message.action = 99;
                    break;
                }
                if (object.pauseTime != null)
                    message.pauseTime = object.pauseTime >>> 0;
                if (object.sensitivity != null)
                    message.sensitivity = object.sensitivity >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a CollisionDetector message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.safety.CollisionDetector
             * @static
             * @param {lebai.safety.CollisionDetector} message CollisionDetector
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CollisionDetector.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.action = options.enums === String ? "ESTOP" : 0;
                    object.pauseTime = 0;
                    object.sensitivity = 0;
                }
                if (message.action != null && message.hasOwnProperty("action"))
                    object.action = options.enums === String ? $root.lebai.safety.CollisionDetectorAction[message.action] === undefined ? message.action : $root.lebai.safety.CollisionDetectorAction[message.action] : message.action;
                if (message.pauseTime != null && message.hasOwnProperty("pauseTime"))
                    object.pauseTime = message.pauseTime;
                if (message.sensitivity != null && message.hasOwnProperty("sensitivity"))
                    object.sensitivity = message.sensitivity;
                return object;
            };

            /**
             * Converts this CollisionDetector to JSON.
             * @function toJSON
             * @memberof lebai.safety.CollisionDetector
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CollisionDetector.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for CollisionDetector
             * @function getTypeUrl
             * @memberof lebai.safety.CollisionDetector
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            CollisionDetector.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.safety.CollisionDetector";
            };

            return CollisionDetector;
        })();

        safety.JointLimit = (function() {

            /**
             * Properties of a JointLimit.
             * @memberof lebai.safety
             * @interface IJointLimit
             * @property {number|null} [minPosition] JointLimit minPosition
             * @property {number|null} [maxPosition] JointLimit maxPosition
             * @property {number|null} [maxA] JointLimit maxA
             * @property {number|null} [maxV] JointLimit maxV
             */

            /**
             * Constructs a new JointLimit.
             * @memberof lebai.safety
             * @classdesc Represents a JointLimit.
             * @implements IJointLimit
             * @constructor
             * @param {lebai.safety.IJointLimit=} [properties] Properties to set
             */
            function JointLimit(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * JointLimit minPosition.
             * @member {number} minPosition
             * @memberof lebai.safety.JointLimit
             * @instance
             */
            JointLimit.prototype.minPosition = 0;

            /**
             * JointLimit maxPosition.
             * @member {number} maxPosition
             * @memberof lebai.safety.JointLimit
             * @instance
             */
            JointLimit.prototype.maxPosition = 0;

            /**
             * JointLimit maxA.
             * @member {number} maxA
             * @memberof lebai.safety.JointLimit
             * @instance
             */
            JointLimit.prototype.maxA = 0;

            /**
             * JointLimit maxV.
             * @member {number} maxV
             * @memberof lebai.safety.JointLimit
             * @instance
             */
            JointLimit.prototype.maxV = 0;

            /**
             * Creates a new JointLimit instance using the specified properties.
             * @function create
             * @memberof lebai.safety.JointLimit
             * @static
             * @param {lebai.safety.IJointLimit=} [properties] Properties to set
             * @returns {lebai.safety.JointLimit} JointLimit instance
             */
            JointLimit.create = function create(properties) {
                return new JointLimit(properties);
            };

            /**
             * Encodes the specified JointLimit message. Does not implicitly {@link lebai.safety.JointLimit.verify|verify} messages.
             * @function encode
             * @memberof lebai.safety.JointLimit
             * @static
             * @param {lebai.safety.IJointLimit} message JointLimit message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            JointLimit.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.minPosition != null && Object.hasOwnProperty.call(message, "minPosition"))
                    writer.uint32(/* id 1, wireType 1 =*/9).double(message.minPosition);
                if (message.maxPosition != null && Object.hasOwnProperty.call(message, "maxPosition"))
                    writer.uint32(/* id 2, wireType 1 =*/17).double(message.maxPosition);
                if (message.maxA != null && Object.hasOwnProperty.call(message, "maxA"))
                    writer.uint32(/* id 3, wireType 1 =*/25).double(message.maxA);
                if (message.maxV != null && Object.hasOwnProperty.call(message, "maxV"))
                    writer.uint32(/* id 4, wireType 1 =*/33).double(message.maxV);
                return writer;
            };

            /**
             * Encodes the specified JointLimit message, length delimited. Does not implicitly {@link lebai.safety.JointLimit.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.safety.JointLimit
             * @static
             * @param {lebai.safety.IJointLimit} message JointLimit message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            JointLimit.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a JointLimit message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.safety.JointLimit
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.safety.JointLimit} JointLimit
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            JointLimit.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.safety.JointLimit();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.minPosition = reader.double();
                            break;
                        }
                    case 2: {
                            message.maxPosition = reader.double();
                            break;
                        }
                    case 3: {
                            message.maxA = reader.double();
                            break;
                        }
                    case 4: {
                            message.maxV = reader.double();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a JointLimit message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.safety.JointLimit
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.safety.JointLimit} JointLimit
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            JointLimit.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a JointLimit message.
             * @function verify
             * @memberof lebai.safety.JointLimit
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            JointLimit.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.minPosition != null && message.hasOwnProperty("minPosition"))
                    if (typeof message.minPosition !== "number")
                        return "minPosition: number expected";
                if (message.maxPosition != null && message.hasOwnProperty("maxPosition"))
                    if (typeof message.maxPosition !== "number")
                        return "maxPosition: number expected";
                if (message.maxA != null && message.hasOwnProperty("maxA"))
                    if (typeof message.maxA !== "number")
                        return "maxA: number expected";
                if (message.maxV != null && message.hasOwnProperty("maxV"))
                    if (typeof message.maxV !== "number")
                        return "maxV: number expected";
                return null;
            };

            /**
             * Creates a JointLimit message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.safety.JointLimit
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.safety.JointLimit} JointLimit
             */
            JointLimit.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.safety.JointLimit)
                    return object;
                var message = new $root.lebai.safety.JointLimit();
                if (object.minPosition != null)
                    message.minPosition = Number(object.minPosition);
                if (object.maxPosition != null)
                    message.maxPosition = Number(object.maxPosition);
                if (object.maxA != null)
                    message.maxA = Number(object.maxA);
                if (object.maxV != null)
                    message.maxV = Number(object.maxV);
                return message;
            };

            /**
             * Creates a plain object from a JointLimit message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.safety.JointLimit
             * @static
             * @param {lebai.safety.JointLimit} message JointLimit
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            JointLimit.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.minPosition = 0;
                    object.maxPosition = 0;
                    object.maxA = 0;
                    object.maxV = 0;
                }
                if (message.minPosition != null && message.hasOwnProperty("minPosition"))
                    object.minPosition = options.json && !isFinite(message.minPosition) ? String(message.minPosition) : message.minPosition;
                if (message.maxPosition != null && message.hasOwnProperty("maxPosition"))
                    object.maxPosition = options.json && !isFinite(message.maxPosition) ? String(message.maxPosition) : message.maxPosition;
                if (message.maxA != null && message.hasOwnProperty("maxA"))
                    object.maxA = options.json && !isFinite(message.maxA) ? String(message.maxA) : message.maxA;
                if (message.maxV != null && message.hasOwnProperty("maxV"))
                    object.maxV = options.json && !isFinite(message.maxV) ? String(message.maxV) : message.maxV;
                return object;
            };

            /**
             * Converts this JointLimit to JSON.
             * @function toJSON
             * @memberof lebai.safety.JointLimit
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            JointLimit.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for JointLimit
             * @function getTypeUrl
             * @memberof lebai.safety.JointLimit
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            JointLimit.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.safety.JointLimit";
            };

            return JointLimit;
        })();

        safety.JointsLimit = (function() {

            /**
             * Properties of a JointsLimit.
             * @memberof lebai.safety
             * @interface IJointsLimit
             * @property {Array.<lebai.safety.IJointLimit>|null} [joints] JointsLimit joints
             */

            /**
             * Constructs a new JointsLimit.
             * @memberof lebai.safety
             * @classdesc Represents a JointsLimit.
             * @implements IJointsLimit
             * @constructor
             * @param {lebai.safety.IJointsLimit=} [properties] Properties to set
             */
            function JointsLimit(properties) {
                this.joints = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * JointsLimit joints.
             * @member {Array.<lebai.safety.IJointLimit>} joints
             * @memberof lebai.safety.JointsLimit
             * @instance
             */
            JointsLimit.prototype.joints = $util.emptyArray;

            /**
             * Creates a new JointsLimit instance using the specified properties.
             * @function create
             * @memberof lebai.safety.JointsLimit
             * @static
             * @param {lebai.safety.IJointsLimit=} [properties] Properties to set
             * @returns {lebai.safety.JointsLimit} JointsLimit instance
             */
            JointsLimit.create = function create(properties) {
                return new JointsLimit(properties);
            };

            /**
             * Encodes the specified JointsLimit message. Does not implicitly {@link lebai.safety.JointsLimit.verify|verify} messages.
             * @function encode
             * @memberof lebai.safety.JointsLimit
             * @static
             * @param {lebai.safety.IJointsLimit} message JointsLimit message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            JointsLimit.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.joints != null && message.joints.length)
                    for (var i = 0; i < message.joints.length; ++i)
                        $root.lebai.safety.JointLimit.encode(message.joints[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified JointsLimit message, length delimited. Does not implicitly {@link lebai.safety.JointsLimit.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.safety.JointsLimit
             * @static
             * @param {lebai.safety.IJointsLimit} message JointsLimit message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            JointsLimit.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a JointsLimit message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.safety.JointsLimit
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.safety.JointsLimit} JointsLimit
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            JointsLimit.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.safety.JointsLimit();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.joints && message.joints.length))
                                message.joints = [];
                            message.joints.push($root.lebai.safety.JointLimit.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a JointsLimit message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.safety.JointsLimit
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.safety.JointsLimit} JointsLimit
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            JointsLimit.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a JointsLimit message.
             * @function verify
             * @memberof lebai.safety.JointsLimit
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            JointsLimit.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.joints != null && message.hasOwnProperty("joints")) {
                    if (!Array.isArray(message.joints))
                        return "joints: array expected";
                    for (var i = 0; i < message.joints.length; ++i) {
                        var error = $root.lebai.safety.JointLimit.verify(message.joints[i]);
                        if (error)
                            return "joints." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a JointsLimit message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.safety.JointsLimit
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.safety.JointsLimit} JointsLimit
             */
            JointsLimit.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.safety.JointsLimit)
                    return object;
                var message = new $root.lebai.safety.JointsLimit();
                if (object.joints) {
                    if (!Array.isArray(object.joints))
                        throw TypeError(".lebai.safety.JointsLimit.joints: array expected");
                    message.joints = [];
                    for (var i = 0; i < object.joints.length; ++i) {
                        if (typeof object.joints[i] !== "object")
                            throw TypeError(".lebai.safety.JointsLimit.joints: object expected");
                        message.joints[i] = $root.lebai.safety.JointLimit.fromObject(object.joints[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a JointsLimit message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.safety.JointsLimit
             * @static
             * @param {lebai.safety.JointsLimit} message JointsLimit
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            JointsLimit.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.joints = [];
                if (message.joints && message.joints.length) {
                    object.joints = [];
                    for (var j = 0; j < message.joints.length; ++j)
                        object.joints[j] = $root.lebai.safety.JointLimit.toObject(message.joints[j], options);
                }
                return object;
            };

            /**
             * Converts this JointsLimit to JSON.
             * @function toJSON
             * @memberof lebai.safety.JointsLimit
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            JointsLimit.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for JointsLimit
             * @function getTypeUrl
             * @memberof lebai.safety.JointsLimit
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            JointsLimit.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.safety.JointsLimit";
            };

            return JointsLimit;
        })();

        safety.CartesianLimit = (function() {

            /**
             * Properties of a CartesianLimit.
             * @memberof lebai.safety
             * @interface ICartesianLimit
             * @property {number|null} [maxA] CartesianLimit maxA
             * @property {number|null} [maxV] CartesianLimit maxV
             * @property {number|null} [eqRadius] CartesianLimit eqRadius
             */

            /**
             * Constructs a new CartesianLimit.
             * @memberof lebai.safety
             * @classdesc Represents a CartesianLimit.
             * @implements ICartesianLimit
             * @constructor
             * @param {lebai.safety.ICartesianLimit=} [properties] Properties to set
             */
            function CartesianLimit(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CartesianLimit maxA.
             * @member {number} maxA
             * @memberof lebai.safety.CartesianLimit
             * @instance
             */
            CartesianLimit.prototype.maxA = 0;

            /**
             * CartesianLimit maxV.
             * @member {number} maxV
             * @memberof lebai.safety.CartesianLimit
             * @instance
             */
            CartesianLimit.prototype.maxV = 0;

            /**
             * CartesianLimit eqRadius.
             * @member {number} eqRadius
             * @memberof lebai.safety.CartesianLimit
             * @instance
             */
            CartesianLimit.prototype.eqRadius = 0;

            /**
             * Creates a new CartesianLimit instance using the specified properties.
             * @function create
             * @memberof lebai.safety.CartesianLimit
             * @static
             * @param {lebai.safety.ICartesianLimit=} [properties] Properties to set
             * @returns {lebai.safety.CartesianLimit} CartesianLimit instance
             */
            CartesianLimit.create = function create(properties) {
                return new CartesianLimit(properties);
            };

            /**
             * Encodes the specified CartesianLimit message. Does not implicitly {@link lebai.safety.CartesianLimit.verify|verify} messages.
             * @function encode
             * @memberof lebai.safety.CartesianLimit
             * @static
             * @param {lebai.safety.ICartesianLimit} message CartesianLimit message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CartesianLimit.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.maxA != null && Object.hasOwnProperty.call(message, "maxA"))
                    writer.uint32(/* id 1, wireType 1 =*/9).double(message.maxA);
                if (message.maxV != null && Object.hasOwnProperty.call(message, "maxV"))
                    writer.uint32(/* id 2, wireType 1 =*/17).double(message.maxV);
                if (message.eqRadius != null && Object.hasOwnProperty.call(message, "eqRadius"))
                    writer.uint32(/* id 3, wireType 1 =*/25).double(message.eqRadius);
                return writer;
            };

            /**
             * Encodes the specified CartesianLimit message, length delimited. Does not implicitly {@link lebai.safety.CartesianLimit.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.safety.CartesianLimit
             * @static
             * @param {lebai.safety.ICartesianLimit} message CartesianLimit message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CartesianLimit.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CartesianLimit message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.safety.CartesianLimit
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.safety.CartesianLimit} CartesianLimit
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CartesianLimit.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.safety.CartesianLimit();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.maxA = reader.double();
                            break;
                        }
                    case 2: {
                            message.maxV = reader.double();
                            break;
                        }
                    case 3: {
                            message.eqRadius = reader.double();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CartesianLimit message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.safety.CartesianLimit
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.safety.CartesianLimit} CartesianLimit
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CartesianLimit.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CartesianLimit message.
             * @function verify
             * @memberof lebai.safety.CartesianLimit
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CartesianLimit.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.maxA != null && message.hasOwnProperty("maxA"))
                    if (typeof message.maxA !== "number")
                        return "maxA: number expected";
                if (message.maxV != null && message.hasOwnProperty("maxV"))
                    if (typeof message.maxV !== "number")
                        return "maxV: number expected";
                if (message.eqRadius != null && message.hasOwnProperty("eqRadius"))
                    if (typeof message.eqRadius !== "number")
                        return "eqRadius: number expected";
                return null;
            };

            /**
             * Creates a CartesianLimit message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.safety.CartesianLimit
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.safety.CartesianLimit} CartesianLimit
             */
            CartesianLimit.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.safety.CartesianLimit)
                    return object;
                var message = new $root.lebai.safety.CartesianLimit();
                if (object.maxA != null)
                    message.maxA = Number(object.maxA);
                if (object.maxV != null)
                    message.maxV = Number(object.maxV);
                if (object.eqRadius != null)
                    message.eqRadius = Number(object.eqRadius);
                return message;
            };

            /**
             * Creates a plain object from a CartesianLimit message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.safety.CartesianLimit
             * @static
             * @param {lebai.safety.CartesianLimit} message CartesianLimit
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CartesianLimit.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.maxA = 0;
                    object.maxV = 0;
                    object.eqRadius = 0;
                }
                if (message.maxA != null && message.hasOwnProperty("maxA"))
                    object.maxA = options.json && !isFinite(message.maxA) ? String(message.maxA) : message.maxA;
                if (message.maxV != null && message.hasOwnProperty("maxV"))
                    object.maxV = options.json && !isFinite(message.maxV) ? String(message.maxV) : message.maxV;
                if (message.eqRadius != null && message.hasOwnProperty("eqRadius"))
                    object.eqRadius = options.json && !isFinite(message.eqRadius) ? String(message.eqRadius) : message.eqRadius;
                return object;
            };

            /**
             * Converts this CartesianLimit to JSON.
             * @function toJSON
             * @memberof lebai.safety.CartesianLimit
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CartesianLimit.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for CartesianLimit
             * @function getTypeUrl
             * @memberof lebai.safety.CartesianLimit
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            CartesianLimit.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.safety.CartesianLimit";
            };

            return CartesianLimit;
        })();

        safety.SafetyService = (function() {

            /**
             * Constructs a new SafetyService service.
             * @memberof lebai.safety
             * @classdesc Represents a SafetyService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function SafetyService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (SafetyService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = SafetyService;

            /**
             * Creates new SafetyService service using the specified rpc implementation.
             * @function create
             * @memberof lebai.safety.SafetyService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {SafetyService} RPC service. Useful where requests and/or responses are streamed.
             */
            SafetyService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link lebai.safety.SafetyService#enableCollisionDetector}.
             * @memberof lebai.safety.SafetyService
             * @typedef EnableCollisionDetectorCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls EnableCollisionDetector.
             * @function enableCollisionDetector
             * @memberof lebai.safety.SafetyService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {lebai.safety.SafetyService.EnableCollisionDetectorCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(SafetyService.prototype.enableCollisionDetector = function enableCollisionDetector(request, callback) {
                return this.rpcCall(enableCollisionDetector, $root.google.protobuf.Empty, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "EnableCollisionDetector" });

            /**
             * Calls EnableCollisionDetector.
             * @function enableCollisionDetector
             * @memberof lebai.safety.SafetyService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.safety.SafetyService#disableCollisionDetector}.
             * @memberof lebai.safety.SafetyService
             * @typedef DisableCollisionDetectorCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls DisableCollisionDetector.
             * @function disableCollisionDetector
             * @memberof lebai.safety.SafetyService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {lebai.safety.SafetyService.DisableCollisionDetectorCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(SafetyService.prototype.disableCollisionDetector = function disableCollisionDetector(request, callback) {
                return this.rpcCall(disableCollisionDetector, $root.google.protobuf.Empty, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "DisableCollisionDetector" });

            /**
             * Calls DisableCollisionDetector.
             * @function disableCollisionDetector
             * @memberof lebai.safety.SafetyService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.safety.SafetyService#setCollisionTorqueDiff}.
             * @memberof lebai.safety.SafetyService
             * @typedef SetCollisionTorqueDiffCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls SetCollisionTorqueDiff.
             * @function setCollisionTorqueDiff
             * @memberof lebai.safety.SafetyService
             * @instance
             * @param {lebai.safety.ICollisionTorqueDiff} request CollisionTorqueDiff message or plain object
             * @param {lebai.safety.SafetyService.SetCollisionTorqueDiffCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(SafetyService.prototype.setCollisionTorqueDiff = function setCollisionTorqueDiff(request, callback) {
                return this.rpcCall(setCollisionTorqueDiff, $root.lebai.safety.CollisionTorqueDiff, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "SetCollisionTorqueDiff" });

            /**
             * Calls SetCollisionTorqueDiff.
             * @function setCollisionTorqueDiff
             * @memberof lebai.safety.SafetyService
             * @instance
             * @param {lebai.safety.ICollisionTorqueDiff} request CollisionTorqueDiff message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.safety.SafetyService#getCollisionTorqueDiff}.
             * @memberof lebai.safety.SafetyService
             * @typedef GetCollisionTorqueDiffCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.safety.CollisionTorqueDiff} [response] CollisionTorqueDiff
             */

            /**
             * Calls GetCollisionTorqueDiff.
             * @function getCollisionTorqueDiff
             * @memberof lebai.safety.SafetyService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {lebai.safety.SafetyService.GetCollisionTorqueDiffCallback} callback Node-style callback called with the error, if any, and CollisionTorqueDiff
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(SafetyService.prototype.getCollisionTorqueDiff = function getCollisionTorqueDiff(request, callback) {
                return this.rpcCall(getCollisionTorqueDiff, $root.google.protobuf.Empty, $root.lebai.safety.CollisionTorqueDiff, request, callback);
            }, "name", { value: "GetCollisionTorqueDiff" });

            /**
             * Calls GetCollisionTorqueDiff.
             * @function getCollisionTorqueDiff
             * @memberof lebai.safety.SafetyService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<lebai.safety.CollisionTorqueDiff>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.safety.SafetyService#setCollisionDetector}.
             * @memberof lebai.safety.SafetyService
             * @typedef SetCollisionDetectorCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls SetCollisionDetector.
             * @function setCollisionDetector
             * @memberof lebai.safety.SafetyService
             * @instance
             * @param {lebai.safety.ICollisionDetector} request CollisionDetector message or plain object
             * @param {lebai.safety.SafetyService.SetCollisionDetectorCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(SafetyService.prototype.setCollisionDetector = function setCollisionDetector(request, callback) {
                return this.rpcCall(setCollisionDetector, $root.lebai.safety.CollisionDetector, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "SetCollisionDetector" });

            /**
             * Calls SetCollisionDetector.
             * @function setCollisionDetector
             * @memberof lebai.safety.SafetyService
             * @instance
             * @param {lebai.safety.ICollisionDetector} request CollisionDetector message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.safety.SafetyService#getCollisionDetector}.
             * @memberof lebai.safety.SafetyService
             * @typedef GetCollisionDetectorCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.safety.CollisionDetector} [response] CollisionDetector
             */

            /**
             * Calls GetCollisionDetector.
             * @function getCollisionDetector
             * @memberof lebai.safety.SafetyService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {lebai.safety.SafetyService.GetCollisionDetectorCallback} callback Node-style callback called with the error, if any, and CollisionDetector
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(SafetyService.prototype.getCollisionDetector = function getCollisionDetector(request, callback) {
                return this.rpcCall(getCollisionDetector, $root.google.protobuf.Empty, $root.lebai.safety.CollisionDetector, request, callback);
            }, "name", { value: "GetCollisionDetector" });

            /**
             * Calls GetCollisionDetector.
             * @function getCollisionDetector
             * @memberof lebai.safety.SafetyService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<lebai.safety.CollisionDetector>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.safety.SafetyService#enableLimit}.
             * @memberof lebai.safety.SafetyService
             * @typedef EnableLimitCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls EnableLimit.
             * @function enableLimit
             * @memberof lebai.safety.SafetyService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {lebai.safety.SafetyService.EnableLimitCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(SafetyService.prototype.enableLimit = function enableLimit(request, callback) {
                return this.rpcCall(enableLimit, $root.google.protobuf.Empty, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "EnableLimit" });

            /**
             * Calls EnableLimit.
             * @function enableLimit
             * @memberof lebai.safety.SafetyService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.safety.SafetyService#disableLimit}.
             * @memberof lebai.safety.SafetyService
             * @typedef DisableLimitCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls DisableLimit.
             * @function disableLimit
             * @memberof lebai.safety.SafetyService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {lebai.safety.SafetyService.DisableLimitCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(SafetyService.prototype.disableLimit = function disableLimit(request, callback) {
                return this.rpcCall(disableLimit, $root.google.protobuf.Empty, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "DisableLimit" });

            /**
             * Calls DisableLimit.
             * @function disableLimit
             * @memberof lebai.safety.SafetyService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.safety.SafetyService#setJointsLimit}.
             * @memberof lebai.safety.SafetyService
             * @typedef SetJointsLimitCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls SetJointsLimit.
             * @function setJointsLimit
             * @memberof lebai.safety.SafetyService
             * @instance
             * @param {lebai.safety.IJointsLimit} request JointsLimit message or plain object
             * @param {lebai.safety.SafetyService.SetJointsLimitCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(SafetyService.prototype.setJointsLimit = function setJointsLimit(request, callback) {
                return this.rpcCall(setJointsLimit, $root.lebai.safety.JointsLimit, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "SetJointsLimit" });

            /**
             * Calls SetJointsLimit.
             * @function setJointsLimit
             * @memberof lebai.safety.SafetyService
             * @instance
             * @param {lebai.safety.IJointsLimit} request JointsLimit message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.safety.SafetyService#getJointsLimit}.
             * @memberof lebai.safety.SafetyService
             * @typedef GetJointsLimitCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.safety.JointsLimit} [response] JointsLimit
             */

            /**
             * Calls GetJointsLimit.
             * @function getJointsLimit
             * @memberof lebai.safety.SafetyService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {lebai.safety.SafetyService.GetJointsLimitCallback} callback Node-style callback called with the error, if any, and JointsLimit
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(SafetyService.prototype.getJointsLimit = function getJointsLimit(request, callback) {
                return this.rpcCall(getJointsLimit, $root.google.protobuf.Empty, $root.lebai.safety.JointsLimit, request, callback);
            }, "name", { value: "GetJointsLimit" });

            /**
             * Calls GetJointsLimit.
             * @function getJointsLimit
             * @memberof lebai.safety.SafetyService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<lebai.safety.JointsLimit>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.safety.SafetyService#setCartLimit}.
             * @memberof lebai.safety.SafetyService
             * @typedef SetCartLimitCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls SetCartLimit.
             * @function setCartLimit
             * @memberof lebai.safety.SafetyService
             * @instance
             * @param {lebai.safety.ICartesianLimit} request CartesianLimit message or plain object
             * @param {lebai.safety.SafetyService.SetCartLimitCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(SafetyService.prototype.setCartLimit = function setCartLimit(request, callback) {
                return this.rpcCall(setCartLimit, $root.lebai.safety.CartesianLimit, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "SetCartLimit" });

            /**
             * Calls SetCartLimit.
             * @function setCartLimit
             * @memberof lebai.safety.SafetyService
             * @instance
             * @param {lebai.safety.ICartesianLimit} request CartesianLimit message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.safety.SafetyService#getCartLimit}.
             * @memberof lebai.safety.SafetyService
             * @typedef GetCartLimitCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.safety.CartesianLimit} [response] CartesianLimit
             */

            /**
             * Calls GetCartLimit.
             * @function getCartLimit
             * @memberof lebai.safety.SafetyService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {lebai.safety.SafetyService.GetCartLimitCallback} callback Node-style callback called with the error, if any, and CartesianLimit
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(SafetyService.prototype.getCartLimit = function getCartLimit(request, callback) {
                return this.rpcCall(getCartLimit, $root.google.protobuf.Empty, $root.lebai.safety.CartesianLimit, request, callback);
            }, "name", { value: "GetCartLimit" });

            /**
             * Calls GetCartLimit.
             * @function getCartLimit
             * @memberof lebai.safety.SafetyService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<lebai.safety.CartesianLimit>} Promise
             * @variation 2
             */

            return SafetyService;
        })();

        return safety;
    })();

    lebai.serial = (function() {

        /**
         * Namespace serial.
         * @memberof lebai
         * @namespace
         */
        var serial = {};

        serial.SetSerialTimeoutRequest = (function() {

            /**
             * Properties of a SetSerialTimeoutRequest.
             * @memberof lebai.serial
             * @interface ISetSerialTimeoutRequest
             * @property {string|null} [device] SetSerialTimeoutRequest device
             * @property {number|null} [timeout] SetSerialTimeoutRequest timeout
             */

            /**
             * Constructs a new SetSerialTimeoutRequest.
             * @memberof lebai.serial
             * @classdesc Represents a SetSerialTimeoutRequest.
             * @implements ISetSerialTimeoutRequest
             * @constructor
             * @param {lebai.serial.ISetSerialTimeoutRequest=} [properties] Properties to set
             */
            function SetSerialTimeoutRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SetSerialTimeoutRequest device.
             * @member {string} device
             * @memberof lebai.serial.SetSerialTimeoutRequest
             * @instance
             */
            SetSerialTimeoutRequest.prototype.device = "";

            /**
             * SetSerialTimeoutRequest timeout.
             * @member {number} timeout
             * @memberof lebai.serial.SetSerialTimeoutRequest
             * @instance
             */
            SetSerialTimeoutRequest.prototype.timeout = 0;

            /**
             * Creates a new SetSerialTimeoutRequest instance using the specified properties.
             * @function create
             * @memberof lebai.serial.SetSerialTimeoutRequest
             * @static
             * @param {lebai.serial.ISetSerialTimeoutRequest=} [properties] Properties to set
             * @returns {lebai.serial.SetSerialTimeoutRequest} SetSerialTimeoutRequest instance
             */
            SetSerialTimeoutRequest.create = function create(properties) {
                return new SetSerialTimeoutRequest(properties);
            };

            /**
             * Encodes the specified SetSerialTimeoutRequest message. Does not implicitly {@link lebai.serial.SetSerialTimeoutRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.serial.SetSerialTimeoutRequest
             * @static
             * @param {lebai.serial.ISetSerialTimeoutRequest} message SetSerialTimeoutRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetSerialTimeoutRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.device != null && Object.hasOwnProperty.call(message, "device"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.device);
                if (message.timeout != null && Object.hasOwnProperty.call(message, "timeout"))
                    writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.timeout);
                return writer;
            };

            /**
             * Encodes the specified SetSerialTimeoutRequest message, length delimited. Does not implicitly {@link lebai.serial.SetSerialTimeoutRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.serial.SetSerialTimeoutRequest
             * @static
             * @param {lebai.serial.ISetSerialTimeoutRequest} message SetSerialTimeoutRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetSerialTimeoutRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetSerialTimeoutRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.serial.SetSerialTimeoutRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.serial.SetSerialTimeoutRequest} SetSerialTimeoutRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetSerialTimeoutRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.serial.SetSerialTimeoutRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.device = reader.string();
                            break;
                        }
                    case 11: {
                            message.timeout = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetSerialTimeoutRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.serial.SetSerialTimeoutRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.serial.SetSerialTimeoutRequest} SetSerialTimeoutRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetSerialTimeoutRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetSerialTimeoutRequest message.
             * @function verify
             * @memberof lebai.serial.SetSerialTimeoutRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetSerialTimeoutRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.device != null && message.hasOwnProperty("device"))
                    if (!$util.isString(message.device))
                        return "device: string expected";
                if (message.timeout != null && message.hasOwnProperty("timeout"))
                    if (!$util.isInteger(message.timeout))
                        return "timeout: integer expected";
                return null;
            };

            /**
             * Creates a SetSerialTimeoutRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.serial.SetSerialTimeoutRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.serial.SetSerialTimeoutRequest} SetSerialTimeoutRequest
             */
            SetSerialTimeoutRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.serial.SetSerialTimeoutRequest)
                    return object;
                var message = new $root.lebai.serial.SetSerialTimeoutRequest();
                if (object.device != null)
                    message.device = String(object.device);
                if (object.timeout != null)
                    message.timeout = object.timeout >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a SetSerialTimeoutRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.serial.SetSerialTimeoutRequest
             * @static
             * @param {lebai.serial.SetSerialTimeoutRequest} message SetSerialTimeoutRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetSerialTimeoutRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.device = "";
                    object.timeout = 0;
                }
                if (message.device != null && message.hasOwnProperty("device"))
                    object.device = message.device;
                if (message.timeout != null && message.hasOwnProperty("timeout"))
                    object.timeout = message.timeout;
                return object;
            };

            /**
             * Converts this SetSerialTimeoutRequest to JSON.
             * @function toJSON
             * @memberof lebai.serial.SetSerialTimeoutRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetSerialTimeoutRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetSerialTimeoutRequest
             * @function getTypeUrl
             * @memberof lebai.serial.SetSerialTimeoutRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetSerialTimeoutRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.serial.SetSerialTimeoutRequest";
            };

            return SetSerialTimeoutRequest;
        })();

        serial.SetSerialBaudRateRequest = (function() {

            /**
             * Properties of a SetSerialBaudRateRequest.
             * @memberof lebai.serial
             * @interface ISetSerialBaudRateRequest
             * @property {string|null} [device] SetSerialBaudRateRequest device
             * @property {number|null} [baudRate] SetSerialBaudRateRequest baudRate
             */

            /**
             * Constructs a new SetSerialBaudRateRequest.
             * @memberof lebai.serial
             * @classdesc Represents a SetSerialBaudRateRequest.
             * @implements ISetSerialBaudRateRequest
             * @constructor
             * @param {lebai.serial.ISetSerialBaudRateRequest=} [properties] Properties to set
             */
            function SetSerialBaudRateRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SetSerialBaudRateRequest device.
             * @member {string} device
             * @memberof lebai.serial.SetSerialBaudRateRequest
             * @instance
             */
            SetSerialBaudRateRequest.prototype.device = "";

            /**
             * SetSerialBaudRateRequest baudRate.
             * @member {number} baudRate
             * @memberof lebai.serial.SetSerialBaudRateRequest
             * @instance
             */
            SetSerialBaudRateRequest.prototype.baudRate = 0;

            /**
             * Creates a new SetSerialBaudRateRequest instance using the specified properties.
             * @function create
             * @memberof lebai.serial.SetSerialBaudRateRequest
             * @static
             * @param {lebai.serial.ISetSerialBaudRateRequest=} [properties] Properties to set
             * @returns {lebai.serial.SetSerialBaudRateRequest} SetSerialBaudRateRequest instance
             */
            SetSerialBaudRateRequest.create = function create(properties) {
                return new SetSerialBaudRateRequest(properties);
            };

            /**
             * Encodes the specified SetSerialBaudRateRequest message. Does not implicitly {@link lebai.serial.SetSerialBaudRateRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.serial.SetSerialBaudRateRequest
             * @static
             * @param {lebai.serial.ISetSerialBaudRateRequest} message SetSerialBaudRateRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetSerialBaudRateRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.device != null && Object.hasOwnProperty.call(message, "device"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.device);
                if (message.baudRate != null && Object.hasOwnProperty.call(message, "baudRate"))
                    writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.baudRate);
                return writer;
            };

            /**
             * Encodes the specified SetSerialBaudRateRequest message, length delimited. Does not implicitly {@link lebai.serial.SetSerialBaudRateRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.serial.SetSerialBaudRateRequest
             * @static
             * @param {lebai.serial.ISetSerialBaudRateRequest} message SetSerialBaudRateRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetSerialBaudRateRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetSerialBaudRateRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.serial.SetSerialBaudRateRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.serial.SetSerialBaudRateRequest} SetSerialBaudRateRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetSerialBaudRateRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.serial.SetSerialBaudRateRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.device = reader.string();
                            break;
                        }
                    case 11: {
                            message.baudRate = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetSerialBaudRateRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.serial.SetSerialBaudRateRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.serial.SetSerialBaudRateRequest} SetSerialBaudRateRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetSerialBaudRateRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetSerialBaudRateRequest message.
             * @function verify
             * @memberof lebai.serial.SetSerialBaudRateRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetSerialBaudRateRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.device != null && message.hasOwnProperty("device"))
                    if (!$util.isString(message.device))
                        return "device: string expected";
                if (message.baudRate != null && message.hasOwnProperty("baudRate"))
                    if (!$util.isInteger(message.baudRate))
                        return "baudRate: integer expected";
                return null;
            };

            /**
             * Creates a SetSerialBaudRateRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.serial.SetSerialBaudRateRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.serial.SetSerialBaudRateRequest} SetSerialBaudRateRequest
             */
            SetSerialBaudRateRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.serial.SetSerialBaudRateRequest)
                    return object;
                var message = new $root.lebai.serial.SetSerialBaudRateRequest();
                if (object.device != null)
                    message.device = String(object.device);
                if (object.baudRate != null)
                    message.baudRate = object.baudRate >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a SetSerialBaudRateRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.serial.SetSerialBaudRateRequest
             * @static
             * @param {lebai.serial.SetSerialBaudRateRequest} message SetSerialBaudRateRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetSerialBaudRateRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.device = "";
                    object.baudRate = 0;
                }
                if (message.device != null && message.hasOwnProperty("device"))
                    object.device = message.device;
                if (message.baudRate != null && message.hasOwnProperty("baudRate"))
                    object.baudRate = message.baudRate;
                return object;
            };

            /**
             * Converts this SetSerialBaudRateRequest to JSON.
             * @function toJSON
             * @memberof lebai.serial.SetSerialBaudRateRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetSerialBaudRateRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetSerialBaudRateRequest
             * @function getTypeUrl
             * @memberof lebai.serial.SetSerialBaudRateRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetSerialBaudRateRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.serial.SetSerialBaudRateRequest";
            };

            return SetSerialBaudRateRequest;
        })();

        /**
         * Parity enum.
         * @name lebai.serial.Parity
         * @enum {number}
         * @property {number} None=0 None value
         * @property {number} Odd=1 Odd value
         * @property {number} Even=2 Even value
         */
        serial.Parity = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "None"] = 0;
            values[valuesById[1] = "Odd"] = 1;
            values[valuesById[2] = "Even"] = 2;
            return values;
        })();

        serial.SetSerialParityRequest = (function() {

            /**
             * Properties of a SetSerialParityRequest.
             * @memberof lebai.serial
             * @interface ISetSerialParityRequest
             * @property {string|null} [device] SetSerialParityRequest device
             * @property {lebai.serial.Parity|null} [parity] SetSerialParityRequest parity
             */

            /**
             * Constructs a new SetSerialParityRequest.
             * @memberof lebai.serial
             * @classdesc Represents a SetSerialParityRequest.
             * @implements ISetSerialParityRequest
             * @constructor
             * @param {lebai.serial.ISetSerialParityRequest=} [properties] Properties to set
             */
            function SetSerialParityRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SetSerialParityRequest device.
             * @member {string} device
             * @memberof lebai.serial.SetSerialParityRequest
             * @instance
             */
            SetSerialParityRequest.prototype.device = "";

            /**
             * SetSerialParityRequest parity.
             * @member {lebai.serial.Parity} parity
             * @memberof lebai.serial.SetSerialParityRequest
             * @instance
             */
            SetSerialParityRequest.prototype.parity = 0;

            /**
             * Creates a new SetSerialParityRequest instance using the specified properties.
             * @function create
             * @memberof lebai.serial.SetSerialParityRequest
             * @static
             * @param {lebai.serial.ISetSerialParityRequest=} [properties] Properties to set
             * @returns {lebai.serial.SetSerialParityRequest} SetSerialParityRequest instance
             */
            SetSerialParityRequest.create = function create(properties) {
                return new SetSerialParityRequest(properties);
            };

            /**
             * Encodes the specified SetSerialParityRequest message. Does not implicitly {@link lebai.serial.SetSerialParityRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.serial.SetSerialParityRequest
             * @static
             * @param {lebai.serial.ISetSerialParityRequest} message SetSerialParityRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetSerialParityRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.device != null && Object.hasOwnProperty.call(message, "device"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.device);
                if (message.parity != null && Object.hasOwnProperty.call(message, "parity"))
                    writer.uint32(/* id 11, wireType 0 =*/88).int32(message.parity);
                return writer;
            };

            /**
             * Encodes the specified SetSerialParityRequest message, length delimited. Does not implicitly {@link lebai.serial.SetSerialParityRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.serial.SetSerialParityRequest
             * @static
             * @param {lebai.serial.ISetSerialParityRequest} message SetSerialParityRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetSerialParityRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetSerialParityRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.serial.SetSerialParityRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.serial.SetSerialParityRequest} SetSerialParityRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetSerialParityRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.serial.SetSerialParityRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.device = reader.string();
                            break;
                        }
                    case 11: {
                            message.parity = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetSerialParityRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.serial.SetSerialParityRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.serial.SetSerialParityRequest} SetSerialParityRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetSerialParityRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetSerialParityRequest message.
             * @function verify
             * @memberof lebai.serial.SetSerialParityRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetSerialParityRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.device != null && message.hasOwnProperty("device"))
                    if (!$util.isString(message.device))
                        return "device: string expected";
                if (message.parity != null && message.hasOwnProperty("parity"))
                    switch (message.parity) {
                    default:
                        return "parity: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                return null;
            };

            /**
             * Creates a SetSerialParityRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.serial.SetSerialParityRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.serial.SetSerialParityRequest} SetSerialParityRequest
             */
            SetSerialParityRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.serial.SetSerialParityRequest)
                    return object;
                var message = new $root.lebai.serial.SetSerialParityRequest();
                if (object.device != null)
                    message.device = String(object.device);
                switch (object.parity) {
                default:
                    if (typeof object.parity === "number") {
                        message.parity = object.parity;
                        break;
                    }
                    break;
                case "None":
                case 0:
                    message.parity = 0;
                    break;
                case "Odd":
                case 1:
                    message.parity = 1;
                    break;
                case "Even":
                case 2:
                    message.parity = 2;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a SetSerialParityRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.serial.SetSerialParityRequest
             * @static
             * @param {lebai.serial.SetSerialParityRequest} message SetSerialParityRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetSerialParityRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.device = "";
                    object.parity = options.enums === String ? "None" : 0;
                }
                if (message.device != null && message.hasOwnProperty("device"))
                    object.device = message.device;
                if (message.parity != null && message.hasOwnProperty("parity"))
                    object.parity = options.enums === String ? $root.lebai.serial.Parity[message.parity] === undefined ? message.parity : $root.lebai.serial.Parity[message.parity] : message.parity;
                return object;
            };

            /**
             * Converts this SetSerialParityRequest to JSON.
             * @function toJSON
             * @memberof lebai.serial.SetSerialParityRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetSerialParityRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetSerialParityRequest
             * @function getTypeUrl
             * @memberof lebai.serial.SetSerialParityRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetSerialParityRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.serial.SetSerialParityRequest";
            };

            return SetSerialParityRequest;
        })();

        serial.WriteSerialRequest = (function() {

            /**
             * Properties of a WriteSerialRequest.
             * @memberof lebai.serial
             * @interface IWriteSerialRequest
             * @property {string|null} [device] WriteSerialRequest device
             * @property {Array.<number>|null} [data] WriteSerialRequest data
             */

            /**
             * Constructs a new WriteSerialRequest.
             * @memberof lebai.serial
             * @classdesc Represents a WriteSerialRequest.
             * @implements IWriteSerialRequest
             * @constructor
             * @param {lebai.serial.IWriteSerialRequest=} [properties] Properties to set
             */
            function WriteSerialRequest(properties) {
                this.data = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WriteSerialRequest device.
             * @member {string} device
             * @memberof lebai.serial.WriteSerialRequest
             * @instance
             */
            WriteSerialRequest.prototype.device = "";

            /**
             * WriteSerialRequest data.
             * @member {Array.<number>} data
             * @memberof lebai.serial.WriteSerialRequest
             * @instance
             */
            WriteSerialRequest.prototype.data = $util.emptyArray;

            /**
             * Creates a new WriteSerialRequest instance using the specified properties.
             * @function create
             * @memberof lebai.serial.WriteSerialRequest
             * @static
             * @param {lebai.serial.IWriteSerialRequest=} [properties] Properties to set
             * @returns {lebai.serial.WriteSerialRequest} WriteSerialRequest instance
             */
            WriteSerialRequest.create = function create(properties) {
                return new WriteSerialRequest(properties);
            };

            /**
             * Encodes the specified WriteSerialRequest message. Does not implicitly {@link lebai.serial.WriteSerialRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.serial.WriteSerialRequest
             * @static
             * @param {lebai.serial.IWriteSerialRequest} message WriteSerialRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteSerialRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.device != null && Object.hasOwnProperty.call(message, "device"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.device);
                if (message.data != null && message.data.length) {
                    writer.uint32(/* id 11, wireType 2 =*/90).fork();
                    for (var i = 0; i < message.data.length; ++i)
                        writer.uint32(message.data[i]);
                    writer.ldelim();
                }
                return writer;
            };

            /**
             * Encodes the specified WriteSerialRequest message, length delimited. Does not implicitly {@link lebai.serial.WriteSerialRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.serial.WriteSerialRequest
             * @static
             * @param {lebai.serial.IWriteSerialRequest} message WriteSerialRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WriteSerialRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WriteSerialRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.serial.WriteSerialRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.serial.WriteSerialRequest} WriteSerialRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteSerialRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.serial.WriteSerialRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.device = reader.string();
                            break;
                        }
                    case 11: {
                            if (!(message.data && message.data.length))
                                message.data = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.data.push(reader.uint32());
                            } else
                                message.data.push(reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WriteSerialRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.serial.WriteSerialRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.serial.WriteSerialRequest} WriteSerialRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WriteSerialRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WriteSerialRequest message.
             * @function verify
             * @memberof lebai.serial.WriteSerialRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WriteSerialRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.device != null && message.hasOwnProperty("device"))
                    if (!$util.isString(message.device))
                        return "device: string expected";
                if (message.data != null && message.hasOwnProperty("data")) {
                    if (!Array.isArray(message.data))
                        return "data: array expected";
                    for (var i = 0; i < message.data.length; ++i)
                        if (!$util.isInteger(message.data[i]))
                            return "data: integer[] expected";
                }
                return null;
            };

            /**
             * Creates a WriteSerialRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.serial.WriteSerialRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.serial.WriteSerialRequest} WriteSerialRequest
             */
            WriteSerialRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.serial.WriteSerialRequest)
                    return object;
                var message = new $root.lebai.serial.WriteSerialRequest();
                if (object.device != null)
                    message.device = String(object.device);
                if (object.data) {
                    if (!Array.isArray(object.data))
                        throw TypeError(".lebai.serial.WriteSerialRequest.data: array expected");
                    message.data = [];
                    for (var i = 0; i < object.data.length; ++i)
                        message.data[i] = object.data[i] >>> 0;
                }
                return message;
            };

            /**
             * Creates a plain object from a WriteSerialRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.serial.WriteSerialRequest
             * @static
             * @param {lebai.serial.WriteSerialRequest} message WriteSerialRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WriteSerialRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.data = [];
                if (options.defaults)
                    object.device = "";
                if (message.device != null && message.hasOwnProperty("device"))
                    object.device = message.device;
                if (message.data && message.data.length) {
                    object.data = [];
                    for (var j = 0; j < message.data.length; ++j)
                        object.data[j] = message.data[j];
                }
                return object;
            };

            /**
             * Converts this WriteSerialRequest to JSON.
             * @function toJSON
             * @memberof lebai.serial.WriteSerialRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WriteSerialRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for WriteSerialRequest
             * @function getTypeUrl
             * @memberof lebai.serial.WriteSerialRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            WriteSerialRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.serial.WriteSerialRequest";
            };

            return WriteSerialRequest;
        })();

        serial.ReadSerialRequest = (function() {

            /**
             * Properties of a ReadSerialRequest.
             * @memberof lebai.serial
             * @interface IReadSerialRequest
             * @property {string|null} [device] ReadSerialRequest device
             * @property {number|null} [len] ReadSerialRequest len
             */

            /**
             * Constructs a new ReadSerialRequest.
             * @memberof lebai.serial
             * @classdesc Represents a ReadSerialRequest.
             * @implements IReadSerialRequest
             * @constructor
             * @param {lebai.serial.IReadSerialRequest=} [properties] Properties to set
             */
            function ReadSerialRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadSerialRequest device.
             * @member {string} device
             * @memberof lebai.serial.ReadSerialRequest
             * @instance
             */
            ReadSerialRequest.prototype.device = "";

            /**
             * ReadSerialRequest len.
             * @member {number} len
             * @memberof lebai.serial.ReadSerialRequest
             * @instance
             */
            ReadSerialRequest.prototype.len = 0;

            /**
             * Creates a new ReadSerialRequest instance using the specified properties.
             * @function create
             * @memberof lebai.serial.ReadSerialRequest
             * @static
             * @param {lebai.serial.IReadSerialRequest=} [properties] Properties to set
             * @returns {lebai.serial.ReadSerialRequest} ReadSerialRequest instance
             */
            ReadSerialRequest.create = function create(properties) {
                return new ReadSerialRequest(properties);
            };

            /**
             * Encodes the specified ReadSerialRequest message. Does not implicitly {@link lebai.serial.ReadSerialRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.serial.ReadSerialRequest
             * @static
             * @param {lebai.serial.IReadSerialRequest} message ReadSerialRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadSerialRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.device != null && Object.hasOwnProperty.call(message, "device"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.device);
                if (message.len != null && Object.hasOwnProperty.call(message, "len"))
                    writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.len);
                return writer;
            };

            /**
             * Encodes the specified ReadSerialRequest message, length delimited. Does not implicitly {@link lebai.serial.ReadSerialRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.serial.ReadSerialRequest
             * @static
             * @param {lebai.serial.IReadSerialRequest} message ReadSerialRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadSerialRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadSerialRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.serial.ReadSerialRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.serial.ReadSerialRequest} ReadSerialRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadSerialRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.serial.ReadSerialRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.device = reader.string();
                            break;
                        }
                    case 11: {
                            message.len = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadSerialRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.serial.ReadSerialRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.serial.ReadSerialRequest} ReadSerialRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadSerialRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadSerialRequest message.
             * @function verify
             * @memberof lebai.serial.ReadSerialRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadSerialRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.device != null && message.hasOwnProperty("device"))
                    if (!$util.isString(message.device))
                        return "device: string expected";
                if (message.len != null && message.hasOwnProperty("len"))
                    if (!$util.isInteger(message.len))
                        return "len: integer expected";
                return null;
            };

            /**
             * Creates a ReadSerialRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.serial.ReadSerialRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.serial.ReadSerialRequest} ReadSerialRequest
             */
            ReadSerialRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.serial.ReadSerialRequest)
                    return object;
                var message = new $root.lebai.serial.ReadSerialRequest();
                if (object.device != null)
                    message.device = String(object.device);
                if (object.len != null)
                    message.len = object.len >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a ReadSerialRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.serial.ReadSerialRequest
             * @static
             * @param {lebai.serial.ReadSerialRequest} message ReadSerialRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadSerialRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.device = "";
                    object.len = 0;
                }
                if (message.device != null && message.hasOwnProperty("device"))
                    object.device = message.device;
                if (message.len != null && message.hasOwnProperty("len"))
                    object.len = message.len;
                return object;
            };

            /**
             * Converts this ReadSerialRequest to JSON.
             * @function toJSON
             * @memberof lebai.serial.ReadSerialRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadSerialRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ReadSerialRequest
             * @function getTypeUrl
             * @memberof lebai.serial.ReadSerialRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ReadSerialRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.serial.ReadSerialRequest";
            };

            return ReadSerialRequest;
        })();

        serial.ReadSerialResponse = (function() {

            /**
             * Properties of a ReadSerialResponse.
             * @memberof lebai.serial
             * @interface IReadSerialResponse
             * @property {Array.<number>|null} [data] ReadSerialResponse data
             */

            /**
             * Constructs a new ReadSerialResponse.
             * @memberof lebai.serial
             * @classdesc Represents a ReadSerialResponse.
             * @implements IReadSerialResponse
             * @constructor
             * @param {lebai.serial.IReadSerialResponse=} [properties] Properties to set
             */
            function ReadSerialResponse(properties) {
                this.data = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadSerialResponse data.
             * @member {Array.<number>} data
             * @memberof lebai.serial.ReadSerialResponse
             * @instance
             */
            ReadSerialResponse.prototype.data = $util.emptyArray;

            /**
             * Creates a new ReadSerialResponse instance using the specified properties.
             * @function create
             * @memberof lebai.serial.ReadSerialResponse
             * @static
             * @param {lebai.serial.IReadSerialResponse=} [properties] Properties to set
             * @returns {lebai.serial.ReadSerialResponse} ReadSerialResponse instance
             */
            ReadSerialResponse.create = function create(properties) {
                return new ReadSerialResponse(properties);
            };

            /**
             * Encodes the specified ReadSerialResponse message. Does not implicitly {@link lebai.serial.ReadSerialResponse.verify|verify} messages.
             * @function encode
             * @memberof lebai.serial.ReadSerialResponse
             * @static
             * @param {lebai.serial.IReadSerialResponse} message ReadSerialResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadSerialResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.data != null && message.data.length) {
                    writer.uint32(/* id 11, wireType 2 =*/90).fork();
                    for (var i = 0; i < message.data.length; ++i)
                        writer.uint32(message.data[i]);
                    writer.ldelim();
                }
                return writer;
            };

            /**
             * Encodes the specified ReadSerialResponse message, length delimited. Does not implicitly {@link lebai.serial.ReadSerialResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.serial.ReadSerialResponse
             * @static
             * @param {lebai.serial.IReadSerialResponse} message ReadSerialResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadSerialResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadSerialResponse message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.serial.ReadSerialResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.serial.ReadSerialResponse} ReadSerialResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadSerialResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.serial.ReadSerialResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 11: {
                            if (!(message.data && message.data.length))
                                message.data = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.data.push(reader.uint32());
                            } else
                                message.data.push(reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadSerialResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.serial.ReadSerialResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.serial.ReadSerialResponse} ReadSerialResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadSerialResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadSerialResponse message.
             * @function verify
             * @memberof lebai.serial.ReadSerialResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadSerialResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.data != null && message.hasOwnProperty("data")) {
                    if (!Array.isArray(message.data))
                        return "data: array expected";
                    for (var i = 0; i < message.data.length; ++i)
                        if (!$util.isInteger(message.data[i]))
                            return "data: integer[] expected";
                }
                return null;
            };

            /**
             * Creates a ReadSerialResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.serial.ReadSerialResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.serial.ReadSerialResponse} ReadSerialResponse
             */
            ReadSerialResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.serial.ReadSerialResponse)
                    return object;
                var message = new $root.lebai.serial.ReadSerialResponse();
                if (object.data) {
                    if (!Array.isArray(object.data))
                        throw TypeError(".lebai.serial.ReadSerialResponse.data: array expected");
                    message.data = [];
                    for (var i = 0; i < object.data.length; ++i)
                        message.data[i] = object.data[i] >>> 0;
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadSerialResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.serial.ReadSerialResponse
             * @static
             * @param {lebai.serial.ReadSerialResponse} message ReadSerialResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadSerialResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.data = [];
                if (message.data && message.data.length) {
                    object.data = [];
                    for (var j = 0; j < message.data.length; ++j)
                        object.data[j] = message.data[j];
                }
                return object;
            };

            /**
             * Converts this ReadSerialResponse to JSON.
             * @function toJSON
             * @memberof lebai.serial.ReadSerialResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadSerialResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ReadSerialResponse
             * @function getTypeUrl
             * @memberof lebai.serial.ReadSerialResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ReadSerialResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.serial.ReadSerialResponse";
            };

            return ReadSerialResponse;
        })();

        serial.SerialService = (function() {

            /**
             * Constructs a new SerialService service.
             * @memberof lebai.serial
             * @classdesc Represents a SerialService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function SerialService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (SerialService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = SerialService;

            /**
             * Creates new SerialService service using the specified rpc implementation.
             * @function create
             * @memberof lebai.serial.SerialService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {SerialService} RPC service. Useful where requests and/or responses are streamed.
             */
            SerialService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link lebai.serial.SerialService#setSerialTimeout}.
             * @memberof lebai.serial.SerialService
             * @typedef SetSerialTimeoutCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls SetSerialTimeout.
             * @function setSerialTimeout
             * @memberof lebai.serial.SerialService
             * @instance
             * @param {lebai.serial.ISetSerialTimeoutRequest} request SetSerialTimeoutRequest message or plain object
             * @param {lebai.serial.SerialService.SetSerialTimeoutCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(SerialService.prototype.setSerialTimeout = function setSerialTimeout(request, callback) {
                return this.rpcCall(setSerialTimeout, $root.lebai.serial.SetSerialTimeoutRequest, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "SetSerialTimeout" });

            /**
             * Calls SetSerialTimeout.
             * @function setSerialTimeout
             * @memberof lebai.serial.SerialService
             * @instance
             * @param {lebai.serial.ISetSerialTimeoutRequest} request SetSerialTimeoutRequest message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.serial.SerialService#setSerialBaudRate}.
             * @memberof lebai.serial.SerialService
             * @typedef SetSerialBaudRateCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls SetSerialBaudRate.
             * @function setSerialBaudRate
             * @memberof lebai.serial.SerialService
             * @instance
             * @param {lebai.serial.ISetSerialBaudRateRequest} request SetSerialBaudRateRequest message or plain object
             * @param {lebai.serial.SerialService.SetSerialBaudRateCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(SerialService.prototype.setSerialBaudRate = function setSerialBaudRate(request, callback) {
                return this.rpcCall(setSerialBaudRate, $root.lebai.serial.SetSerialBaudRateRequest, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "SetSerialBaudRate" });

            /**
             * Calls SetSerialBaudRate.
             * @function setSerialBaudRate
             * @memberof lebai.serial.SerialService
             * @instance
             * @param {lebai.serial.ISetSerialBaudRateRequest} request SetSerialBaudRateRequest message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.serial.SerialService#setSerialParity}.
             * @memberof lebai.serial.SerialService
             * @typedef SetSerialParityCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls SetSerialParity.
             * @function setSerialParity
             * @memberof lebai.serial.SerialService
             * @instance
             * @param {lebai.serial.ISetSerialParityRequest} request SetSerialParityRequest message or plain object
             * @param {lebai.serial.SerialService.SetSerialParityCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(SerialService.prototype.setSerialParity = function setSerialParity(request, callback) {
                return this.rpcCall(setSerialParity, $root.lebai.serial.SetSerialParityRequest, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "SetSerialParity" });

            /**
             * Calls SetSerialParity.
             * @function setSerialParity
             * @memberof lebai.serial.SerialService
             * @instance
             * @param {lebai.serial.ISetSerialParityRequest} request SetSerialParityRequest message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.serial.SerialService#writeSerial}.
             * @memberof lebai.serial.SerialService
             * @typedef WriteSerialCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls WriteSerial.
             * @function writeSerial
             * @memberof lebai.serial.SerialService
             * @instance
             * @param {lebai.serial.IWriteSerialRequest} request WriteSerialRequest message or plain object
             * @param {lebai.serial.SerialService.WriteSerialCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(SerialService.prototype.writeSerial = function writeSerial(request, callback) {
                return this.rpcCall(writeSerial, $root.lebai.serial.WriteSerialRequest, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "WriteSerial" });

            /**
             * Calls WriteSerial.
             * @function writeSerial
             * @memberof lebai.serial.SerialService
             * @instance
             * @param {lebai.serial.IWriteSerialRequest} request WriteSerialRequest message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.serial.SerialService#readSerial}.
             * @memberof lebai.serial.SerialService
             * @typedef ReadSerialCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.serial.ReadSerialResponse} [response] ReadSerialResponse
             */

            /**
             * Calls ReadSerial.
             * @function readSerial
             * @memberof lebai.serial.SerialService
             * @instance
             * @param {lebai.serial.IReadSerialRequest} request ReadSerialRequest message or plain object
             * @param {lebai.serial.SerialService.ReadSerialCallback} callback Node-style callback called with the error, if any, and ReadSerialResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(SerialService.prototype.readSerial = function readSerial(request, callback) {
                return this.rpcCall(readSerial, $root.lebai.serial.ReadSerialRequest, $root.lebai.serial.ReadSerialResponse, request, callback);
            }, "name", { value: "ReadSerial" });

            /**
             * Calls ReadSerial.
             * @function readSerial
             * @memberof lebai.serial.SerialService
             * @instance
             * @param {lebai.serial.IReadSerialRequest} request ReadSerialRequest message or plain object
             * @returns {Promise<lebai.serial.ReadSerialResponse>} Promise
             * @variation 2
             */

            return SerialService;
        })();

        return serial;
    })();

    lebai.shortcut = (function() {

        /**
         * Namespace shortcut.
         * @memberof lebai
         * @namespace
         */
        var shortcut = {};

        shortcut.ShortcutIndex = (function() {

            /**
             * Properties of a ShortcutIndex.
             * @memberof lebai.shortcut
             * @interface IShortcutIndex
             * @property {number|null} [id] ShortcutIndex id
             */

            /**
             * Constructs a new ShortcutIndex.
             * @memberof lebai.shortcut
             * @classdesc Represents a ShortcutIndex.
             * @implements IShortcutIndex
             * @constructor
             * @param {lebai.shortcut.IShortcutIndex=} [properties] Properties to set
             */
            function ShortcutIndex(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ShortcutIndex id.
             * @member {number} id
             * @memberof lebai.shortcut.ShortcutIndex
             * @instance
             */
            ShortcutIndex.prototype.id = 0;

            /**
             * Creates a new ShortcutIndex instance using the specified properties.
             * @function create
             * @memberof lebai.shortcut.ShortcutIndex
             * @static
             * @param {lebai.shortcut.IShortcutIndex=} [properties] Properties to set
             * @returns {lebai.shortcut.ShortcutIndex} ShortcutIndex instance
             */
            ShortcutIndex.create = function create(properties) {
                return new ShortcutIndex(properties);
            };

            /**
             * Encodes the specified ShortcutIndex message. Does not implicitly {@link lebai.shortcut.ShortcutIndex.verify|verify} messages.
             * @function encode
             * @memberof lebai.shortcut.ShortcutIndex
             * @static
             * @param {lebai.shortcut.IShortcutIndex} message ShortcutIndex message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ShortcutIndex.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
                return writer;
            };

            /**
             * Encodes the specified ShortcutIndex message, length delimited. Does not implicitly {@link lebai.shortcut.ShortcutIndex.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.shortcut.ShortcutIndex
             * @static
             * @param {lebai.shortcut.IShortcutIndex} message ShortcutIndex message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ShortcutIndex.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ShortcutIndex message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.shortcut.ShortcutIndex
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.shortcut.ShortcutIndex} ShortcutIndex
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ShortcutIndex.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.shortcut.ShortcutIndex();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.id = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ShortcutIndex message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.shortcut.ShortcutIndex
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.shortcut.ShortcutIndex} ShortcutIndex
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ShortcutIndex.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ShortcutIndex message.
             * @function verify
             * @memberof lebai.shortcut.ShortcutIndex
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ShortcutIndex.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id))
                        return "id: integer expected";
                return null;
            };

            /**
             * Creates a ShortcutIndex message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.shortcut.ShortcutIndex
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.shortcut.ShortcutIndex} ShortcutIndex
             */
            ShortcutIndex.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.shortcut.ShortcutIndex)
                    return object;
                var message = new $root.lebai.shortcut.ShortcutIndex();
                if (object.id != null)
                    message.id = object.id >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a ShortcutIndex message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.shortcut.ShortcutIndex
             * @static
             * @param {lebai.shortcut.ShortcutIndex} message ShortcutIndex
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ShortcutIndex.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.id = 0;
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                return object;
            };

            /**
             * Converts this ShortcutIndex to JSON.
             * @function toJSON
             * @memberof lebai.shortcut.ShortcutIndex
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ShortcutIndex.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ShortcutIndex
             * @function getTypeUrl
             * @memberof lebai.shortcut.ShortcutIndex
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ShortcutIndex.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.shortcut.ShortcutIndex";
            };

            return ShortcutIndex;
        })();

        shortcut.Shortcut = (function() {

            /**
             * Properties of a Shortcut.
             * @memberof lebai.shortcut
             * @interface IShortcut
             * @property {number|null} [id] Shortcut id
             * @property {string|null} [dir] Shortcut dir
             * @property {string|null} [name] Shortcut name
             */

            /**
             * Constructs a new Shortcut.
             * @memberof lebai.shortcut
             * @classdesc Represents a Shortcut.
             * @implements IShortcut
             * @constructor
             * @param {lebai.shortcut.IShortcut=} [properties] Properties to set
             */
            function Shortcut(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Shortcut id.
             * @member {number} id
             * @memberof lebai.shortcut.Shortcut
             * @instance
             */
            Shortcut.prototype.id = 0;

            /**
             * Shortcut dir.
             * @member {string} dir
             * @memberof lebai.shortcut.Shortcut
             * @instance
             */
            Shortcut.prototype.dir = "";

            /**
             * Shortcut name.
             * @member {string} name
             * @memberof lebai.shortcut.Shortcut
             * @instance
             */
            Shortcut.prototype.name = "";

            /**
             * Creates a new Shortcut instance using the specified properties.
             * @function create
             * @memberof lebai.shortcut.Shortcut
             * @static
             * @param {lebai.shortcut.IShortcut=} [properties] Properties to set
             * @returns {lebai.shortcut.Shortcut} Shortcut instance
             */
            Shortcut.create = function create(properties) {
                return new Shortcut(properties);
            };

            /**
             * Encodes the specified Shortcut message. Does not implicitly {@link lebai.shortcut.Shortcut.verify|verify} messages.
             * @function encode
             * @memberof lebai.shortcut.Shortcut
             * @static
             * @param {lebai.shortcut.IShortcut} message Shortcut message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Shortcut.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
                if (message.dir != null && Object.hasOwnProperty.call(message, "dir"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.dir);
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
                return writer;
            };

            /**
             * Encodes the specified Shortcut message, length delimited. Does not implicitly {@link lebai.shortcut.Shortcut.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.shortcut.Shortcut
             * @static
             * @param {lebai.shortcut.IShortcut} message Shortcut message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Shortcut.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Shortcut message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.shortcut.Shortcut
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.shortcut.Shortcut} Shortcut
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Shortcut.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.shortcut.Shortcut();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.id = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.dir = reader.string();
                            break;
                        }
                    case 3: {
                            message.name = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Shortcut message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.shortcut.Shortcut
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.shortcut.Shortcut} Shortcut
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Shortcut.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Shortcut message.
             * @function verify
             * @memberof lebai.shortcut.Shortcut
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Shortcut.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id))
                        return "id: integer expected";
                if (message.dir != null && message.hasOwnProperty("dir"))
                    if (!$util.isString(message.dir))
                        return "dir: string expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                return null;
            };

            /**
             * Creates a Shortcut message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.shortcut.Shortcut
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.shortcut.Shortcut} Shortcut
             */
            Shortcut.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.shortcut.Shortcut)
                    return object;
                var message = new $root.lebai.shortcut.Shortcut();
                if (object.id != null)
                    message.id = object.id >>> 0;
                if (object.dir != null)
                    message.dir = String(object.dir);
                if (object.name != null)
                    message.name = String(object.name);
                return message;
            };

            /**
             * Creates a plain object from a Shortcut message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.shortcut.Shortcut
             * @static
             * @param {lebai.shortcut.Shortcut} message Shortcut
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Shortcut.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.id = 0;
                    object.dir = "";
                    object.name = "";
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.dir != null && message.hasOwnProperty("dir"))
                    object.dir = message.dir;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                return object;
            };

            /**
             * Converts this Shortcut to JSON.
             * @function toJSON
             * @memberof lebai.shortcut.Shortcut
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Shortcut.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Shortcut
             * @function getTypeUrl
             * @memberof lebai.shortcut.Shortcut
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Shortcut.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.shortcut.Shortcut";
            };

            return Shortcut;
        })();

        shortcut.ShortcutList = (function() {

            /**
             * Properties of a ShortcutList.
             * @memberof lebai.shortcut
             * @interface IShortcutList
             * @property {Array.<lebai.shortcut.IShortcut>|null} [list] ShortcutList list
             */

            /**
             * Constructs a new ShortcutList.
             * @memberof lebai.shortcut
             * @classdesc Represents a ShortcutList.
             * @implements IShortcutList
             * @constructor
             * @param {lebai.shortcut.IShortcutList=} [properties] Properties to set
             */
            function ShortcutList(properties) {
                this.list = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ShortcutList list.
             * @member {Array.<lebai.shortcut.IShortcut>} list
             * @memberof lebai.shortcut.ShortcutList
             * @instance
             */
            ShortcutList.prototype.list = $util.emptyArray;

            /**
             * Creates a new ShortcutList instance using the specified properties.
             * @function create
             * @memberof lebai.shortcut.ShortcutList
             * @static
             * @param {lebai.shortcut.IShortcutList=} [properties] Properties to set
             * @returns {lebai.shortcut.ShortcutList} ShortcutList instance
             */
            ShortcutList.create = function create(properties) {
                return new ShortcutList(properties);
            };

            /**
             * Encodes the specified ShortcutList message. Does not implicitly {@link lebai.shortcut.ShortcutList.verify|verify} messages.
             * @function encode
             * @memberof lebai.shortcut.ShortcutList
             * @static
             * @param {lebai.shortcut.IShortcutList} message ShortcutList message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ShortcutList.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.list != null && message.list.length)
                    for (var i = 0; i < message.list.length; ++i)
                        $root.lebai.shortcut.Shortcut.encode(message.list[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ShortcutList message, length delimited. Does not implicitly {@link lebai.shortcut.ShortcutList.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.shortcut.ShortcutList
             * @static
             * @param {lebai.shortcut.IShortcutList} message ShortcutList message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ShortcutList.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ShortcutList message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.shortcut.ShortcutList
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.shortcut.ShortcutList} ShortcutList
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ShortcutList.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.shortcut.ShortcutList();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.list && message.list.length))
                                message.list = [];
                            message.list.push($root.lebai.shortcut.Shortcut.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ShortcutList message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.shortcut.ShortcutList
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.shortcut.ShortcutList} ShortcutList
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ShortcutList.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ShortcutList message.
             * @function verify
             * @memberof lebai.shortcut.ShortcutList
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ShortcutList.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.list != null && message.hasOwnProperty("list")) {
                    if (!Array.isArray(message.list))
                        return "list: array expected";
                    for (var i = 0; i < message.list.length; ++i) {
                        var error = $root.lebai.shortcut.Shortcut.verify(message.list[i]);
                        if (error)
                            return "list." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a ShortcutList message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.shortcut.ShortcutList
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.shortcut.ShortcutList} ShortcutList
             */
            ShortcutList.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.shortcut.ShortcutList)
                    return object;
                var message = new $root.lebai.shortcut.ShortcutList();
                if (object.list) {
                    if (!Array.isArray(object.list))
                        throw TypeError(".lebai.shortcut.ShortcutList.list: array expected");
                    message.list = [];
                    for (var i = 0; i < object.list.length; ++i) {
                        if (typeof object.list[i] !== "object")
                            throw TypeError(".lebai.shortcut.ShortcutList.list: object expected");
                        message.list[i] = $root.lebai.shortcut.Shortcut.fromObject(object.list[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a ShortcutList message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.shortcut.ShortcutList
             * @static
             * @param {lebai.shortcut.ShortcutList} message ShortcutList
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ShortcutList.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.list = [];
                if (message.list && message.list.length) {
                    object.list = [];
                    for (var j = 0; j < message.list.length; ++j)
                        object.list[j] = $root.lebai.shortcut.Shortcut.toObject(message.list[j], options);
                }
                return object;
            };

            /**
             * Converts this ShortcutList to JSON.
             * @function toJSON
             * @memberof lebai.shortcut.ShortcutList
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ShortcutList.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ShortcutList
             * @function getTypeUrl
             * @memberof lebai.shortcut.ShortcutList
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ShortcutList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.shortcut.ShortcutList";
            };

            return ShortcutList;
        })();

        shortcut.ShortcutService = (function() {

            /**
             * Constructs a new ShortcutService service.
             * @memberof lebai.shortcut
             * @classdesc Represents a ShortcutService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function ShortcutService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (ShortcutService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = ShortcutService;

            /**
             * Creates new ShortcutService service using the specified rpc implementation.
             * @function create
             * @memberof lebai.shortcut.ShortcutService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {ShortcutService} RPC service. Useful where requests and/or responses are streamed.
             */
            ShortcutService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link lebai.shortcut.ShortcutService#setShortPose}.
             * @memberof lebai.shortcut.ShortcutService
             * @typedef SetShortPoseCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls SetShortPose.
             * @function setShortPose
             * @memberof lebai.shortcut.ShortcutService
             * @instance
             * @param {lebai.shortcut.IShortcut} request Shortcut message or plain object
             * @param {lebai.shortcut.ShortcutService.SetShortPoseCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ShortcutService.prototype.setShortPose = function setShortPose(request, callback) {
                return this.rpcCall(setShortPose, $root.lebai.shortcut.Shortcut, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "SetShortPose" });

            /**
             * Calls SetShortPose.
             * @function setShortPose
             * @memberof lebai.shortcut.ShortcutService
             * @instance
             * @param {lebai.shortcut.IShortcut} request Shortcut message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.shortcut.ShortcutService#getShortPose}.
             * @memberof lebai.shortcut.ShortcutService
             * @typedef GetShortPoseCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.shortcut.Shortcut} [response] Shortcut
             */

            /**
             * Calls GetShortPose.
             * @function getShortPose
             * @memberof lebai.shortcut.ShortcutService
             * @instance
             * @param {lebai.shortcut.IShortcutIndex} request ShortcutIndex message or plain object
             * @param {lebai.shortcut.ShortcutService.GetShortPoseCallback} callback Node-style callback called with the error, if any, and Shortcut
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ShortcutService.prototype.getShortPose = function getShortPose(request, callback) {
                return this.rpcCall(getShortPose, $root.lebai.shortcut.ShortcutIndex, $root.lebai.shortcut.Shortcut, request, callback);
            }, "name", { value: "GetShortPose" });

            /**
             * Calls GetShortPose.
             * @function getShortPose
             * @memberof lebai.shortcut.ShortcutService
             * @instance
             * @param {lebai.shortcut.IShortcutIndex} request ShortcutIndex message or plain object
             * @returns {Promise<lebai.shortcut.Shortcut>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.shortcut.ShortcutService#getShortPoses}.
             * @memberof lebai.shortcut.ShortcutService
             * @typedef GetShortPosesCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.shortcut.ShortcutList} [response] ShortcutList
             */

            /**
             * Calls GetShortPoses.
             * @function getShortPoses
             * @memberof lebai.shortcut.ShortcutService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {lebai.shortcut.ShortcutService.GetShortPosesCallback} callback Node-style callback called with the error, if any, and ShortcutList
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ShortcutService.prototype.getShortPoses = function getShortPoses(request, callback) {
                return this.rpcCall(getShortPoses, $root.google.protobuf.Empty, $root.lebai.shortcut.ShortcutList, request, callback);
            }, "name", { value: "GetShortPoses" });

            /**
             * Calls GetShortPoses.
             * @function getShortPoses
             * @memberof lebai.shortcut.ShortcutService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<lebai.shortcut.ShortcutList>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.shortcut.ShortcutService#setShortTask}.
             * @memberof lebai.shortcut.ShortcutService
             * @typedef SetShortTaskCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls SetShortTask.
             * @function setShortTask
             * @memberof lebai.shortcut.ShortcutService
             * @instance
             * @param {lebai.shortcut.IShortcut} request Shortcut message or plain object
             * @param {lebai.shortcut.ShortcutService.SetShortTaskCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ShortcutService.prototype.setShortTask = function setShortTask(request, callback) {
                return this.rpcCall(setShortTask, $root.lebai.shortcut.Shortcut, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "SetShortTask" });

            /**
             * Calls SetShortTask.
             * @function setShortTask
             * @memberof lebai.shortcut.ShortcutService
             * @instance
             * @param {lebai.shortcut.IShortcut} request Shortcut message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.shortcut.ShortcutService#getShortTask}.
             * @memberof lebai.shortcut.ShortcutService
             * @typedef GetShortTaskCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.shortcut.Shortcut} [response] Shortcut
             */

            /**
             * Calls GetShortTask.
             * @function getShortTask
             * @memberof lebai.shortcut.ShortcutService
             * @instance
             * @param {lebai.shortcut.IShortcutIndex} request ShortcutIndex message or plain object
             * @param {lebai.shortcut.ShortcutService.GetShortTaskCallback} callback Node-style callback called with the error, if any, and Shortcut
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ShortcutService.prototype.getShortTask = function getShortTask(request, callback) {
                return this.rpcCall(getShortTask, $root.lebai.shortcut.ShortcutIndex, $root.lebai.shortcut.Shortcut, request, callback);
            }, "name", { value: "GetShortTask" });

            /**
             * Calls GetShortTask.
             * @function getShortTask
             * @memberof lebai.shortcut.ShortcutService
             * @instance
             * @param {lebai.shortcut.IShortcutIndex} request ShortcutIndex message or plain object
             * @returns {Promise<lebai.shortcut.Shortcut>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.shortcut.ShortcutService#getShortTasks}.
             * @memberof lebai.shortcut.ShortcutService
             * @typedef GetShortTasksCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.shortcut.ShortcutList} [response] ShortcutList
             */

            /**
             * Calls GetShortTasks.
             * @function getShortTasks
             * @memberof lebai.shortcut.ShortcutService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {lebai.shortcut.ShortcutService.GetShortTasksCallback} callback Node-style callback called with the error, if any, and ShortcutList
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ShortcutService.prototype.getShortTasks = function getShortTasks(request, callback) {
                return this.rpcCall(getShortTasks, $root.google.protobuf.Empty, $root.lebai.shortcut.ShortcutList, request, callback);
            }, "name", { value: "GetShortTasks" });

            /**
             * Calls GetShortTasks.
             * @function getShortTasks
             * @memberof lebai.shortcut.ShortcutService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<lebai.shortcut.ShortcutList>} Promise
             * @variation 2
             */

            return ShortcutService;
        })();

        return shortcut;
    })();

    lebai.signal = (function() {

        /**
         * Namespace signal.
         * @memberof lebai
         * @namespace
         */
        var signal = {};

        signal.SetSignalRequest = (function() {

            /**
             * Properties of a SetSignalRequest.
             * @memberof lebai.signal
             * @interface ISetSignalRequest
             * @property {number|null} [key] SetSignalRequest key
             * @property {number|null} [value] SetSignalRequest value
             */

            /**
             * Constructs a new SetSignalRequest.
             * @memberof lebai.signal
             * @classdesc Represents a SetSignalRequest.
             * @implements ISetSignalRequest
             * @constructor
             * @param {lebai.signal.ISetSignalRequest=} [properties] Properties to set
             */
            function SetSignalRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SetSignalRequest key.
             * @member {number} key
             * @memberof lebai.signal.SetSignalRequest
             * @instance
             */
            SetSignalRequest.prototype.key = 0;

            /**
             * SetSignalRequest value.
             * @member {number} value
             * @memberof lebai.signal.SetSignalRequest
             * @instance
             */
            SetSignalRequest.prototype.value = 0;

            /**
             * Creates a new SetSignalRequest instance using the specified properties.
             * @function create
             * @memberof lebai.signal.SetSignalRequest
             * @static
             * @param {lebai.signal.ISetSignalRequest=} [properties] Properties to set
             * @returns {lebai.signal.SetSignalRequest} SetSignalRequest instance
             */
            SetSignalRequest.create = function create(properties) {
                return new SetSignalRequest(properties);
            };

            /**
             * Encodes the specified SetSignalRequest message. Does not implicitly {@link lebai.signal.SetSignalRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.signal.SetSignalRequest
             * @static
             * @param {lebai.signal.ISetSignalRequest} message SetSignalRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetSignalRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.key);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.value);
                return writer;
            };

            /**
             * Encodes the specified SetSignalRequest message, length delimited. Does not implicitly {@link lebai.signal.SetSignalRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.signal.SetSignalRequest
             * @static
             * @param {lebai.signal.ISetSignalRequest} message SetSignalRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetSignalRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetSignalRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.signal.SetSignalRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.signal.SetSignalRequest} SetSignalRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetSignalRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.signal.SetSignalRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.key = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.value = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetSignalRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.signal.SetSignalRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.signal.SetSignalRequest} SetSignalRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetSignalRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetSignalRequest message.
             * @function verify
             * @memberof lebai.signal.SetSignalRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetSignalRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!$util.isInteger(message.key))
                        return "key: integer expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isInteger(message.value))
                        return "value: integer expected";
                return null;
            };

            /**
             * Creates a SetSignalRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.signal.SetSignalRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.signal.SetSignalRequest} SetSignalRequest
             */
            SetSignalRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.signal.SetSignalRequest)
                    return object;
                var message = new $root.lebai.signal.SetSignalRequest();
                if (object.key != null)
                    message.key = object.key >>> 0;
                if (object.value != null)
                    message.value = object.value | 0;
                return message;
            };

            /**
             * Creates a plain object from a SetSignalRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.signal.SetSignalRequest
             * @static
             * @param {lebai.signal.SetSignalRequest} message SetSignalRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetSignalRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.key = 0;
                    object.value = 0;
                }
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                return object;
            };

            /**
             * Converts this SetSignalRequest to JSON.
             * @function toJSON
             * @memberof lebai.signal.SetSignalRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetSignalRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetSignalRequest
             * @function getTypeUrl
             * @memberof lebai.signal.SetSignalRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetSignalRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.signal.SetSignalRequest";
            };

            return SetSignalRequest;
        })();

        signal.SetSignalsRequest = (function() {

            /**
             * Properties of a SetSignalsRequest.
             * @memberof lebai.signal
             * @interface ISetSignalsRequest
             * @property {number|null} [key] SetSignalsRequest key
             * @property {Array.<number>|null} [values] SetSignalsRequest values
             */

            /**
             * Constructs a new SetSignalsRequest.
             * @memberof lebai.signal
             * @classdesc Represents a SetSignalsRequest.
             * @implements ISetSignalsRequest
             * @constructor
             * @param {lebai.signal.ISetSignalsRequest=} [properties] Properties to set
             */
            function SetSignalsRequest(properties) {
                this.values = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SetSignalsRequest key.
             * @member {number} key
             * @memberof lebai.signal.SetSignalsRequest
             * @instance
             */
            SetSignalsRequest.prototype.key = 0;

            /**
             * SetSignalsRequest values.
             * @member {Array.<number>} values
             * @memberof lebai.signal.SetSignalsRequest
             * @instance
             */
            SetSignalsRequest.prototype.values = $util.emptyArray;

            /**
             * Creates a new SetSignalsRequest instance using the specified properties.
             * @function create
             * @memberof lebai.signal.SetSignalsRequest
             * @static
             * @param {lebai.signal.ISetSignalsRequest=} [properties] Properties to set
             * @returns {lebai.signal.SetSignalsRequest} SetSignalsRequest instance
             */
            SetSignalsRequest.create = function create(properties) {
                return new SetSignalsRequest(properties);
            };

            /**
             * Encodes the specified SetSignalsRequest message. Does not implicitly {@link lebai.signal.SetSignalsRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.signal.SetSignalsRequest
             * @static
             * @param {lebai.signal.ISetSignalsRequest} message SetSignalsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetSignalsRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.key);
                if (message.values != null && message.values.length) {
                    writer.uint32(/* id 2, wireType 2 =*/18).fork();
                    for (var i = 0; i < message.values.length; ++i)
                        writer.int32(message.values[i]);
                    writer.ldelim();
                }
                return writer;
            };

            /**
             * Encodes the specified SetSignalsRequest message, length delimited. Does not implicitly {@link lebai.signal.SetSignalsRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.signal.SetSignalsRequest
             * @static
             * @param {lebai.signal.ISetSignalsRequest} message SetSignalsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetSignalsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetSignalsRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.signal.SetSignalsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.signal.SetSignalsRequest} SetSignalsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetSignalsRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.signal.SetSignalsRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.key = reader.uint32();
                            break;
                        }
                    case 2: {
                            if (!(message.values && message.values.length))
                                message.values = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.values.push(reader.int32());
                            } else
                                message.values.push(reader.int32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetSignalsRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.signal.SetSignalsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.signal.SetSignalsRequest} SetSignalsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetSignalsRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetSignalsRequest message.
             * @function verify
             * @memberof lebai.signal.SetSignalsRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetSignalsRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!$util.isInteger(message.key))
                        return "key: integer expected";
                if (message.values != null && message.hasOwnProperty("values")) {
                    if (!Array.isArray(message.values))
                        return "values: array expected";
                    for (var i = 0; i < message.values.length; ++i)
                        if (!$util.isInteger(message.values[i]))
                            return "values: integer[] expected";
                }
                return null;
            };

            /**
             * Creates a SetSignalsRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.signal.SetSignalsRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.signal.SetSignalsRequest} SetSignalsRequest
             */
            SetSignalsRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.signal.SetSignalsRequest)
                    return object;
                var message = new $root.lebai.signal.SetSignalsRequest();
                if (object.key != null)
                    message.key = object.key >>> 0;
                if (object.values) {
                    if (!Array.isArray(object.values))
                        throw TypeError(".lebai.signal.SetSignalsRequest.values: array expected");
                    message.values = [];
                    for (var i = 0; i < object.values.length; ++i)
                        message.values[i] = object.values[i] | 0;
                }
                return message;
            };

            /**
             * Creates a plain object from a SetSignalsRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.signal.SetSignalsRequest
             * @static
             * @param {lebai.signal.SetSignalsRequest} message SetSignalsRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetSignalsRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.values = [];
                if (options.defaults)
                    object.key = 0;
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                if (message.values && message.values.length) {
                    object.values = [];
                    for (var j = 0; j < message.values.length; ++j)
                        object.values[j] = message.values[j];
                }
                return object;
            };

            /**
             * Converts this SetSignalsRequest to JSON.
             * @function toJSON
             * @memberof lebai.signal.SetSignalsRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetSignalsRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetSignalsRequest
             * @function getTypeUrl
             * @memberof lebai.signal.SetSignalsRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetSignalsRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.signal.SetSignalsRequest";
            };

            return SetSignalsRequest;
        })();

        signal.WaitSignalRequest = (function() {

            /**
             * Properties of a WaitSignalRequest.
             * @memberof lebai.signal
             * @interface IWaitSignalRequest
             * @property {number|null} [key] WaitSignalRequest key
             * @property {number|null} [value] WaitSignalRequest value
             * @property {lebai.cmp.Relation|null} [relation] WaitSignalRequest relation
             */

            /**
             * Constructs a new WaitSignalRequest.
             * @memberof lebai.signal
             * @classdesc Represents a WaitSignalRequest.
             * @implements IWaitSignalRequest
             * @constructor
             * @param {lebai.signal.IWaitSignalRequest=} [properties] Properties to set
             */
            function WaitSignalRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WaitSignalRequest key.
             * @member {number} key
             * @memberof lebai.signal.WaitSignalRequest
             * @instance
             */
            WaitSignalRequest.prototype.key = 0;

            /**
             * WaitSignalRequest value.
             * @member {number} value
             * @memberof lebai.signal.WaitSignalRequest
             * @instance
             */
            WaitSignalRequest.prototype.value = 0;

            /**
             * WaitSignalRequest relation.
             * @member {lebai.cmp.Relation} relation
             * @memberof lebai.signal.WaitSignalRequest
             * @instance
             */
            WaitSignalRequest.prototype.relation = 0;

            /**
             * Creates a new WaitSignalRequest instance using the specified properties.
             * @function create
             * @memberof lebai.signal.WaitSignalRequest
             * @static
             * @param {lebai.signal.IWaitSignalRequest=} [properties] Properties to set
             * @returns {lebai.signal.WaitSignalRequest} WaitSignalRequest instance
             */
            WaitSignalRequest.create = function create(properties) {
                return new WaitSignalRequest(properties);
            };

            /**
             * Encodes the specified WaitSignalRequest message. Does not implicitly {@link lebai.signal.WaitSignalRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.signal.WaitSignalRequest
             * @static
             * @param {lebai.signal.IWaitSignalRequest} message WaitSignalRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WaitSignalRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.key);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.value);
                if (message.relation != null && Object.hasOwnProperty.call(message, "relation"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.relation);
                return writer;
            };

            /**
             * Encodes the specified WaitSignalRequest message, length delimited. Does not implicitly {@link lebai.signal.WaitSignalRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.signal.WaitSignalRequest
             * @static
             * @param {lebai.signal.IWaitSignalRequest} message WaitSignalRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WaitSignalRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WaitSignalRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.signal.WaitSignalRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.signal.WaitSignalRequest} WaitSignalRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WaitSignalRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.signal.WaitSignalRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.key = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.value = reader.int32();
                            break;
                        }
                    case 3: {
                            message.relation = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WaitSignalRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.signal.WaitSignalRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.signal.WaitSignalRequest} WaitSignalRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WaitSignalRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WaitSignalRequest message.
             * @function verify
             * @memberof lebai.signal.WaitSignalRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WaitSignalRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!$util.isInteger(message.key))
                        return "key: integer expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isInteger(message.value))
                        return "value: integer expected";
                if (message.relation != null && message.hasOwnProperty("relation"))
                    switch (message.relation) {
                    default:
                        return "relation: enum value expected";
                    case 0:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                        break;
                    }
                return null;
            };

            /**
             * Creates a WaitSignalRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.signal.WaitSignalRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.signal.WaitSignalRequest} WaitSignalRequest
             */
            WaitSignalRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.signal.WaitSignalRequest)
                    return object;
                var message = new $root.lebai.signal.WaitSignalRequest();
                if (object.key != null)
                    message.key = object.key >>> 0;
                if (object.value != null)
                    message.value = object.value | 0;
                switch (object.relation) {
                default:
                    if (typeof object.relation === "number") {
                        message.relation = object.relation;
                        break;
                    }
                    break;
                case "EQ":
                case 0:
                    message.relation = 0;
                    break;
                case "NEQ":
                case 2:
                    message.relation = 2;
                    break;
                case "LT":
                case 3:
                    message.relation = 3;
                    break;
                case "LTE":
                case 4:
                    message.relation = 4;
                    break;
                case "GT":
                case 5:
                    message.relation = 5;
                    break;
                case "GTE":
                case 6:
                    message.relation = 6;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a WaitSignalRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.signal.WaitSignalRequest
             * @static
             * @param {lebai.signal.WaitSignalRequest} message WaitSignalRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WaitSignalRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.key = 0;
                    object.value = 0;
                    object.relation = options.enums === String ? "EQ" : 0;
                }
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                if (message.relation != null && message.hasOwnProperty("relation"))
                    object.relation = options.enums === String ? $root.lebai.cmp.Relation[message.relation] === undefined ? message.relation : $root.lebai.cmp.Relation[message.relation] : message.relation;
                return object;
            };

            /**
             * Converts this WaitSignalRequest to JSON.
             * @function toJSON
             * @memberof lebai.signal.WaitSignalRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WaitSignalRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for WaitSignalRequest
             * @function getTypeUrl
             * @memberof lebai.signal.WaitSignalRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            WaitSignalRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.signal.WaitSignalRequest";
            };

            return WaitSignalRequest;
        })();

        signal.GetSignalRequest = (function() {

            /**
             * Properties of a GetSignalRequest.
             * @memberof lebai.signal
             * @interface IGetSignalRequest
             * @property {number|null} [key] GetSignalRequest key
             */

            /**
             * Constructs a new GetSignalRequest.
             * @memberof lebai.signal
             * @classdesc Represents a GetSignalRequest.
             * @implements IGetSignalRequest
             * @constructor
             * @param {lebai.signal.IGetSignalRequest=} [properties] Properties to set
             */
            function GetSignalRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetSignalRequest key.
             * @member {number} key
             * @memberof lebai.signal.GetSignalRequest
             * @instance
             */
            GetSignalRequest.prototype.key = 0;

            /**
             * Creates a new GetSignalRequest instance using the specified properties.
             * @function create
             * @memberof lebai.signal.GetSignalRequest
             * @static
             * @param {lebai.signal.IGetSignalRequest=} [properties] Properties to set
             * @returns {lebai.signal.GetSignalRequest} GetSignalRequest instance
             */
            GetSignalRequest.create = function create(properties) {
                return new GetSignalRequest(properties);
            };

            /**
             * Encodes the specified GetSignalRequest message. Does not implicitly {@link lebai.signal.GetSignalRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.signal.GetSignalRequest
             * @static
             * @param {lebai.signal.IGetSignalRequest} message GetSignalRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetSignalRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.key);
                return writer;
            };

            /**
             * Encodes the specified GetSignalRequest message, length delimited. Does not implicitly {@link lebai.signal.GetSignalRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.signal.GetSignalRequest
             * @static
             * @param {lebai.signal.IGetSignalRequest} message GetSignalRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetSignalRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetSignalRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.signal.GetSignalRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.signal.GetSignalRequest} GetSignalRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetSignalRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.signal.GetSignalRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.key = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetSignalRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.signal.GetSignalRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.signal.GetSignalRequest} GetSignalRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetSignalRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetSignalRequest message.
             * @function verify
             * @memberof lebai.signal.GetSignalRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetSignalRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!$util.isInteger(message.key))
                        return "key: integer expected";
                return null;
            };

            /**
             * Creates a GetSignalRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.signal.GetSignalRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.signal.GetSignalRequest} GetSignalRequest
             */
            GetSignalRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.signal.GetSignalRequest)
                    return object;
                var message = new $root.lebai.signal.GetSignalRequest();
                if (object.key != null)
                    message.key = object.key >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a GetSignalRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.signal.GetSignalRequest
             * @static
             * @param {lebai.signal.GetSignalRequest} message GetSignalRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetSignalRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.key = 0;
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                return object;
            };

            /**
             * Converts this GetSignalRequest to JSON.
             * @function toJSON
             * @memberof lebai.signal.GetSignalRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetSignalRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetSignalRequest
             * @function getTypeUrl
             * @memberof lebai.signal.GetSignalRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetSignalRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.signal.GetSignalRequest";
            };

            return GetSignalRequest;
        })();

        signal.GetSignalResponse = (function() {

            /**
             * Properties of a GetSignalResponse.
             * @memberof lebai.signal
             * @interface IGetSignalResponse
             * @property {number|null} [value] GetSignalResponse value
             */

            /**
             * Constructs a new GetSignalResponse.
             * @memberof lebai.signal
             * @classdesc Represents a GetSignalResponse.
             * @implements IGetSignalResponse
             * @constructor
             * @param {lebai.signal.IGetSignalResponse=} [properties] Properties to set
             */
            function GetSignalResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetSignalResponse value.
             * @member {number} value
             * @memberof lebai.signal.GetSignalResponse
             * @instance
             */
            GetSignalResponse.prototype.value = 0;

            /**
             * Creates a new GetSignalResponse instance using the specified properties.
             * @function create
             * @memberof lebai.signal.GetSignalResponse
             * @static
             * @param {lebai.signal.IGetSignalResponse=} [properties] Properties to set
             * @returns {lebai.signal.GetSignalResponse} GetSignalResponse instance
             */
            GetSignalResponse.create = function create(properties) {
                return new GetSignalResponse(properties);
            };

            /**
             * Encodes the specified GetSignalResponse message. Does not implicitly {@link lebai.signal.GetSignalResponse.verify|verify} messages.
             * @function encode
             * @memberof lebai.signal.GetSignalResponse
             * @static
             * @param {lebai.signal.IGetSignalResponse} message GetSignalResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetSignalResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.value);
                return writer;
            };

            /**
             * Encodes the specified GetSignalResponse message, length delimited. Does not implicitly {@link lebai.signal.GetSignalResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.signal.GetSignalResponse
             * @static
             * @param {lebai.signal.IGetSignalResponse} message GetSignalResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetSignalResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetSignalResponse message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.signal.GetSignalResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.signal.GetSignalResponse} GetSignalResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetSignalResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.signal.GetSignalResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.value = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetSignalResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.signal.GetSignalResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.signal.GetSignalResponse} GetSignalResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetSignalResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetSignalResponse message.
             * @function verify
             * @memberof lebai.signal.GetSignalResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetSignalResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isInteger(message.value))
                        return "value: integer expected";
                return null;
            };

            /**
             * Creates a GetSignalResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.signal.GetSignalResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.signal.GetSignalResponse} GetSignalResponse
             */
            GetSignalResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.signal.GetSignalResponse)
                    return object;
                var message = new $root.lebai.signal.GetSignalResponse();
                if (object.value != null)
                    message.value = object.value | 0;
                return message;
            };

            /**
             * Creates a plain object from a GetSignalResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.signal.GetSignalResponse
             * @static
             * @param {lebai.signal.GetSignalResponse} message GetSignalResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetSignalResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.value = 0;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                return object;
            };

            /**
             * Converts this GetSignalResponse to JSON.
             * @function toJSON
             * @memberof lebai.signal.GetSignalResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetSignalResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetSignalResponse
             * @function getTypeUrl
             * @memberof lebai.signal.GetSignalResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetSignalResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.signal.GetSignalResponse";
            };

            return GetSignalResponse;
        })();

        signal.GetSignalsRequest = (function() {

            /**
             * Properties of a GetSignalsRequest.
             * @memberof lebai.signal
             * @interface IGetSignalsRequest
             * @property {number|null} [key] GetSignalsRequest key
             * @property {number|null} [len] GetSignalsRequest len
             */

            /**
             * Constructs a new GetSignalsRequest.
             * @memberof lebai.signal
             * @classdesc Represents a GetSignalsRequest.
             * @implements IGetSignalsRequest
             * @constructor
             * @param {lebai.signal.IGetSignalsRequest=} [properties] Properties to set
             */
            function GetSignalsRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetSignalsRequest key.
             * @member {number} key
             * @memberof lebai.signal.GetSignalsRequest
             * @instance
             */
            GetSignalsRequest.prototype.key = 0;

            /**
             * GetSignalsRequest len.
             * @member {number} len
             * @memberof lebai.signal.GetSignalsRequest
             * @instance
             */
            GetSignalsRequest.prototype.len = 0;

            /**
             * Creates a new GetSignalsRequest instance using the specified properties.
             * @function create
             * @memberof lebai.signal.GetSignalsRequest
             * @static
             * @param {lebai.signal.IGetSignalsRequest=} [properties] Properties to set
             * @returns {lebai.signal.GetSignalsRequest} GetSignalsRequest instance
             */
            GetSignalsRequest.create = function create(properties) {
                return new GetSignalsRequest(properties);
            };

            /**
             * Encodes the specified GetSignalsRequest message. Does not implicitly {@link lebai.signal.GetSignalsRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.signal.GetSignalsRequest
             * @static
             * @param {lebai.signal.IGetSignalsRequest} message GetSignalsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetSignalsRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.key);
                if (message.len != null && Object.hasOwnProperty.call(message, "len"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.len);
                return writer;
            };

            /**
             * Encodes the specified GetSignalsRequest message, length delimited. Does not implicitly {@link lebai.signal.GetSignalsRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.signal.GetSignalsRequest
             * @static
             * @param {lebai.signal.IGetSignalsRequest} message GetSignalsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetSignalsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetSignalsRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.signal.GetSignalsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.signal.GetSignalsRequest} GetSignalsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetSignalsRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.signal.GetSignalsRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.key = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.len = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetSignalsRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.signal.GetSignalsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.signal.GetSignalsRequest} GetSignalsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetSignalsRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetSignalsRequest message.
             * @function verify
             * @memberof lebai.signal.GetSignalsRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetSignalsRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!$util.isInteger(message.key))
                        return "key: integer expected";
                if (message.len != null && message.hasOwnProperty("len"))
                    if (!$util.isInteger(message.len))
                        return "len: integer expected";
                return null;
            };

            /**
             * Creates a GetSignalsRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.signal.GetSignalsRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.signal.GetSignalsRequest} GetSignalsRequest
             */
            GetSignalsRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.signal.GetSignalsRequest)
                    return object;
                var message = new $root.lebai.signal.GetSignalsRequest();
                if (object.key != null)
                    message.key = object.key >>> 0;
                if (object.len != null)
                    message.len = object.len >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a GetSignalsRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.signal.GetSignalsRequest
             * @static
             * @param {lebai.signal.GetSignalsRequest} message GetSignalsRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetSignalsRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.key = 0;
                    object.len = 0;
                }
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                if (message.len != null && message.hasOwnProperty("len"))
                    object.len = message.len;
                return object;
            };

            /**
             * Converts this GetSignalsRequest to JSON.
             * @function toJSON
             * @memberof lebai.signal.GetSignalsRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetSignalsRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetSignalsRequest
             * @function getTypeUrl
             * @memberof lebai.signal.GetSignalsRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetSignalsRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.signal.GetSignalsRequest";
            };

            return GetSignalsRequest;
        })();

        signal.GetSignalsResponse = (function() {

            /**
             * Properties of a GetSignalsResponse.
             * @memberof lebai.signal
             * @interface IGetSignalsResponse
             * @property {Array.<number>|null} [values] GetSignalsResponse values
             */

            /**
             * Constructs a new GetSignalsResponse.
             * @memberof lebai.signal
             * @classdesc Represents a GetSignalsResponse.
             * @implements IGetSignalsResponse
             * @constructor
             * @param {lebai.signal.IGetSignalsResponse=} [properties] Properties to set
             */
            function GetSignalsResponse(properties) {
                this.values = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetSignalsResponse values.
             * @member {Array.<number>} values
             * @memberof lebai.signal.GetSignalsResponse
             * @instance
             */
            GetSignalsResponse.prototype.values = $util.emptyArray;

            /**
             * Creates a new GetSignalsResponse instance using the specified properties.
             * @function create
             * @memberof lebai.signal.GetSignalsResponse
             * @static
             * @param {lebai.signal.IGetSignalsResponse=} [properties] Properties to set
             * @returns {lebai.signal.GetSignalsResponse} GetSignalsResponse instance
             */
            GetSignalsResponse.create = function create(properties) {
                return new GetSignalsResponse(properties);
            };

            /**
             * Encodes the specified GetSignalsResponse message. Does not implicitly {@link lebai.signal.GetSignalsResponse.verify|verify} messages.
             * @function encode
             * @memberof lebai.signal.GetSignalsResponse
             * @static
             * @param {lebai.signal.IGetSignalsResponse} message GetSignalsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetSignalsResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.values != null && message.values.length) {
                    writer.uint32(/* id 1, wireType 2 =*/10).fork();
                    for (var i = 0; i < message.values.length; ++i)
                        writer.int32(message.values[i]);
                    writer.ldelim();
                }
                return writer;
            };

            /**
             * Encodes the specified GetSignalsResponse message, length delimited. Does not implicitly {@link lebai.signal.GetSignalsResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.signal.GetSignalsResponse
             * @static
             * @param {lebai.signal.IGetSignalsResponse} message GetSignalsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetSignalsResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetSignalsResponse message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.signal.GetSignalsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.signal.GetSignalsResponse} GetSignalsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetSignalsResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.signal.GetSignalsResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.values && message.values.length))
                                message.values = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.values.push(reader.int32());
                            } else
                                message.values.push(reader.int32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetSignalsResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.signal.GetSignalsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.signal.GetSignalsResponse} GetSignalsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetSignalsResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetSignalsResponse message.
             * @function verify
             * @memberof lebai.signal.GetSignalsResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetSignalsResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.values != null && message.hasOwnProperty("values")) {
                    if (!Array.isArray(message.values))
                        return "values: array expected";
                    for (var i = 0; i < message.values.length; ++i)
                        if (!$util.isInteger(message.values[i]))
                            return "values: integer[] expected";
                }
                return null;
            };

            /**
             * Creates a GetSignalsResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.signal.GetSignalsResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.signal.GetSignalsResponse} GetSignalsResponse
             */
            GetSignalsResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.signal.GetSignalsResponse)
                    return object;
                var message = new $root.lebai.signal.GetSignalsResponse();
                if (object.values) {
                    if (!Array.isArray(object.values))
                        throw TypeError(".lebai.signal.GetSignalsResponse.values: array expected");
                    message.values = [];
                    for (var i = 0; i < object.values.length; ++i)
                        message.values[i] = object.values[i] | 0;
                }
                return message;
            };

            /**
             * Creates a plain object from a GetSignalsResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.signal.GetSignalsResponse
             * @static
             * @param {lebai.signal.GetSignalsResponse} message GetSignalsResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetSignalsResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.values = [];
                if (message.values && message.values.length) {
                    object.values = [];
                    for (var j = 0; j < message.values.length; ++j)
                        object.values[j] = message.values[j];
                }
                return object;
            };

            /**
             * Converts this GetSignalsResponse to JSON.
             * @function toJSON
             * @memberof lebai.signal.GetSignalsResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetSignalsResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetSignalsResponse
             * @function getTypeUrl
             * @memberof lebai.signal.GetSignalsResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetSignalsResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.signal.GetSignalsResponse";
            };

            return GetSignalsResponse;
        })();

        signal.SignalService = (function() {

            /**
             * Constructs a new SignalService service.
             * @memberof lebai.signal
             * @classdesc Represents a SignalService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function SignalService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (SignalService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = SignalService;

            /**
             * Creates new SignalService service using the specified rpc implementation.
             * @function create
             * @memberof lebai.signal.SignalService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {SignalService} RPC service. Useful where requests and/or responses are streamed.
             */
            SignalService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link lebai.signal.SignalService#setSignal}.
             * @memberof lebai.signal.SignalService
             * @typedef SetSignalCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls SetSignal.
             * @function setSignal
             * @memberof lebai.signal.SignalService
             * @instance
             * @param {lebai.signal.ISetSignalRequest} request SetSignalRequest message or plain object
             * @param {lebai.signal.SignalService.SetSignalCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(SignalService.prototype.setSignal = function setSignal(request, callback) {
                return this.rpcCall(setSignal, $root.lebai.signal.SetSignalRequest, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "SetSignal" });

            /**
             * Calls SetSignal.
             * @function setSignal
             * @memberof lebai.signal.SignalService
             * @instance
             * @param {lebai.signal.ISetSignalRequest} request SetSignalRequest message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.signal.SignalService#setSignals}.
             * @memberof lebai.signal.SignalService
             * @typedef SetSignalsCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls SetSignals.
             * @function setSignals
             * @memberof lebai.signal.SignalService
             * @instance
             * @param {lebai.signal.ISetSignalsRequest} request SetSignalsRequest message or plain object
             * @param {lebai.signal.SignalService.SetSignalsCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(SignalService.prototype.setSignals = function setSignals(request, callback) {
                return this.rpcCall(setSignals, $root.lebai.signal.SetSignalsRequest, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "SetSignals" });

            /**
             * Calls SetSignals.
             * @function setSignals
             * @memberof lebai.signal.SignalService
             * @instance
             * @param {lebai.signal.ISetSignalsRequest} request SetSignalsRequest message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.signal.SignalService#getSignal}.
             * @memberof lebai.signal.SignalService
             * @typedef GetSignalCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.signal.GetSignalResponse} [response] GetSignalResponse
             */

            /**
             * Calls GetSignal.
             * @function getSignal
             * @memberof lebai.signal.SignalService
             * @instance
             * @param {lebai.signal.IGetSignalRequest} request GetSignalRequest message or plain object
             * @param {lebai.signal.SignalService.GetSignalCallback} callback Node-style callback called with the error, if any, and GetSignalResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(SignalService.prototype.getSignal = function getSignal(request, callback) {
                return this.rpcCall(getSignal, $root.lebai.signal.GetSignalRequest, $root.lebai.signal.GetSignalResponse, request, callback);
            }, "name", { value: "GetSignal" });

            /**
             * Calls GetSignal.
             * @function getSignal
             * @memberof lebai.signal.SignalService
             * @instance
             * @param {lebai.signal.IGetSignalRequest} request GetSignalRequest message or plain object
             * @returns {Promise<lebai.signal.GetSignalResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.signal.SignalService#getSignals}.
             * @memberof lebai.signal.SignalService
             * @typedef GetSignalsCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.signal.GetSignalsResponse} [response] GetSignalsResponse
             */

            /**
             * Calls GetSignals.
             * @function getSignals
             * @memberof lebai.signal.SignalService
             * @instance
             * @param {lebai.signal.IGetSignalsRequest} request GetSignalsRequest message or plain object
             * @param {lebai.signal.SignalService.GetSignalsCallback} callback Node-style callback called with the error, if any, and GetSignalsResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(SignalService.prototype.getSignals = function getSignals(request, callback) {
                return this.rpcCall(getSignals, $root.lebai.signal.GetSignalsRequest, $root.lebai.signal.GetSignalsResponse, request, callback);
            }, "name", { value: "GetSignals" });

            /**
             * Calls GetSignals.
             * @function getSignals
             * @memberof lebai.signal.SignalService
             * @instance
             * @param {lebai.signal.IGetSignalsRequest} request GetSignalsRequest message or plain object
             * @returns {Promise<lebai.signal.GetSignalsResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.signal.SignalService#waitSignal}.
             * @memberof lebai.signal.SignalService
             * @typedef WaitSignalCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls WaitSignal.
             * @function waitSignal
             * @memberof lebai.signal.SignalService
             * @instance
             * @param {lebai.signal.IWaitSignalRequest} request WaitSignalRequest message or plain object
             * @param {lebai.signal.SignalService.WaitSignalCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(SignalService.prototype.waitSignal = function waitSignal(request, callback) {
                return this.rpcCall(waitSignal, $root.lebai.signal.WaitSignalRequest, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "WaitSignal" });

            /**
             * Calls WaitSignal.
             * @function waitSignal
             * @memberof lebai.signal.SignalService
             * @instance
             * @param {lebai.signal.IWaitSignalRequest} request WaitSignalRequest message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.signal.SignalService#addSignal}.
             * @memberof lebai.signal.SignalService
             * @typedef AddSignalCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls AddSignal.
             * @function addSignal
             * @memberof lebai.signal.SignalService
             * @instance
             * @param {lebai.signal.ISetSignalRequest} request SetSignalRequest message or plain object
             * @param {lebai.signal.SignalService.AddSignalCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(SignalService.prototype.addSignal = function addSignal(request, callback) {
                return this.rpcCall(addSignal, $root.lebai.signal.SetSignalRequest, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "AddSignal" });

            /**
             * Calls AddSignal.
             * @function addSignal
             * @memberof lebai.signal.SignalService
             * @instance
             * @param {lebai.signal.ISetSignalRequest} request SetSignalRequest message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            return SignalService;
        })();

        return signal;
    })();

    lebai.storage = (function() {

        /**
         * Namespace storage.
         * @memberof lebai
         * @namespace
         */
        var storage = {};

        storage.ItemIndex = (function() {

            /**
             * Properties of an ItemIndex.
             * @memberof lebai.storage
             * @interface IItemIndex
             * @property {string|null} [key] ItemIndex key
             */

            /**
             * Constructs a new ItemIndex.
             * @memberof lebai.storage
             * @classdesc Represents an ItemIndex.
             * @implements IItemIndex
             * @constructor
             * @param {lebai.storage.IItemIndex=} [properties] Properties to set
             */
            function ItemIndex(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ItemIndex key.
             * @member {string} key
             * @memberof lebai.storage.ItemIndex
             * @instance
             */
            ItemIndex.prototype.key = "";

            /**
             * Creates a new ItemIndex instance using the specified properties.
             * @function create
             * @memberof lebai.storage.ItemIndex
             * @static
             * @param {lebai.storage.IItemIndex=} [properties] Properties to set
             * @returns {lebai.storage.ItemIndex} ItemIndex instance
             */
            ItemIndex.create = function create(properties) {
                return new ItemIndex(properties);
            };

            /**
             * Encodes the specified ItemIndex message. Does not implicitly {@link lebai.storage.ItemIndex.verify|verify} messages.
             * @function encode
             * @memberof lebai.storage.ItemIndex
             * @static
             * @param {lebai.storage.IItemIndex} message ItemIndex message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ItemIndex.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
                return writer;
            };

            /**
             * Encodes the specified ItemIndex message, length delimited. Does not implicitly {@link lebai.storage.ItemIndex.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.storage.ItemIndex
             * @static
             * @param {lebai.storage.IItemIndex} message ItemIndex message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ItemIndex.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ItemIndex message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.storage.ItemIndex
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.storage.ItemIndex} ItemIndex
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ItemIndex.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.storage.ItemIndex();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.key = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ItemIndex message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.storage.ItemIndex
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.storage.ItemIndex} ItemIndex
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ItemIndex.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ItemIndex message.
             * @function verify
             * @memberof lebai.storage.ItemIndex
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ItemIndex.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!$util.isString(message.key))
                        return "key: string expected";
                return null;
            };

            /**
             * Creates an ItemIndex message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.storage.ItemIndex
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.storage.ItemIndex} ItemIndex
             */
            ItemIndex.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.storage.ItemIndex)
                    return object;
                var message = new $root.lebai.storage.ItemIndex();
                if (object.key != null)
                    message.key = String(object.key);
                return message;
            };

            /**
             * Creates a plain object from an ItemIndex message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.storage.ItemIndex
             * @static
             * @param {lebai.storage.ItemIndex} message ItemIndex
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ItemIndex.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.key = "";
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                return object;
            };

            /**
             * Converts this ItemIndex to JSON.
             * @function toJSON
             * @memberof lebai.storage.ItemIndex
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ItemIndex.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ItemIndex
             * @function getTypeUrl
             * @memberof lebai.storage.ItemIndex
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ItemIndex.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.storage.ItemIndex";
            };

            return ItemIndex;
        })();

        storage.Item = (function() {

            /**
             * Properties of an Item.
             * @memberof lebai.storage
             * @interface IItem
             * @property {string|null} [key] Item key
             * @property {string|null} [value] Item value
             */

            /**
             * Constructs a new Item.
             * @memberof lebai.storage
             * @classdesc Represents an Item.
             * @implements IItem
             * @constructor
             * @param {lebai.storage.IItem=} [properties] Properties to set
             */
            function Item(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Item key.
             * @member {string} key
             * @memberof lebai.storage.Item
             * @instance
             */
            Item.prototype.key = "";

            /**
             * Item value.
             * @member {string} value
             * @memberof lebai.storage.Item
             * @instance
             */
            Item.prototype.value = "";

            /**
             * Creates a new Item instance using the specified properties.
             * @function create
             * @memberof lebai.storage.Item
             * @static
             * @param {lebai.storage.IItem=} [properties] Properties to set
             * @returns {lebai.storage.Item} Item instance
             */
            Item.create = function create(properties) {
                return new Item(properties);
            };

            /**
             * Encodes the specified Item message. Does not implicitly {@link lebai.storage.Item.verify|verify} messages.
             * @function encode
             * @memberof lebai.storage.Item
             * @static
             * @param {lebai.storage.IItem} message Item message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Item.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
                return writer;
            };

            /**
             * Encodes the specified Item message, length delimited. Does not implicitly {@link lebai.storage.Item.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.storage.Item
             * @static
             * @param {lebai.storage.IItem} message Item message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Item.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Item message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.storage.Item
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.storage.Item} Item
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Item.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.storage.Item();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.key = reader.string();
                            break;
                        }
                    case 2: {
                            message.value = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Item message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.storage.Item
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.storage.Item} Item
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Item.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Item message.
             * @function verify
             * @memberof lebai.storage.Item
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Item.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!$util.isString(message.key))
                        return "key: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isString(message.value))
                        return "value: string expected";
                return null;
            };

            /**
             * Creates an Item message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.storage.Item
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.storage.Item} Item
             */
            Item.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.storage.Item)
                    return object;
                var message = new $root.lebai.storage.Item();
                if (object.key != null)
                    message.key = String(object.key);
                if (object.value != null)
                    message.value = String(object.value);
                return message;
            };

            /**
             * Creates a plain object from an Item message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.storage.Item
             * @static
             * @param {lebai.storage.Item} message Item
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Item.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.key = "";
                    object.value = "";
                }
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                return object;
            };

            /**
             * Converts this Item to JSON.
             * @function toJSON
             * @memberof lebai.storage.Item
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Item.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Item
             * @function getTypeUrl
             * @memberof lebai.storage.Item
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Item.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.storage.Item";
            };

            return Item;
        })();

        storage.GetItemsRequest = (function() {

            /**
             * Properties of a GetItemsRequest.
             * @memberof lebai.storage
             * @interface IGetItemsRequest
             * @property {string|null} [prefix] GetItemsRequest prefix
             */

            /**
             * Constructs a new GetItemsRequest.
             * @memberof lebai.storage
             * @classdesc Represents a GetItemsRequest.
             * @implements IGetItemsRequest
             * @constructor
             * @param {lebai.storage.IGetItemsRequest=} [properties] Properties to set
             */
            function GetItemsRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetItemsRequest prefix.
             * @member {string} prefix
             * @memberof lebai.storage.GetItemsRequest
             * @instance
             */
            GetItemsRequest.prototype.prefix = "";

            /**
             * Creates a new GetItemsRequest instance using the specified properties.
             * @function create
             * @memberof lebai.storage.GetItemsRequest
             * @static
             * @param {lebai.storage.IGetItemsRequest=} [properties] Properties to set
             * @returns {lebai.storage.GetItemsRequest} GetItemsRequest instance
             */
            GetItemsRequest.create = function create(properties) {
                return new GetItemsRequest(properties);
            };

            /**
             * Encodes the specified GetItemsRequest message. Does not implicitly {@link lebai.storage.GetItemsRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.storage.GetItemsRequest
             * @static
             * @param {lebai.storage.IGetItemsRequest} message GetItemsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetItemsRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.prefix != null && Object.hasOwnProperty.call(message, "prefix"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.prefix);
                return writer;
            };

            /**
             * Encodes the specified GetItemsRequest message, length delimited. Does not implicitly {@link lebai.storage.GetItemsRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.storage.GetItemsRequest
             * @static
             * @param {lebai.storage.IGetItemsRequest} message GetItemsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetItemsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetItemsRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.storage.GetItemsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.storage.GetItemsRequest} GetItemsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetItemsRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.storage.GetItemsRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.prefix = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetItemsRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.storage.GetItemsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.storage.GetItemsRequest} GetItemsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetItemsRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetItemsRequest message.
             * @function verify
             * @memberof lebai.storage.GetItemsRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetItemsRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.prefix != null && message.hasOwnProperty("prefix"))
                    if (!$util.isString(message.prefix))
                        return "prefix: string expected";
                return null;
            };

            /**
             * Creates a GetItemsRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.storage.GetItemsRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.storage.GetItemsRequest} GetItemsRequest
             */
            GetItemsRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.storage.GetItemsRequest)
                    return object;
                var message = new $root.lebai.storage.GetItemsRequest();
                if (object.prefix != null)
                    message.prefix = String(object.prefix);
                return message;
            };

            /**
             * Creates a plain object from a GetItemsRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.storage.GetItemsRequest
             * @static
             * @param {lebai.storage.GetItemsRequest} message GetItemsRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetItemsRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.prefix = "";
                if (message.prefix != null && message.hasOwnProperty("prefix"))
                    object.prefix = message.prefix;
                return object;
            };

            /**
             * Converts this GetItemsRequest to JSON.
             * @function toJSON
             * @memberof lebai.storage.GetItemsRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetItemsRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetItemsRequest
             * @function getTypeUrl
             * @memberof lebai.storage.GetItemsRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetItemsRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.storage.GetItemsRequest";
            };

            return GetItemsRequest;
        })();

        storage.Items = (function() {

            /**
             * Properties of an Items.
             * @memberof lebai.storage
             * @interface IItems
             * @property {Array.<lebai.storage.IItem>|null} [items] Items items
             */

            /**
             * Constructs a new Items.
             * @memberof lebai.storage
             * @classdesc Represents an Items.
             * @implements IItems
             * @constructor
             * @param {lebai.storage.IItems=} [properties] Properties to set
             */
            function Items(properties) {
                this.items = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Items items.
             * @member {Array.<lebai.storage.IItem>} items
             * @memberof lebai.storage.Items
             * @instance
             */
            Items.prototype.items = $util.emptyArray;

            /**
             * Creates a new Items instance using the specified properties.
             * @function create
             * @memberof lebai.storage.Items
             * @static
             * @param {lebai.storage.IItems=} [properties] Properties to set
             * @returns {lebai.storage.Items} Items instance
             */
            Items.create = function create(properties) {
                return new Items(properties);
            };

            /**
             * Encodes the specified Items message. Does not implicitly {@link lebai.storage.Items.verify|verify} messages.
             * @function encode
             * @memberof lebai.storage.Items
             * @static
             * @param {lebai.storage.IItems} message Items message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Items.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.items != null && message.items.length)
                    for (var i = 0; i < message.items.length; ++i)
                        $root.lebai.storage.Item.encode(message.items[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Items message, length delimited. Does not implicitly {@link lebai.storage.Items.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.storage.Items
             * @static
             * @param {lebai.storage.IItems} message Items message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Items.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Items message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.storage.Items
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.storage.Items} Items
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Items.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.storage.Items();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.items && message.items.length))
                                message.items = [];
                            message.items.push($root.lebai.storage.Item.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Items message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.storage.Items
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.storage.Items} Items
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Items.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Items message.
             * @function verify
             * @memberof lebai.storage.Items
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Items.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.items != null && message.hasOwnProperty("items")) {
                    if (!Array.isArray(message.items))
                        return "items: array expected";
                    for (var i = 0; i < message.items.length; ++i) {
                        var error = $root.lebai.storage.Item.verify(message.items[i]);
                        if (error)
                            return "items." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an Items message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.storage.Items
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.storage.Items} Items
             */
            Items.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.storage.Items)
                    return object;
                var message = new $root.lebai.storage.Items();
                if (object.items) {
                    if (!Array.isArray(object.items))
                        throw TypeError(".lebai.storage.Items.items: array expected");
                    message.items = [];
                    for (var i = 0; i < object.items.length; ++i) {
                        if (typeof object.items[i] !== "object")
                            throw TypeError(".lebai.storage.Items.items: object expected");
                        message.items[i] = $root.lebai.storage.Item.fromObject(object.items[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an Items message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.storage.Items
             * @static
             * @param {lebai.storage.Items} message Items
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Items.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.items = [];
                if (message.items && message.items.length) {
                    object.items = [];
                    for (var j = 0; j < message.items.length; ++j)
                        object.items[j] = $root.lebai.storage.Item.toObject(message.items[j], options);
                }
                return object;
            };

            /**
             * Converts this Items to JSON.
             * @function toJSON
             * @memberof lebai.storage.Items
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Items.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Items
             * @function getTypeUrl
             * @memberof lebai.storage.Items
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Items.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.storage.Items";
            };

            return Items;
        })();

        storage.StorageService = (function() {

            /**
             * Constructs a new StorageService service.
             * @memberof lebai.storage
             * @classdesc Represents a StorageService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function StorageService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (StorageService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = StorageService;

            /**
             * Creates new StorageService service using the specified rpc implementation.
             * @function create
             * @memberof lebai.storage.StorageService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {StorageService} RPC service. Useful where requests and/or responses are streamed.
             */
            StorageService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link lebai.storage.StorageService#setItem}.
             * @memberof lebai.storage.StorageService
             * @typedef SetItemCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls SetItem.
             * @function setItem
             * @memberof lebai.storage.StorageService
             * @instance
             * @param {lebai.storage.IItem} request Item message or plain object
             * @param {lebai.storage.StorageService.SetItemCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(StorageService.prototype.setItem = function setItem(request, callback) {
                return this.rpcCall(setItem, $root.lebai.storage.Item, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "SetItem" });

            /**
             * Calls SetItem.
             * @function setItem
             * @memberof lebai.storage.StorageService
             * @instance
             * @param {lebai.storage.IItem} request Item message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.storage.StorageService#getItem}.
             * @memberof lebai.storage.StorageService
             * @typedef GetItemCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.storage.Item} [response] Item
             */

            /**
             * Calls GetItem.
             * @function getItem
             * @memberof lebai.storage.StorageService
             * @instance
             * @param {lebai.storage.IItemIndex} request ItemIndex message or plain object
             * @param {lebai.storage.StorageService.GetItemCallback} callback Node-style callback called with the error, if any, and Item
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(StorageService.prototype.getItem = function getItem(request, callback) {
                return this.rpcCall(getItem, $root.lebai.storage.ItemIndex, $root.lebai.storage.Item, request, callback);
            }, "name", { value: "GetItem" });

            /**
             * Calls GetItem.
             * @function getItem
             * @memberof lebai.storage.StorageService
             * @instance
             * @param {lebai.storage.IItemIndex} request ItemIndex message or plain object
             * @returns {Promise<lebai.storage.Item>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.storage.StorageService#getItems}.
             * @memberof lebai.storage.StorageService
             * @typedef GetItemsCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.storage.Items} [response] Items
             */

            /**
             * Calls GetItems.
             * @function getItems
             * @memberof lebai.storage.StorageService
             * @instance
             * @param {lebai.storage.IGetItemsRequest} request GetItemsRequest message or plain object
             * @param {lebai.storage.StorageService.GetItemsCallback} callback Node-style callback called with the error, if any, and Items
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(StorageService.prototype.getItems = function getItems(request, callback) {
                return this.rpcCall(getItems, $root.lebai.storage.GetItemsRequest, $root.lebai.storage.Items, request, callback);
            }, "name", { value: "GetItems" });

            /**
             * Calls GetItems.
             * @function getItems
             * @memberof lebai.storage.StorageService
             * @instance
             * @param {lebai.storage.IGetItemsRequest} request GetItemsRequest message or plain object
             * @returns {Promise<lebai.storage.Items>} Promise
             * @variation 2
             */

            return StorageService;
        })();

        return storage;
    })();

    lebai.structure = (function() {

        /**
         * Namespace structure.
         * @memberof lebai
         * @namespace
         */
        var structure = {};

        structure.Structure = (function() {

            /**
             * Properties of a Structure.
             * @memberof lebai.structure
             * @interface IStructure
             * @property {boolean|null} [active] Structure active
             * @property {string|null} [name] Structure name
             * @property {lebai.system.ArmModel|null} [kind] Structure kind
             * @property {number|null} [dof] Structure dof
             * @property {string|null} [dh] Structure dh
             * @property {string|null} [dyn] Structure dyn
             * @property {string|null} [servo] Structure servo
             */

            /**
             * Constructs a new Structure.
             * @memberof lebai.structure
             * @classdesc Represents a Structure.
             * @implements IStructure
             * @constructor
             * @param {lebai.structure.IStructure=} [properties] Properties to set
             */
            function Structure(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Structure active.
             * @member {boolean} active
             * @memberof lebai.structure.Structure
             * @instance
             */
            Structure.prototype.active = false;

            /**
             * Structure name.
             * @member {string} name
             * @memberof lebai.structure.Structure
             * @instance
             */
            Structure.prototype.name = "";

            /**
             * Structure kind.
             * @member {lebai.system.ArmModel} kind
             * @memberof lebai.structure.Structure
             * @instance
             */
            Structure.prototype.kind = 0;

            /**
             * Structure dof.
             * @member {number} dof
             * @memberof lebai.structure.Structure
             * @instance
             */
            Structure.prototype.dof = 0;

            /**
             * Structure dh.
             * @member {string} dh
             * @memberof lebai.structure.Structure
             * @instance
             */
            Structure.prototype.dh = "";

            /**
             * Structure dyn.
             * @member {string} dyn
             * @memberof lebai.structure.Structure
             * @instance
             */
            Structure.prototype.dyn = "";

            /**
             * Structure servo.
             * @member {string} servo
             * @memberof lebai.structure.Structure
             * @instance
             */
            Structure.prototype.servo = "";

            /**
             * Creates a new Structure instance using the specified properties.
             * @function create
             * @memberof lebai.structure.Structure
             * @static
             * @param {lebai.structure.IStructure=} [properties] Properties to set
             * @returns {lebai.structure.Structure} Structure instance
             */
            Structure.create = function create(properties) {
                return new Structure(properties);
            };

            /**
             * Encodes the specified Structure message. Does not implicitly {@link lebai.structure.Structure.verify|verify} messages.
             * @function encode
             * @memberof lebai.structure.Structure
             * @static
             * @param {lebai.structure.IStructure} message Structure message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Structure.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.active != null && Object.hasOwnProperty.call(message, "active"))
                    writer.uint32(/* id 10, wireType 0 =*/80).bool(message.active);
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.name);
                if (message.kind != null && Object.hasOwnProperty.call(message, "kind"))
                    writer.uint32(/* id 12, wireType 0 =*/96).int32(message.kind);
                if (message.dof != null && Object.hasOwnProperty.call(message, "dof"))
                    writer.uint32(/* id 13, wireType 0 =*/104).uint32(message.dof);
                if (message.dh != null && Object.hasOwnProperty.call(message, "dh"))
                    writer.uint32(/* id 14, wireType 2 =*/114).string(message.dh);
                if (message.dyn != null && Object.hasOwnProperty.call(message, "dyn"))
                    writer.uint32(/* id 15, wireType 2 =*/122).string(message.dyn);
                if (message.servo != null && Object.hasOwnProperty.call(message, "servo"))
                    writer.uint32(/* id 16, wireType 2 =*/130).string(message.servo);
                return writer;
            };

            /**
             * Encodes the specified Structure message, length delimited. Does not implicitly {@link lebai.structure.Structure.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.structure.Structure
             * @static
             * @param {lebai.structure.IStructure} message Structure message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Structure.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Structure message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.structure.Structure
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.structure.Structure} Structure
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Structure.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.structure.Structure();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 10: {
                            message.active = reader.bool();
                            break;
                        }
                    case 11: {
                            message.name = reader.string();
                            break;
                        }
                    case 12: {
                            message.kind = reader.int32();
                            break;
                        }
                    case 13: {
                            message.dof = reader.uint32();
                            break;
                        }
                    case 14: {
                            message.dh = reader.string();
                            break;
                        }
                    case 15: {
                            message.dyn = reader.string();
                            break;
                        }
                    case 16: {
                            message.servo = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Structure message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.structure.Structure
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.structure.Structure} Structure
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Structure.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Structure message.
             * @function verify
             * @memberof lebai.structure.Structure
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Structure.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.active != null && message.hasOwnProperty("active"))
                    if (typeof message.active !== "boolean")
                        return "active: boolean expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.kind != null && message.hasOwnProperty("kind"))
                    switch (message.kind) {
                    default:
                        return "kind: enum value expected";
                    case 0:
                    case 1:
                    case 11:
                        break;
                    }
                if (message.dof != null && message.hasOwnProperty("dof"))
                    if (!$util.isInteger(message.dof))
                        return "dof: integer expected";
                if (message.dh != null && message.hasOwnProperty("dh"))
                    if (!$util.isString(message.dh))
                        return "dh: string expected";
                if (message.dyn != null && message.hasOwnProperty("dyn"))
                    if (!$util.isString(message.dyn))
                        return "dyn: string expected";
                if (message.servo != null && message.hasOwnProperty("servo"))
                    if (!$util.isString(message.servo))
                        return "servo: string expected";
                return null;
            };

            /**
             * Creates a Structure message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.structure.Structure
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.structure.Structure} Structure
             */
            Structure.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.structure.Structure)
                    return object;
                var message = new $root.lebai.structure.Structure();
                if (object.active != null)
                    message.active = Boolean(object.active);
                if (object.name != null)
                    message.name = String(object.name);
                switch (object.kind) {
                default:
                    if (typeof object.kind === "number") {
                        message.kind = object.kind;
                        break;
                    }
                    break;
                case "J6M1":
                case 0:
                    message.kind = 0;
                    break;
                case "J6L1":
                case 1:
                    message.kind = 1;
                    break;
                case "J5L1":
                case 11:
                    message.kind = 11;
                    break;
                }
                if (object.dof != null)
                    message.dof = object.dof >>> 0;
                if (object.dh != null)
                    message.dh = String(object.dh);
                if (object.dyn != null)
                    message.dyn = String(object.dyn);
                if (object.servo != null)
                    message.servo = String(object.servo);
                return message;
            };

            /**
             * Creates a plain object from a Structure message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.structure.Structure
             * @static
             * @param {lebai.structure.Structure} message Structure
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Structure.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.active = false;
                    object.name = "";
                    object.kind = options.enums === String ? "J6M1" : 0;
                    object.dof = 0;
                    object.dh = "";
                    object.dyn = "";
                    object.servo = "";
                }
                if (message.active != null && message.hasOwnProperty("active"))
                    object.active = message.active;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.kind != null && message.hasOwnProperty("kind"))
                    object.kind = options.enums === String ? $root.lebai.system.ArmModel[message.kind] === undefined ? message.kind : $root.lebai.system.ArmModel[message.kind] : message.kind;
                if (message.dof != null && message.hasOwnProperty("dof"))
                    object.dof = message.dof;
                if (message.dh != null && message.hasOwnProperty("dh"))
                    object.dh = message.dh;
                if (message.dyn != null && message.hasOwnProperty("dyn"))
                    object.dyn = message.dyn;
                if (message.servo != null && message.hasOwnProperty("servo"))
                    object.servo = message.servo;
                return object;
            };

            /**
             * Converts this Structure to JSON.
             * @function toJSON
             * @memberof lebai.structure.Structure
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Structure.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Structure
             * @function getTypeUrl
             * @memberof lebai.structure.Structure
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Structure.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.structure.Structure";
            };

            return Structure;
        })();

        structure.SaveStructureRequest = (function() {

            /**
             * Properties of a SaveStructureRequest.
             * @memberof lebai.structure
             * @interface ISaveStructureRequest
             * @property {string|null} [name] SaveStructureRequest name
             * @property {lebai.structure.IStructure|null} [data] SaveStructureRequest data
             * @property {string|null} [dir] SaveStructureRequest dir
             */

            /**
             * Constructs a new SaveStructureRequest.
             * @memberof lebai.structure
             * @classdesc Represents a SaveStructureRequest.
             * @implements ISaveStructureRequest
             * @constructor
             * @param {lebai.structure.ISaveStructureRequest=} [properties] Properties to set
             */
            function SaveStructureRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SaveStructureRequest name.
             * @member {string} name
             * @memberof lebai.structure.SaveStructureRequest
             * @instance
             */
            SaveStructureRequest.prototype.name = "";

            /**
             * SaveStructureRequest data.
             * @member {lebai.structure.IStructure|null|undefined} data
             * @memberof lebai.structure.SaveStructureRequest
             * @instance
             */
            SaveStructureRequest.prototype.data = null;

            /**
             * SaveStructureRequest dir.
             * @member {string} dir
             * @memberof lebai.structure.SaveStructureRequest
             * @instance
             */
            SaveStructureRequest.prototype.dir = "";

            /**
             * Creates a new SaveStructureRequest instance using the specified properties.
             * @function create
             * @memberof lebai.structure.SaveStructureRequest
             * @static
             * @param {lebai.structure.ISaveStructureRequest=} [properties] Properties to set
             * @returns {lebai.structure.SaveStructureRequest} SaveStructureRequest instance
             */
            SaveStructureRequest.create = function create(properties) {
                return new SaveStructureRequest(properties);
            };

            /**
             * Encodes the specified SaveStructureRequest message. Does not implicitly {@link lebai.structure.SaveStructureRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.structure.SaveStructureRequest
             * @static
             * @param {lebai.structure.ISaveStructureRequest} message SaveStructureRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SaveStructureRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    $root.lebai.structure.Structure.encode(message.data, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.dir != null && Object.hasOwnProperty.call(message, "dir"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.dir);
                return writer;
            };

            /**
             * Encodes the specified SaveStructureRequest message, length delimited. Does not implicitly {@link lebai.structure.SaveStructureRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.structure.SaveStructureRequest
             * @static
             * @param {lebai.structure.ISaveStructureRequest} message SaveStructureRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SaveStructureRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SaveStructureRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.structure.SaveStructureRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.structure.SaveStructureRequest} SaveStructureRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SaveStructureRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.structure.SaveStructureRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.name = reader.string();
                            break;
                        }
                    case 2: {
                            message.data = $root.lebai.structure.Structure.decode(reader, reader.uint32());
                            break;
                        }
                    case 11: {
                            message.dir = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SaveStructureRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.structure.SaveStructureRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.structure.SaveStructureRequest} SaveStructureRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SaveStructureRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SaveStructureRequest message.
             * @function verify
             * @memberof lebai.structure.SaveStructureRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SaveStructureRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.data != null && message.hasOwnProperty("data")) {
                    var error = $root.lebai.structure.Structure.verify(message.data);
                    if (error)
                        return "data." + error;
                }
                if (message.dir != null && message.hasOwnProperty("dir"))
                    if (!$util.isString(message.dir))
                        return "dir: string expected";
                return null;
            };

            /**
             * Creates a SaveStructureRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.structure.SaveStructureRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.structure.SaveStructureRequest} SaveStructureRequest
             */
            SaveStructureRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.structure.SaveStructureRequest)
                    return object;
                var message = new $root.lebai.structure.SaveStructureRequest();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.data != null) {
                    if (typeof object.data !== "object")
                        throw TypeError(".lebai.structure.SaveStructureRequest.data: object expected");
                    message.data = $root.lebai.structure.Structure.fromObject(object.data);
                }
                if (object.dir != null)
                    message.dir = String(object.dir);
                return message;
            };

            /**
             * Creates a plain object from a SaveStructureRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.structure.SaveStructureRequest
             * @static
             * @param {lebai.structure.SaveStructureRequest} message SaveStructureRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SaveStructureRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.data = null;
                    object.dir = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.data != null && message.hasOwnProperty("data"))
                    object.data = $root.lebai.structure.Structure.toObject(message.data, options);
                if (message.dir != null && message.hasOwnProperty("dir"))
                    object.dir = message.dir;
                return object;
            };

            /**
             * Converts this SaveStructureRequest to JSON.
             * @function toJSON
             * @memberof lebai.structure.SaveStructureRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SaveStructureRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SaveStructureRequest
             * @function getTypeUrl
             * @memberof lebai.structure.SaveStructureRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SaveStructureRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.structure.SaveStructureRequest";
            };

            return SaveStructureRequest;
        })();

        structure.StructureService = (function() {

            /**
             * Constructs a new StructureService service.
             * @memberof lebai.structure
             * @classdesc Represents a StructureService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function StructureService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (StructureService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = StructureService;

            /**
             * Creates new StructureService service using the specified rpc implementation.
             * @function create
             * @memberof lebai.structure.StructureService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {StructureService} RPC service. Useful where requests and/or responses are streamed.
             */
            StructureService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link lebai.structure.StructureService#saveStructure}.
             * @memberof lebai.structure.StructureService
             * @typedef SaveStructureCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls SaveStructure.
             * @function saveStructure
             * @memberof lebai.structure.StructureService
             * @instance
             * @param {lebai.structure.ISaveStructureRequest} request SaveStructureRequest message or plain object
             * @param {lebai.structure.StructureService.SaveStructureCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(StructureService.prototype.saveStructure = function saveStructure(request, callback) {
                return this.rpcCall(saveStructure, $root.lebai.structure.SaveStructureRequest, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "SaveStructure" });

            /**
             * Calls SaveStructure.
             * @function saveStructure
             * @memberof lebai.structure.StructureService
             * @instance
             * @param {lebai.structure.ISaveStructureRequest} request SaveStructureRequest message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.structure.StructureService#loadStructure}.
             * @memberof lebai.structure.StructureService
             * @typedef LoadStructureCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.structure.Structure} [response] Structure
             */

            /**
             * Calls LoadStructure.
             * @function loadStructure
             * @memberof lebai.structure.StructureService
             * @instance
             * @param {lebai.db.ILoadRequest} request LoadRequest message or plain object
             * @param {lebai.structure.StructureService.LoadStructureCallback} callback Node-style callback called with the error, if any, and Structure
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(StructureService.prototype.loadStructure = function loadStructure(request, callback) {
                return this.rpcCall(loadStructure, $root.lebai.db.LoadRequest, $root.lebai.structure.Structure, request, callback);
            }, "name", { value: "LoadStructure" });

            /**
             * Calls LoadStructure.
             * @function loadStructure
             * @memberof lebai.structure.StructureService
             * @instance
             * @param {lebai.db.ILoadRequest} request LoadRequest message or plain object
             * @returns {Promise<lebai.structure.Structure>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.structure.StructureService#loadStructureList}.
             * @memberof lebai.structure.StructureService
             * @typedef LoadStructureListCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.db.LoadListResponse} [response] LoadListResponse
             */

            /**
             * Calls LoadStructureList.
             * @function loadStructureList
             * @memberof lebai.structure.StructureService
             * @instance
             * @param {lebai.db.ILoadListRequest} request LoadListRequest message or plain object
             * @param {lebai.structure.StructureService.LoadStructureListCallback} callback Node-style callback called with the error, if any, and LoadListResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(StructureService.prototype.loadStructureList = function loadStructureList(request, callback) {
                return this.rpcCall(loadStructureList, $root.lebai.db.LoadListRequest, $root.lebai.db.LoadListResponse, request, callback);
            }, "name", { value: "LoadStructureList" });

            /**
             * Calls LoadStructureList.
             * @function loadStructureList
             * @memberof lebai.structure.StructureService
             * @instance
             * @param {lebai.db.ILoadListRequest} request LoadListRequest message or plain object
             * @returns {Promise<lebai.db.LoadListResponse>} Promise
             * @variation 2
             */

            return StructureService;
        })();

        return structure;
    })();

    lebai.task = (function() {

        /**
         * Namespace task.
         * @memberof lebai
         * @namespace
         */
        var task = {};

        /**
         * TaskKind enum.
         * @name lebai.task.TaskKind
         * @enum {number}
         * @property {number} LUA=0 LUA value
         * @property {number} APP=10 APP value
         */
        task.TaskKind = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "LUA"] = 0;
            values[valuesById[10] = "APP"] = 10;
            return values;
        })();

        /**
         * TaskState enum.
         * @name lebai.task.TaskState
         * @enum {number}
         * @property {number} NONE=0 NONE value
         * @property {number} RUNNING=1 RUNNING value
         * @property {number} PAUSE=2 PAUSE value
         * @property {number} SUCCESS=3 SUCCESS value
         * @property {number} INTERRUPT=4 INTERRUPT value
         * @property {number} FAIL=5 FAIL value
         * @property {number} WAIT=10 WAIT value
         * @property {number} BEGIN=11 BEGIN value
         * @property {number} INTERRUPTING=14 INTERRUPTING value
         */
        task.TaskState = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "NONE"] = 0;
            values[valuesById[1] = "RUNNING"] = 1;
            values[valuesById[2] = "PAUSE"] = 2;
            values[valuesById[3] = "SUCCESS"] = 3;
            values[valuesById[4] = "INTERRUPT"] = 4;
            values[valuesById[5] = "FAIL"] = 5;
            values[valuesById[10] = "WAIT"] = 10;
            values[valuesById[11] = "BEGIN"] = 11;
            values[valuesById[14] = "INTERRUPTING"] = 14;
            return values;
        })();

        task.TaskIndex = (function() {

            /**
             * Properties of a TaskIndex.
             * @memberof lebai.task
             * @interface ITaskIndex
             * @property {number|null} [id] TaskIndex id
             */

            /**
             * Constructs a new TaskIndex.
             * @memberof lebai.task
             * @classdesc Represents a TaskIndex.
             * @implements ITaskIndex
             * @constructor
             * @param {lebai.task.ITaskIndex=} [properties] Properties to set
             */
            function TaskIndex(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TaskIndex id.
             * @member {number} id
             * @memberof lebai.task.TaskIndex
             * @instance
             */
            TaskIndex.prototype.id = 0;

            /**
             * Creates a new TaskIndex instance using the specified properties.
             * @function create
             * @memberof lebai.task.TaskIndex
             * @static
             * @param {lebai.task.ITaskIndex=} [properties] Properties to set
             * @returns {lebai.task.TaskIndex} TaskIndex instance
             */
            TaskIndex.create = function create(properties) {
                return new TaskIndex(properties);
            };

            /**
             * Encodes the specified TaskIndex message. Does not implicitly {@link lebai.task.TaskIndex.verify|verify} messages.
             * @function encode
             * @memberof lebai.task.TaskIndex
             * @static
             * @param {lebai.task.ITaskIndex} message TaskIndex message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TaskIndex.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
                return writer;
            };

            /**
             * Encodes the specified TaskIndex message, length delimited. Does not implicitly {@link lebai.task.TaskIndex.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.task.TaskIndex
             * @static
             * @param {lebai.task.ITaskIndex} message TaskIndex message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TaskIndex.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TaskIndex message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.task.TaskIndex
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.task.TaskIndex} TaskIndex
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TaskIndex.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.task.TaskIndex();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.id = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TaskIndex message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.task.TaskIndex
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.task.TaskIndex} TaskIndex
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TaskIndex.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TaskIndex message.
             * @function verify
             * @memberof lebai.task.TaskIndex
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TaskIndex.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id))
                        return "id: integer expected";
                return null;
            };

            /**
             * Creates a TaskIndex message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.task.TaskIndex
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.task.TaskIndex} TaskIndex
             */
            TaskIndex.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.task.TaskIndex)
                    return object;
                var message = new $root.lebai.task.TaskIndex();
                if (object.id != null)
                    message.id = object.id >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a TaskIndex message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.task.TaskIndex
             * @static
             * @param {lebai.task.TaskIndex} message TaskIndex
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TaskIndex.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.id = 0;
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                return object;
            };

            /**
             * Converts this TaskIndex to JSON.
             * @function toJSON
             * @memberof lebai.task.TaskIndex
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TaskIndex.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for TaskIndex
             * @function getTypeUrl
             * @memberof lebai.task.TaskIndex
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            TaskIndex.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.task.TaskIndex";
            };

            return TaskIndex;
        })();

        task.Task = (function() {

            /**
             * Properties of a Task.
             * @memberof lebai.task
             * @interface ITask
             * @property {number|null} [id] Task id
             * @property {string|null} [blockId] Task blockId
             * @property {number|null} [eventId] Task eventId
             * @property {lebai.task.TaskState|null} [state] Task state
             * @property {number|null} [loopCount] Task loopCount
             * @property {number|null} [loopTo] Task loopTo
             * @property {boolean|null} [isParallel] Task isParallel
             * @property {boolean|null} [isSimu] Task isSimu
             * @property {string|null} [stdout] Task stdout
             * @property {google.protobuf.ITimestamp|null} [startedAt] Task startedAt
             * @property {google.protobuf.ITimestamp|null} [endedAt] Task endedAt
             * @property {google.protobuf.ITimestamp|null} [pauseAt] Task pauseAt
             * @property {number|null} [prePause] Task prePause
             * @property {lebai.task.TaskKind|null} [kind] Task kind
             * @property {string|null} [dir] Task dir
             * @property {string|null} [name] Task name
             * @property {Array.<string>|null} [params] Task params
             */

            /**
             * Constructs a new Task.
             * @memberof lebai.task
             * @classdesc Represents a Task.
             * @implements ITask
             * @constructor
             * @param {lebai.task.ITask=} [properties] Properties to set
             */
            function Task(properties) {
                this.params = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Task id.
             * @member {number} id
             * @memberof lebai.task.Task
             * @instance
             */
            Task.prototype.id = 0;

            /**
             * Task blockId.
             * @member {string} blockId
             * @memberof lebai.task.Task
             * @instance
             */
            Task.prototype.blockId = "";

            /**
             * Task eventId.
             * @member {number} eventId
             * @memberof lebai.task.Task
             * @instance
             */
            Task.prototype.eventId = 0;

            /**
             * Task state.
             * @member {lebai.task.TaskState} state
             * @memberof lebai.task.Task
             * @instance
             */
            Task.prototype.state = 0;

            /**
             * Task loopCount.
             * @member {number} loopCount
             * @memberof lebai.task.Task
             * @instance
             */
            Task.prototype.loopCount = 0;

            /**
             * Task loopTo.
             * @member {number} loopTo
             * @memberof lebai.task.Task
             * @instance
             */
            Task.prototype.loopTo = 0;

            /**
             * Task isParallel.
             * @member {boolean} isParallel
             * @memberof lebai.task.Task
             * @instance
             */
            Task.prototype.isParallel = false;

            /**
             * Task isSimu.
             * @member {boolean} isSimu
             * @memberof lebai.task.Task
             * @instance
             */
            Task.prototype.isSimu = false;

            /**
             * Task stdout.
             * @member {string} stdout
             * @memberof lebai.task.Task
             * @instance
             */
            Task.prototype.stdout = "";

            /**
             * Task startedAt.
             * @member {google.protobuf.ITimestamp|null|undefined} startedAt
             * @memberof lebai.task.Task
             * @instance
             */
            Task.prototype.startedAt = null;

            /**
             * Task endedAt.
             * @member {google.protobuf.ITimestamp|null|undefined} endedAt
             * @memberof lebai.task.Task
             * @instance
             */
            Task.prototype.endedAt = null;

            /**
             * Task pauseAt.
             * @member {google.protobuf.ITimestamp|null|undefined} pauseAt
             * @memberof lebai.task.Task
             * @instance
             */
            Task.prototype.pauseAt = null;

            /**
             * Task prePause.
             * @member {number} prePause
             * @memberof lebai.task.Task
             * @instance
             */
            Task.prototype.prePause = 0;

            /**
             * Task kind.
             * @member {lebai.task.TaskKind} kind
             * @memberof lebai.task.Task
             * @instance
             */
            Task.prototype.kind = 0;

            /**
             * Task dir.
             * @member {string} dir
             * @memberof lebai.task.Task
             * @instance
             */
            Task.prototype.dir = "";

            /**
             * Task name.
             * @member {string} name
             * @memberof lebai.task.Task
             * @instance
             */
            Task.prototype.name = "";

            /**
             * Task params.
             * @member {Array.<string>} params
             * @memberof lebai.task.Task
             * @instance
             */
            Task.prototype.params = $util.emptyArray;

            /**
             * Creates a new Task instance using the specified properties.
             * @function create
             * @memberof lebai.task.Task
             * @static
             * @param {lebai.task.ITask=} [properties] Properties to set
             * @returns {lebai.task.Task} Task instance
             */
            Task.create = function create(properties) {
                return new Task(properties);
            };

            /**
             * Encodes the specified Task message. Does not implicitly {@link lebai.task.Task.verify|verify} messages.
             * @function encode
             * @memberof lebai.task.Task
             * @static
             * @param {lebai.task.ITask} message Task message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Task.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
                if (message.blockId != null && Object.hasOwnProperty.call(message, "blockId"))
                    writer.uint32(/* id 10, wireType 2 =*/82).string(message.blockId);
                if (message.eventId != null && Object.hasOwnProperty.call(message, "eventId"))
                    writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.eventId);
                if (message.state != null && Object.hasOwnProperty.call(message, "state"))
                    writer.uint32(/* id 12, wireType 0 =*/96).int32(message.state);
                if (message.loopCount != null && Object.hasOwnProperty.call(message, "loopCount"))
                    writer.uint32(/* id 13, wireType 0 =*/104).uint32(message.loopCount);
                if (message.loopTo != null && Object.hasOwnProperty.call(message, "loopTo"))
                    writer.uint32(/* id 14, wireType 0 =*/112).uint32(message.loopTo);
                if (message.isParallel != null && Object.hasOwnProperty.call(message, "isParallel"))
                    writer.uint32(/* id 15, wireType 0 =*/120).bool(message.isParallel);
                if (message.isSimu != null && Object.hasOwnProperty.call(message, "isSimu"))
                    writer.uint32(/* id 16, wireType 0 =*/128).bool(message.isSimu);
                if (message.stdout != null && Object.hasOwnProperty.call(message, "stdout"))
                    writer.uint32(/* id 17, wireType 2 =*/138).string(message.stdout);
                if (message.startedAt != null && Object.hasOwnProperty.call(message, "startedAt"))
                    $root.google.protobuf.Timestamp.encode(message.startedAt, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
                if (message.endedAt != null && Object.hasOwnProperty.call(message, "endedAt"))
                    $root.google.protobuf.Timestamp.encode(message.endedAt, writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
                if (message.pauseAt != null && Object.hasOwnProperty.call(message, "pauseAt"))
                    $root.google.protobuf.Timestamp.encode(message.pauseAt, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
                if (message.prePause != null && Object.hasOwnProperty.call(message, "prePause"))
                    writer.uint32(/* id 21, wireType 0 =*/168).uint32(message.prePause);
                if (message.kind != null && Object.hasOwnProperty.call(message, "kind"))
                    writer.uint32(/* id 30, wireType 0 =*/240).int32(message.kind);
                if (message.dir != null && Object.hasOwnProperty.call(message, "dir"))
                    writer.uint32(/* id 31, wireType 2 =*/250).string(message.dir);
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 32, wireType 2 =*/258).string(message.name);
                if (message.params != null && message.params.length)
                    for (var i = 0; i < message.params.length; ++i)
                        writer.uint32(/* id 33, wireType 2 =*/266).string(message.params[i]);
                return writer;
            };

            /**
             * Encodes the specified Task message, length delimited. Does not implicitly {@link lebai.task.Task.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.task.Task
             * @static
             * @param {lebai.task.ITask} message Task message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Task.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Task message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.task.Task
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.task.Task} Task
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Task.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.task.Task();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.id = reader.uint32();
                            break;
                        }
                    case 10: {
                            message.blockId = reader.string();
                            break;
                        }
                    case 11: {
                            message.eventId = reader.uint32();
                            break;
                        }
                    case 12: {
                            message.state = reader.int32();
                            break;
                        }
                    case 13: {
                            message.loopCount = reader.uint32();
                            break;
                        }
                    case 14: {
                            message.loopTo = reader.uint32();
                            break;
                        }
                    case 15: {
                            message.isParallel = reader.bool();
                            break;
                        }
                    case 16: {
                            message.isSimu = reader.bool();
                            break;
                        }
                    case 17: {
                            message.stdout = reader.string();
                            break;
                        }
                    case 18: {
                            message.startedAt = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        }
                    case 19: {
                            message.endedAt = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        }
                    case 20: {
                            message.pauseAt = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                            break;
                        }
                    case 21: {
                            message.prePause = reader.uint32();
                            break;
                        }
                    case 30: {
                            message.kind = reader.int32();
                            break;
                        }
                    case 31: {
                            message.dir = reader.string();
                            break;
                        }
                    case 32: {
                            message.name = reader.string();
                            break;
                        }
                    case 33: {
                            if (!(message.params && message.params.length))
                                message.params = [];
                            message.params.push(reader.string());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Task message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.task.Task
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.task.Task} Task
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Task.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Task message.
             * @function verify
             * @memberof lebai.task.Task
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Task.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id))
                        return "id: integer expected";
                if (message.blockId != null && message.hasOwnProperty("blockId"))
                    if (!$util.isString(message.blockId))
                        return "blockId: string expected";
                if (message.eventId != null && message.hasOwnProperty("eventId"))
                    if (!$util.isInteger(message.eventId))
                        return "eventId: integer expected";
                if (message.state != null && message.hasOwnProperty("state"))
                    switch (message.state) {
                    default:
                        return "state: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 10:
                    case 11:
                    case 14:
                        break;
                    }
                if (message.loopCount != null && message.hasOwnProperty("loopCount"))
                    if (!$util.isInteger(message.loopCount))
                        return "loopCount: integer expected";
                if (message.loopTo != null && message.hasOwnProperty("loopTo"))
                    if (!$util.isInteger(message.loopTo))
                        return "loopTo: integer expected";
                if (message.isParallel != null && message.hasOwnProperty("isParallel"))
                    if (typeof message.isParallel !== "boolean")
                        return "isParallel: boolean expected";
                if (message.isSimu != null && message.hasOwnProperty("isSimu"))
                    if (typeof message.isSimu !== "boolean")
                        return "isSimu: boolean expected";
                if (message.stdout != null && message.hasOwnProperty("stdout"))
                    if (!$util.isString(message.stdout))
                        return "stdout: string expected";
                if (message.startedAt != null && message.hasOwnProperty("startedAt")) {
                    var error = $root.google.protobuf.Timestamp.verify(message.startedAt);
                    if (error)
                        return "startedAt." + error;
                }
                if (message.endedAt != null && message.hasOwnProperty("endedAt")) {
                    var error = $root.google.protobuf.Timestamp.verify(message.endedAt);
                    if (error)
                        return "endedAt." + error;
                }
                if (message.pauseAt != null && message.hasOwnProperty("pauseAt")) {
                    var error = $root.google.protobuf.Timestamp.verify(message.pauseAt);
                    if (error)
                        return "pauseAt." + error;
                }
                if (message.prePause != null && message.hasOwnProperty("prePause"))
                    if (!$util.isInteger(message.prePause))
                        return "prePause: integer expected";
                if (message.kind != null && message.hasOwnProperty("kind"))
                    switch (message.kind) {
                    default:
                        return "kind: enum value expected";
                    case 0:
                    case 10:
                        break;
                    }
                if (message.dir != null && message.hasOwnProperty("dir"))
                    if (!$util.isString(message.dir))
                        return "dir: string expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.params != null && message.hasOwnProperty("params")) {
                    if (!Array.isArray(message.params))
                        return "params: array expected";
                    for (var i = 0; i < message.params.length; ++i)
                        if (!$util.isString(message.params[i]))
                            return "params: string[] expected";
                }
                return null;
            };

            /**
             * Creates a Task message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.task.Task
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.task.Task} Task
             */
            Task.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.task.Task)
                    return object;
                var message = new $root.lebai.task.Task();
                if (object.id != null)
                    message.id = object.id >>> 0;
                if (object.blockId != null)
                    message.blockId = String(object.blockId);
                if (object.eventId != null)
                    message.eventId = object.eventId >>> 0;
                switch (object.state) {
                default:
                    if (typeof object.state === "number") {
                        message.state = object.state;
                        break;
                    }
                    break;
                case "NONE":
                case 0:
                    message.state = 0;
                    break;
                case "RUNNING":
                case 1:
                    message.state = 1;
                    break;
                case "PAUSE":
                case 2:
                    message.state = 2;
                    break;
                case "SUCCESS":
                case 3:
                    message.state = 3;
                    break;
                case "INTERRUPT":
                case 4:
                    message.state = 4;
                    break;
                case "FAIL":
                case 5:
                    message.state = 5;
                    break;
                case "WAIT":
                case 10:
                    message.state = 10;
                    break;
                case "BEGIN":
                case 11:
                    message.state = 11;
                    break;
                case "INTERRUPTING":
                case 14:
                    message.state = 14;
                    break;
                }
                if (object.loopCount != null)
                    message.loopCount = object.loopCount >>> 0;
                if (object.loopTo != null)
                    message.loopTo = object.loopTo >>> 0;
                if (object.isParallel != null)
                    message.isParallel = Boolean(object.isParallel);
                if (object.isSimu != null)
                    message.isSimu = Boolean(object.isSimu);
                if (object.stdout != null)
                    message.stdout = String(object.stdout);
                if (object.startedAt != null) {
                    if (typeof object.startedAt !== "object")
                        throw TypeError(".lebai.task.Task.startedAt: object expected");
                    message.startedAt = $root.google.protobuf.Timestamp.fromObject(object.startedAt);
                }
                if (object.endedAt != null) {
                    if (typeof object.endedAt !== "object")
                        throw TypeError(".lebai.task.Task.endedAt: object expected");
                    message.endedAt = $root.google.protobuf.Timestamp.fromObject(object.endedAt);
                }
                if (object.pauseAt != null) {
                    if (typeof object.pauseAt !== "object")
                        throw TypeError(".lebai.task.Task.pauseAt: object expected");
                    message.pauseAt = $root.google.protobuf.Timestamp.fromObject(object.pauseAt);
                }
                if (object.prePause != null)
                    message.prePause = object.prePause >>> 0;
                switch (object.kind) {
                default:
                    if (typeof object.kind === "number") {
                        message.kind = object.kind;
                        break;
                    }
                    break;
                case "LUA":
                case 0:
                    message.kind = 0;
                    break;
                case "APP":
                case 10:
                    message.kind = 10;
                    break;
                }
                if (object.dir != null)
                    message.dir = String(object.dir);
                if (object.name != null)
                    message.name = String(object.name);
                if (object.params) {
                    if (!Array.isArray(object.params))
                        throw TypeError(".lebai.task.Task.params: array expected");
                    message.params = [];
                    for (var i = 0; i < object.params.length; ++i)
                        message.params[i] = String(object.params[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a Task message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.task.Task
             * @static
             * @param {lebai.task.Task} message Task
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Task.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.params = [];
                if (options.defaults) {
                    object.id = 0;
                    object.blockId = "";
                    object.eventId = 0;
                    object.state = options.enums === String ? "NONE" : 0;
                    object.loopCount = 0;
                    object.loopTo = 0;
                    object.isParallel = false;
                    object.isSimu = false;
                    object.stdout = "";
                    object.startedAt = null;
                    object.endedAt = null;
                    object.pauseAt = null;
                    object.prePause = 0;
                    object.kind = options.enums === String ? "LUA" : 0;
                    object.dir = "";
                    object.name = "";
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.blockId != null && message.hasOwnProperty("blockId"))
                    object.blockId = message.blockId;
                if (message.eventId != null && message.hasOwnProperty("eventId"))
                    object.eventId = message.eventId;
                if (message.state != null && message.hasOwnProperty("state"))
                    object.state = options.enums === String ? $root.lebai.task.TaskState[message.state] === undefined ? message.state : $root.lebai.task.TaskState[message.state] : message.state;
                if (message.loopCount != null && message.hasOwnProperty("loopCount"))
                    object.loopCount = message.loopCount;
                if (message.loopTo != null && message.hasOwnProperty("loopTo"))
                    object.loopTo = message.loopTo;
                if (message.isParallel != null && message.hasOwnProperty("isParallel"))
                    object.isParallel = message.isParallel;
                if (message.isSimu != null && message.hasOwnProperty("isSimu"))
                    object.isSimu = message.isSimu;
                if (message.stdout != null && message.hasOwnProperty("stdout"))
                    object.stdout = message.stdout;
                if (message.startedAt != null && message.hasOwnProperty("startedAt"))
                    object.startedAt = $root.google.protobuf.Timestamp.toObject(message.startedAt, options);
                if (message.endedAt != null && message.hasOwnProperty("endedAt"))
                    object.endedAt = $root.google.protobuf.Timestamp.toObject(message.endedAt, options);
                if (message.pauseAt != null && message.hasOwnProperty("pauseAt"))
                    object.pauseAt = $root.google.protobuf.Timestamp.toObject(message.pauseAt, options);
                if (message.prePause != null && message.hasOwnProperty("prePause"))
                    object.prePause = message.prePause;
                if (message.kind != null && message.hasOwnProperty("kind"))
                    object.kind = options.enums === String ? $root.lebai.task.TaskKind[message.kind] === undefined ? message.kind : $root.lebai.task.TaskKind[message.kind] : message.kind;
                if (message.dir != null && message.hasOwnProperty("dir"))
                    object.dir = message.dir;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.params && message.params.length) {
                    object.params = [];
                    for (var j = 0; j < message.params.length; ++j)
                        object.params[j] = message.params[j];
                }
                return object;
            };

            /**
             * Converts this Task to JSON.
             * @function toJSON
             * @memberof lebai.task.Task
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Task.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Task
             * @function getTypeUrl
             * @memberof lebai.task.Task
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Task.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.task.Task";
            };

            return Task;
        })();

        task.TaskIds = (function() {

            /**
             * Properties of a TaskIds.
             * @memberof lebai.task
             * @interface ITaskIds
             * @property {Array.<number>|null} [ids] TaskIds ids
             */

            /**
             * Constructs a new TaskIds.
             * @memberof lebai.task
             * @classdesc Represents a TaskIds.
             * @implements ITaskIds
             * @constructor
             * @param {lebai.task.ITaskIds=} [properties] Properties to set
             */
            function TaskIds(properties) {
                this.ids = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TaskIds ids.
             * @member {Array.<number>} ids
             * @memberof lebai.task.TaskIds
             * @instance
             */
            TaskIds.prototype.ids = $util.emptyArray;

            /**
             * Creates a new TaskIds instance using the specified properties.
             * @function create
             * @memberof lebai.task.TaskIds
             * @static
             * @param {lebai.task.ITaskIds=} [properties] Properties to set
             * @returns {lebai.task.TaskIds} TaskIds instance
             */
            TaskIds.create = function create(properties) {
                return new TaskIds(properties);
            };

            /**
             * Encodes the specified TaskIds message. Does not implicitly {@link lebai.task.TaskIds.verify|verify} messages.
             * @function encode
             * @memberof lebai.task.TaskIds
             * @static
             * @param {lebai.task.ITaskIds} message TaskIds message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TaskIds.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.ids != null && message.ids.length) {
                    writer.uint32(/* id 1, wireType 2 =*/10).fork();
                    for (var i = 0; i < message.ids.length; ++i)
                        writer.uint32(message.ids[i]);
                    writer.ldelim();
                }
                return writer;
            };

            /**
             * Encodes the specified TaskIds message, length delimited. Does not implicitly {@link lebai.task.TaskIds.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.task.TaskIds
             * @static
             * @param {lebai.task.ITaskIds} message TaskIds message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TaskIds.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TaskIds message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.task.TaskIds
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.task.TaskIds} TaskIds
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TaskIds.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.task.TaskIds();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.ids && message.ids.length))
                                message.ids = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.ids.push(reader.uint32());
                            } else
                                message.ids.push(reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TaskIds message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.task.TaskIds
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.task.TaskIds} TaskIds
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TaskIds.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TaskIds message.
             * @function verify
             * @memberof lebai.task.TaskIds
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TaskIds.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.ids != null && message.hasOwnProperty("ids")) {
                    if (!Array.isArray(message.ids))
                        return "ids: array expected";
                    for (var i = 0; i < message.ids.length; ++i)
                        if (!$util.isInteger(message.ids[i]))
                            return "ids: integer[] expected";
                }
                return null;
            };

            /**
             * Creates a TaskIds message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.task.TaskIds
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.task.TaskIds} TaskIds
             */
            TaskIds.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.task.TaskIds)
                    return object;
                var message = new $root.lebai.task.TaskIds();
                if (object.ids) {
                    if (!Array.isArray(object.ids))
                        throw TypeError(".lebai.task.TaskIds.ids: array expected");
                    message.ids = [];
                    for (var i = 0; i < object.ids.length; ++i)
                        message.ids[i] = object.ids[i] >>> 0;
                }
                return message;
            };

            /**
             * Creates a plain object from a TaskIds message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.task.TaskIds
             * @static
             * @param {lebai.task.TaskIds} message TaskIds
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TaskIds.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.ids = [];
                if (message.ids && message.ids.length) {
                    object.ids = [];
                    for (var j = 0; j < message.ids.length; ++j)
                        object.ids[j] = message.ids[j];
                }
                return object;
            };

            /**
             * Converts this TaskIds to JSON.
             * @function toJSON
             * @memberof lebai.task.TaskIds
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TaskIds.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for TaskIds
             * @function getTypeUrl
             * @memberof lebai.task.TaskIds
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            TaskIds.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.task.TaskIds";
            };

            return TaskIds;
        })();

        task.Tasks = (function() {

            /**
             * Properties of a Tasks.
             * @memberof lebai.task
             * @interface ITasks
             * @property {Array.<lebai.task.ITask>|null} [tasks] Tasks tasks
             */

            /**
             * Constructs a new Tasks.
             * @memberof lebai.task
             * @classdesc Represents a Tasks.
             * @implements ITasks
             * @constructor
             * @param {lebai.task.ITasks=} [properties] Properties to set
             */
            function Tasks(properties) {
                this.tasks = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Tasks tasks.
             * @member {Array.<lebai.task.ITask>} tasks
             * @memberof lebai.task.Tasks
             * @instance
             */
            Tasks.prototype.tasks = $util.emptyArray;

            /**
             * Creates a new Tasks instance using the specified properties.
             * @function create
             * @memberof lebai.task.Tasks
             * @static
             * @param {lebai.task.ITasks=} [properties] Properties to set
             * @returns {lebai.task.Tasks} Tasks instance
             */
            Tasks.create = function create(properties) {
                return new Tasks(properties);
            };

            /**
             * Encodes the specified Tasks message. Does not implicitly {@link lebai.task.Tasks.verify|verify} messages.
             * @function encode
             * @memberof lebai.task.Tasks
             * @static
             * @param {lebai.task.ITasks} message Tasks message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Tasks.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tasks != null && message.tasks.length)
                    for (var i = 0; i < message.tasks.length; ++i)
                        $root.lebai.task.Task.encode(message.tasks[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Tasks message, length delimited. Does not implicitly {@link lebai.task.Tasks.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.task.Tasks
             * @static
             * @param {lebai.task.ITasks} message Tasks message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Tasks.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Tasks message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.task.Tasks
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.task.Tasks} Tasks
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Tasks.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.task.Tasks();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.tasks && message.tasks.length))
                                message.tasks = [];
                            message.tasks.push($root.lebai.task.Task.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Tasks message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.task.Tasks
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.task.Tasks} Tasks
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Tasks.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Tasks message.
             * @function verify
             * @memberof lebai.task.Tasks
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Tasks.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tasks != null && message.hasOwnProperty("tasks")) {
                    if (!Array.isArray(message.tasks))
                        return "tasks: array expected";
                    for (var i = 0; i < message.tasks.length; ++i) {
                        var error = $root.lebai.task.Task.verify(message.tasks[i]);
                        if (error)
                            return "tasks." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Tasks message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.task.Tasks
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.task.Tasks} Tasks
             */
            Tasks.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.task.Tasks)
                    return object;
                var message = new $root.lebai.task.Tasks();
                if (object.tasks) {
                    if (!Array.isArray(object.tasks))
                        throw TypeError(".lebai.task.Tasks.tasks: array expected");
                    message.tasks = [];
                    for (var i = 0; i < object.tasks.length; ++i) {
                        if (typeof object.tasks[i] !== "object")
                            throw TypeError(".lebai.task.Tasks.tasks: object expected");
                        message.tasks[i] = $root.lebai.task.Task.fromObject(object.tasks[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a Tasks message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.task.Tasks
             * @static
             * @param {lebai.task.Tasks} message Tasks
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Tasks.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.tasks = [];
                if (message.tasks && message.tasks.length) {
                    object.tasks = [];
                    for (var j = 0; j < message.tasks.length; ++j)
                        object.tasks[j] = $root.lebai.task.Task.toObject(message.tasks[j], options);
                }
                return object;
            };

            /**
             * Converts this Tasks to JSON.
             * @function toJSON
             * @memberof lebai.task.Tasks
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Tasks.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Tasks
             * @function getTypeUrl
             * @memberof lebai.task.Tasks
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Tasks.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.task.Tasks";
            };

            return Tasks;
        })();

        task.TaskStdout = (function() {

            /**
             * Properties of a TaskStdout.
             * @memberof lebai.task
             * @interface ITaskStdout
             * @property {number|null} [id] TaskStdout id
             * @property {boolean|null} [done] TaskStdout done
             * @property {string|null} [stdout] TaskStdout stdout
             */

            /**
             * Constructs a new TaskStdout.
             * @memberof lebai.task
             * @classdesc Represents a TaskStdout.
             * @implements ITaskStdout
             * @constructor
             * @param {lebai.task.ITaskStdout=} [properties] Properties to set
             */
            function TaskStdout(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TaskStdout id.
             * @member {number} id
             * @memberof lebai.task.TaskStdout
             * @instance
             */
            TaskStdout.prototype.id = 0;

            /**
             * TaskStdout done.
             * @member {boolean} done
             * @memberof lebai.task.TaskStdout
             * @instance
             */
            TaskStdout.prototype.done = false;

            /**
             * TaskStdout stdout.
             * @member {string} stdout
             * @memberof lebai.task.TaskStdout
             * @instance
             */
            TaskStdout.prototype.stdout = "";

            /**
             * Creates a new TaskStdout instance using the specified properties.
             * @function create
             * @memberof lebai.task.TaskStdout
             * @static
             * @param {lebai.task.ITaskStdout=} [properties] Properties to set
             * @returns {lebai.task.TaskStdout} TaskStdout instance
             */
            TaskStdout.create = function create(properties) {
                return new TaskStdout(properties);
            };

            /**
             * Encodes the specified TaskStdout message. Does not implicitly {@link lebai.task.TaskStdout.verify|verify} messages.
             * @function encode
             * @memberof lebai.task.TaskStdout
             * @static
             * @param {lebai.task.ITaskStdout} message TaskStdout message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TaskStdout.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
                if (message.done != null && Object.hasOwnProperty.call(message, "done"))
                    writer.uint32(/* id 11, wireType 0 =*/88).bool(message.done);
                if (message.stdout != null && Object.hasOwnProperty.call(message, "stdout"))
                    writer.uint32(/* id 12, wireType 2 =*/98).string(message.stdout);
                return writer;
            };

            /**
             * Encodes the specified TaskStdout message, length delimited. Does not implicitly {@link lebai.task.TaskStdout.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.task.TaskStdout
             * @static
             * @param {lebai.task.ITaskStdout} message TaskStdout message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TaskStdout.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TaskStdout message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.task.TaskStdout
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.task.TaskStdout} TaskStdout
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TaskStdout.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.task.TaskStdout();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.id = reader.uint32();
                            break;
                        }
                    case 11: {
                            message.done = reader.bool();
                            break;
                        }
                    case 12: {
                            message.stdout = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TaskStdout message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.task.TaskStdout
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.task.TaskStdout} TaskStdout
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TaskStdout.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TaskStdout message.
             * @function verify
             * @memberof lebai.task.TaskStdout
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TaskStdout.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id))
                        return "id: integer expected";
                if (message.done != null && message.hasOwnProperty("done"))
                    if (typeof message.done !== "boolean")
                        return "done: boolean expected";
                if (message.stdout != null && message.hasOwnProperty("stdout"))
                    if (!$util.isString(message.stdout))
                        return "stdout: string expected";
                return null;
            };

            /**
             * Creates a TaskStdout message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.task.TaskStdout
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.task.TaskStdout} TaskStdout
             */
            TaskStdout.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.task.TaskStdout)
                    return object;
                var message = new $root.lebai.task.TaskStdout();
                if (object.id != null)
                    message.id = object.id >>> 0;
                if (object.done != null)
                    message.done = Boolean(object.done);
                if (object.stdout != null)
                    message.stdout = String(object.stdout);
                return message;
            };

            /**
             * Creates a plain object from a TaskStdout message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.task.TaskStdout
             * @static
             * @param {lebai.task.TaskStdout} message TaskStdout
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TaskStdout.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.id = 0;
                    object.done = false;
                    object.stdout = "";
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.done != null && message.hasOwnProperty("done"))
                    object.done = message.done;
                if (message.stdout != null && message.hasOwnProperty("stdout"))
                    object.stdout = message.stdout;
                return object;
            };

            /**
             * Converts this TaskStdout to JSON.
             * @function toJSON
             * @memberof lebai.task.TaskStdout
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TaskStdout.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for TaskStdout
             * @function getTypeUrl
             * @memberof lebai.task.TaskStdout
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            TaskStdout.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.task.TaskStdout";
            };

            return TaskStdout;
        })();

        task.StartTaskRequest = (function() {

            /**
             * Properties of a StartTaskRequest.
             * @memberof lebai.task
             * @interface IStartTaskRequest
             * @property {string|null} [name] StartTaskRequest name
             * @property {boolean|null} [isParallel] StartTaskRequest isParallel
             * @property {number|null} [loopTo] StartTaskRequest loopTo
             * @property {string|null} [dir] StartTaskRequest dir
             * @property {lebai.task.TaskKind|null} [kind] StartTaskRequest kind
             * @property {Array.<string>|null} [params] StartTaskRequest params
             */

            /**
             * Constructs a new StartTaskRequest.
             * @memberof lebai.task
             * @classdesc Represents a StartTaskRequest.
             * @implements IStartTaskRequest
             * @constructor
             * @param {lebai.task.IStartTaskRequest=} [properties] Properties to set
             */
            function StartTaskRequest(properties) {
                this.params = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StartTaskRequest name.
             * @member {string} name
             * @memberof lebai.task.StartTaskRequest
             * @instance
             */
            StartTaskRequest.prototype.name = "";

            /**
             * StartTaskRequest isParallel.
             * @member {boolean} isParallel
             * @memberof lebai.task.StartTaskRequest
             * @instance
             */
            StartTaskRequest.prototype.isParallel = false;

            /**
             * StartTaskRequest loopTo.
             * @member {number} loopTo
             * @memberof lebai.task.StartTaskRequest
             * @instance
             */
            StartTaskRequest.prototype.loopTo = 0;

            /**
             * StartTaskRequest dir.
             * @member {string} dir
             * @memberof lebai.task.StartTaskRequest
             * @instance
             */
            StartTaskRequest.prototype.dir = "";

            /**
             * StartTaskRequest kind.
             * @member {lebai.task.TaskKind} kind
             * @memberof lebai.task.StartTaskRequest
             * @instance
             */
            StartTaskRequest.prototype.kind = 0;

            /**
             * StartTaskRequest params.
             * @member {Array.<string>} params
             * @memberof lebai.task.StartTaskRequest
             * @instance
             */
            StartTaskRequest.prototype.params = $util.emptyArray;

            /**
             * Creates a new StartTaskRequest instance using the specified properties.
             * @function create
             * @memberof lebai.task.StartTaskRequest
             * @static
             * @param {lebai.task.IStartTaskRequest=} [properties] Properties to set
             * @returns {lebai.task.StartTaskRequest} StartTaskRequest instance
             */
            StartTaskRequest.create = function create(properties) {
                return new StartTaskRequest(properties);
            };

            /**
             * Encodes the specified StartTaskRequest message. Does not implicitly {@link lebai.task.StartTaskRequest.verify|verify} messages.
             * @function encode
             * @memberof lebai.task.StartTaskRequest
             * @static
             * @param {lebai.task.IStartTaskRequest} message StartTaskRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StartTaskRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.isParallel != null && Object.hasOwnProperty.call(message, "isParallel"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isParallel);
                if (message.loopTo != null && Object.hasOwnProperty.call(message, "loopTo"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.loopTo);
                if (message.dir != null && Object.hasOwnProperty.call(message, "dir"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.dir);
                if (message.kind != null && Object.hasOwnProperty.call(message, "kind"))
                    writer.uint32(/* id 12, wireType 0 =*/96).int32(message.kind);
                if (message.params != null && message.params.length)
                    for (var i = 0; i < message.params.length; ++i)
                        writer.uint32(/* id 22, wireType 2 =*/178).string(message.params[i]);
                return writer;
            };

            /**
             * Encodes the specified StartTaskRequest message, length delimited. Does not implicitly {@link lebai.task.StartTaskRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.task.StartTaskRequest
             * @static
             * @param {lebai.task.IStartTaskRequest} message StartTaskRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StartTaskRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StartTaskRequest message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.task.StartTaskRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.task.StartTaskRequest} StartTaskRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StartTaskRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.task.StartTaskRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.name = reader.string();
                            break;
                        }
                    case 2: {
                            message.isParallel = reader.bool();
                            break;
                        }
                    case 3: {
                            message.loopTo = reader.uint32();
                            break;
                        }
                    case 11: {
                            message.dir = reader.string();
                            break;
                        }
                    case 12: {
                            message.kind = reader.int32();
                            break;
                        }
                    case 22: {
                            if (!(message.params && message.params.length))
                                message.params = [];
                            message.params.push(reader.string());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StartTaskRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.task.StartTaskRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.task.StartTaskRequest} StartTaskRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StartTaskRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StartTaskRequest message.
             * @function verify
             * @memberof lebai.task.StartTaskRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StartTaskRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.isParallel != null && message.hasOwnProperty("isParallel"))
                    if (typeof message.isParallel !== "boolean")
                        return "isParallel: boolean expected";
                if (message.loopTo != null && message.hasOwnProperty("loopTo"))
                    if (!$util.isInteger(message.loopTo))
                        return "loopTo: integer expected";
                if (message.dir != null && message.hasOwnProperty("dir"))
                    if (!$util.isString(message.dir))
                        return "dir: string expected";
                if (message.kind != null && message.hasOwnProperty("kind"))
                    switch (message.kind) {
                    default:
                        return "kind: enum value expected";
                    case 0:
                    case 10:
                        break;
                    }
                if (message.params != null && message.hasOwnProperty("params")) {
                    if (!Array.isArray(message.params))
                        return "params: array expected";
                    for (var i = 0; i < message.params.length; ++i)
                        if (!$util.isString(message.params[i]))
                            return "params: string[] expected";
                }
                return null;
            };

            /**
             * Creates a StartTaskRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.task.StartTaskRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.task.StartTaskRequest} StartTaskRequest
             */
            StartTaskRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.task.StartTaskRequest)
                    return object;
                var message = new $root.lebai.task.StartTaskRequest();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.isParallel != null)
                    message.isParallel = Boolean(object.isParallel);
                if (object.loopTo != null)
                    message.loopTo = object.loopTo >>> 0;
                if (object.dir != null)
                    message.dir = String(object.dir);
                switch (object.kind) {
                default:
                    if (typeof object.kind === "number") {
                        message.kind = object.kind;
                        break;
                    }
                    break;
                case "LUA":
                case 0:
                    message.kind = 0;
                    break;
                case "APP":
                case 10:
                    message.kind = 10;
                    break;
                }
                if (object.params) {
                    if (!Array.isArray(object.params))
                        throw TypeError(".lebai.task.StartTaskRequest.params: array expected");
                    message.params = [];
                    for (var i = 0; i < object.params.length; ++i)
                        message.params[i] = String(object.params[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a StartTaskRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.task.StartTaskRequest
             * @static
             * @param {lebai.task.StartTaskRequest} message StartTaskRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StartTaskRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.params = [];
                if (options.defaults) {
                    object.name = "";
                    object.isParallel = false;
                    object.loopTo = 0;
                    object.dir = "";
                    object.kind = options.enums === String ? "LUA" : 0;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.isParallel != null && message.hasOwnProperty("isParallel"))
                    object.isParallel = message.isParallel;
                if (message.loopTo != null && message.hasOwnProperty("loopTo"))
                    object.loopTo = message.loopTo;
                if (message.dir != null && message.hasOwnProperty("dir"))
                    object.dir = message.dir;
                if (message.kind != null && message.hasOwnProperty("kind"))
                    object.kind = options.enums === String ? $root.lebai.task.TaskKind[message.kind] === undefined ? message.kind : $root.lebai.task.TaskKind[message.kind] : message.kind;
                if (message.params && message.params.length) {
                    object.params = [];
                    for (var j = 0; j < message.params.length; ++j)
                        object.params[j] = message.params[j];
                }
                return object;
            };

            /**
             * Converts this StartTaskRequest to JSON.
             * @function toJSON
             * @memberof lebai.task.StartTaskRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StartTaskRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for StartTaskRequest
             * @function getTypeUrl
             * @memberof lebai.task.StartTaskRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            StartTaskRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.task.StartTaskRequest";
            };

            return StartTaskRequest;
        })();

        task.TaskService = (function() {

            /**
             * Constructs a new TaskService service.
             * @memberof lebai.task
             * @classdesc Represents a TaskService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function TaskService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (TaskService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = TaskService;

            /**
             * Creates new TaskService service using the specified rpc implementation.
             * @function create
             * @memberof lebai.task.TaskService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {TaskService} RPC service. Useful where requests and/or responses are streamed.
             */
            TaskService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link lebai.task.TaskService#loadTask}.
             * @memberof lebai.task.TaskService
             * @typedef LoadTaskCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.task.Task} [response] Task
             */

            /**
             * Calls LoadTask.
             * @function loadTask
             * @memberof lebai.task.TaskService
             * @instance
             * @param {lebai.task.ITaskIndex} request TaskIndex message or plain object
             * @param {lebai.task.TaskService.LoadTaskCallback} callback Node-style callback called with the error, if any, and Task
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(TaskService.prototype.loadTask = function loadTask(request, callback) {
                return this.rpcCall(loadTask, $root.lebai.task.TaskIndex, $root.lebai.task.Task, request, callback);
            }, "name", { value: "LoadTask" });

            /**
             * Calls LoadTask.
             * @function loadTask
             * @memberof lebai.task.TaskService
             * @instance
             * @param {lebai.task.ITaskIndex} request TaskIndex message or plain object
             * @returns {Promise<lebai.task.Task>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.task.TaskService#loadTaskList}.
             * @memberof lebai.task.TaskService
             * @typedef LoadTaskListCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.task.TaskIds} [response] TaskIds
             */

            /**
             * Calls LoadTaskList.
             * @function loadTaskList
             * @memberof lebai.task.TaskService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {lebai.task.TaskService.LoadTaskListCallback} callback Node-style callback called with the error, if any, and TaskIds
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(TaskService.prototype.loadTaskList = function loadTaskList(request, callback) {
                return this.rpcCall(loadTaskList, $root.google.protobuf.Empty, $root.lebai.task.TaskIds, request, callback);
            }, "name", { value: "LoadTaskList" });

            /**
             * Calls LoadTaskList.
             * @function loadTaskList
             * @memberof lebai.task.TaskService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<lebai.task.TaskIds>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.task.TaskService#loadRunningTasks}.
             * @memberof lebai.task.TaskService
             * @typedef LoadRunningTasksCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.task.Tasks} [response] Tasks
             */

            /**
             * Calls LoadRunningTasks.
             * @function loadRunningTasks
             * @memberof lebai.task.TaskService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {lebai.task.TaskService.LoadRunningTasksCallback} callback Node-style callback called with the error, if any, and Tasks
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(TaskService.prototype.loadRunningTasks = function loadRunningTasks(request, callback) {
                return this.rpcCall(loadRunningTasks, $root.google.protobuf.Empty, $root.lebai.task.Tasks, request, callback);
            }, "name", { value: "LoadRunningTasks" });

            /**
             * Calls LoadRunningTasks.
             * @function loadRunningTasks
             * @memberof lebai.task.TaskService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<lebai.task.Tasks>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.task.TaskService#startTask}.
             * @memberof lebai.task.TaskService
             * @typedef StartTaskCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.task.TaskIndex} [response] TaskIndex
             */

            /**
             * Calls StartTask.
             * @function startTask
             * @memberof lebai.task.TaskService
             * @instance
             * @param {lebai.task.IStartTaskRequest} request StartTaskRequest message or plain object
             * @param {lebai.task.TaskService.StartTaskCallback} callback Node-style callback called with the error, if any, and TaskIndex
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(TaskService.prototype.startTask = function startTask(request, callback) {
                return this.rpcCall(startTask, $root.lebai.task.StartTaskRequest, $root.lebai.task.TaskIndex, request, callback);
            }, "name", { value: "StartTask" });

            /**
             * Calls StartTask.
             * @function startTask
             * @memberof lebai.task.TaskService
             * @instance
             * @param {lebai.task.IStartTaskRequest} request StartTaskRequest message or plain object
             * @returns {Promise<lebai.task.TaskIndex>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.task.TaskService#getTaskStdout}.
             * @memberof lebai.task.TaskService
             * @typedef GetTaskStdoutCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.task.TaskStdout} [response] TaskStdout
             */

            /**
             * Calls GetTaskStdout.
             * @function getTaskStdout
             * @memberof lebai.task.TaskService
             * @instance
             * @param {lebai.task.ITaskIndex} request TaskIndex message or plain object
             * @param {lebai.task.TaskService.GetTaskStdoutCallback} callback Node-style callback called with the error, if any, and TaskStdout
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(TaskService.prototype.getTaskStdout = function getTaskStdout(request, callback) {
                return this.rpcCall(getTaskStdout, $root.lebai.task.TaskIndex, $root.lebai.task.TaskStdout, request, callback);
            }, "name", { value: "GetTaskStdout" });

            /**
             * Calls GetTaskStdout.
             * @function getTaskStdout
             * @memberof lebai.task.TaskService
             * @instance
             * @param {lebai.task.ITaskIndex} request TaskIndex message or plain object
             * @returns {Promise<lebai.task.TaskStdout>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.task.TaskService#subTaskStdout}.
             * @memberof lebai.task.TaskService
             * @typedef SubTaskStdoutCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.task.TaskStdout} [response] TaskStdout
             */

            /**
             * Calls SubTaskStdout.
             * @function subTaskStdout
             * @memberof lebai.task.TaskService
             * @instance
             * @param {lebai.task.ITaskIndex} request TaskIndex message or plain object
             * @param {lebai.task.TaskService.SubTaskStdoutCallback} callback Node-style callback called with the error, if any, and TaskStdout
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(TaskService.prototype.subTaskStdout = function subTaskStdout(request, callback) {
                return this.rpcCall(subTaskStdout, $root.lebai.task.TaskIndex, $root.lebai.task.TaskStdout, request, callback);
            }, "name", { value: "SubTaskStdout" });

            /**
             * Calls SubTaskStdout.
             * @function subTaskStdout
             * @memberof lebai.task.TaskService
             * @instance
             * @param {lebai.task.ITaskIndex} request TaskIndex message or plain object
             * @returns {Promise<lebai.task.TaskStdout>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.task.TaskService#waitTask}.
             * @memberof lebai.task.TaskService
             * @typedef WaitTaskCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.task.TaskStdout} [response] TaskStdout
             */

            /**
             * Calls WaitTask.
             * @function waitTask
             * @memberof lebai.task.TaskService
             * @instance
             * @param {lebai.task.ITaskIndex} request TaskIndex message or plain object
             * @param {lebai.task.TaskService.WaitTaskCallback} callback Node-style callback called with the error, if any, and TaskStdout
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(TaskService.prototype.waitTask = function waitTask(request, callback) {
                return this.rpcCall(waitTask, $root.lebai.task.TaskIndex, $root.lebai.task.TaskStdout, request, callback);
            }, "name", { value: "WaitTask" });

            /**
             * Calls WaitTask.
             * @function waitTask
             * @memberof lebai.task.TaskService
             * @instance
             * @param {lebai.task.ITaskIndex} request TaskIndex message or plain object
             * @returns {Promise<lebai.task.TaskStdout>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.task.TaskService#pauseTask}.
             * @memberof lebai.task.TaskService
             * @typedef PauseTaskCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls PauseTask.
             * @function pauseTask
             * @memberof lebai.task.TaskService
             * @instance
             * @param {lebai.task.ITaskIndex} request TaskIndex message or plain object
             * @param {lebai.task.TaskService.PauseTaskCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(TaskService.prototype.pauseTask = function pauseTask(request, callback) {
                return this.rpcCall(pauseTask, $root.lebai.task.TaskIndex, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "PauseTask" });

            /**
             * Calls PauseTask.
             * @function pauseTask
             * @memberof lebai.task.TaskService
             * @instance
             * @param {lebai.task.ITaskIndex} request TaskIndex message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.task.TaskService#resumeTask}.
             * @memberof lebai.task.TaskService
             * @typedef ResumeTaskCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls ResumeTask.
             * @function resumeTask
             * @memberof lebai.task.TaskService
             * @instance
             * @param {lebai.task.ITaskIndex} request TaskIndex message or plain object
             * @param {lebai.task.TaskService.ResumeTaskCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(TaskService.prototype.resumeTask = function resumeTask(request, callback) {
                return this.rpcCall(resumeTask, $root.lebai.task.TaskIndex, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "ResumeTask" });

            /**
             * Calls ResumeTask.
             * @function resumeTask
             * @memberof lebai.task.TaskService
             * @instance
             * @param {lebai.task.ITaskIndex} request TaskIndex message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.task.TaskService#cancelTask}.
             * @memberof lebai.task.TaskService
             * @typedef CancelTaskCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls CancelTask.
             * @function cancelTask
             * @memberof lebai.task.TaskService
             * @instance
             * @param {lebai.task.ITaskIndex} request TaskIndex message or plain object
             * @param {lebai.task.TaskService.CancelTaskCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(TaskService.prototype.cancelTask = function cancelTask(request, callback) {
                return this.rpcCall(cancelTask, $root.lebai.task.TaskIndex, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "CancelTask" });

            /**
             * Calls CancelTask.
             * @function cancelTask
             * @memberof lebai.task.TaskService
             * @instance
             * @param {lebai.task.ITaskIndex} request TaskIndex message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            return TaskService;
        })();

        return task;
    })();

    lebai.trigger = (function() {

        /**
         * Namespace trigger.
         * @memberof lebai
         * @namespace
         */
        var trigger = {};

        trigger.Condition = (function() {

            /**
             * Properties of a Condition.
             * @memberof lebai.trigger
             * @interface ICondition
             * @property {Array.<lebai.io.IButtonIndex>|null} [pressed] Condition pressed
             * @property {lebai.io.IButtonIndex|null} [button] Condition button
             * @property {lebai.io.IButtonStatus|null} [status] Condition status
             */

            /**
             * Constructs a new Condition.
             * @memberof lebai.trigger
             * @classdesc Represents a Condition.
             * @implements ICondition
             * @constructor
             * @param {lebai.trigger.ICondition=} [properties] Properties to set
             */
            function Condition(properties) {
                this.pressed = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Condition pressed.
             * @member {Array.<lebai.io.IButtonIndex>} pressed
             * @memberof lebai.trigger.Condition
             * @instance
             */
            Condition.prototype.pressed = $util.emptyArray;

            /**
             * Condition button.
             * @member {lebai.io.IButtonIndex|null|undefined} button
             * @memberof lebai.trigger.Condition
             * @instance
             */
            Condition.prototype.button = null;

            /**
             * Condition status.
             * @member {lebai.io.IButtonStatus|null|undefined} status
             * @memberof lebai.trigger.Condition
             * @instance
             */
            Condition.prototype.status = null;

            /**
             * Creates a new Condition instance using the specified properties.
             * @function create
             * @memberof lebai.trigger.Condition
             * @static
             * @param {lebai.trigger.ICondition=} [properties] Properties to set
             * @returns {lebai.trigger.Condition} Condition instance
             */
            Condition.create = function create(properties) {
                return new Condition(properties);
            };

            /**
             * Encodes the specified Condition message. Does not implicitly {@link lebai.trigger.Condition.verify|verify} messages.
             * @function encode
             * @memberof lebai.trigger.Condition
             * @static
             * @param {lebai.trigger.ICondition} message Condition message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Condition.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.pressed != null && message.pressed.length)
                    for (var i = 0; i < message.pressed.length; ++i)
                        $root.lebai.io.ButtonIndex.encode(message.pressed[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.button != null && Object.hasOwnProperty.call(message, "button"))
                    $root.lebai.io.ButtonIndex.encode(message.button, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                    $root.lebai.io.ButtonStatus.encode(message.status, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Condition message, length delimited. Does not implicitly {@link lebai.trigger.Condition.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.trigger.Condition
             * @static
             * @param {lebai.trigger.ICondition} message Condition message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Condition.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Condition message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.trigger.Condition
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.trigger.Condition} Condition
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Condition.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.trigger.Condition();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.pressed && message.pressed.length))
                                message.pressed = [];
                            message.pressed.push($root.lebai.io.ButtonIndex.decode(reader, reader.uint32()));
                            break;
                        }
                    case 11: {
                            message.button = $root.lebai.io.ButtonIndex.decode(reader, reader.uint32());
                            break;
                        }
                    case 12: {
                            message.status = $root.lebai.io.ButtonStatus.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Condition message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.trigger.Condition
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.trigger.Condition} Condition
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Condition.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Condition message.
             * @function verify
             * @memberof lebai.trigger.Condition
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Condition.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.pressed != null && message.hasOwnProperty("pressed")) {
                    if (!Array.isArray(message.pressed))
                        return "pressed: array expected";
                    for (var i = 0; i < message.pressed.length; ++i) {
                        var error = $root.lebai.io.ButtonIndex.verify(message.pressed[i]);
                        if (error)
                            return "pressed." + error;
                    }
                }
                if (message.button != null && message.hasOwnProperty("button")) {
                    var error = $root.lebai.io.ButtonIndex.verify(message.button);
                    if (error)
                        return "button." + error;
                }
                if (message.status != null && message.hasOwnProperty("status")) {
                    var error = $root.lebai.io.ButtonStatus.verify(message.status);
                    if (error)
                        return "status." + error;
                }
                return null;
            };

            /**
             * Creates a Condition message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.trigger.Condition
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.trigger.Condition} Condition
             */
            Condition.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.trigger.Condition)
                    return object;
                var message = new $root.lebai.trigger.Condition();
                if (object.pressed) {
                    if (!Array.isArray(object.pressed))
                        throw TypeError(".lebai.trigger.Condition.pressed: array expected");
                    message.pressed = [];
                    for (var i = 0; i < object.pressed.length; ++i) {
                        if (typeof object.pressed[i] !== "object")
                            throw TypeError(".lebai.trigger.Condition.pressed: object expected");
                        message.pressed[i] = $root.lebai.io.ButtonIndex.fromObject(object.pressed[i]);
                    }
                }
                if (object.button != null) {
                    if (typeof object.button !== "object")
                        throw TypeError(".lebai.trigger.Condition.button: object expected");
                    message.button = $root.lebai.io.ButtonIndex.fromObject(object.button);
                }
                if (object.status != null) {
                    if (typeof object.status !== "object")
                        throw TypeError(".lebai.trigger.Condition.status: object expected");
                    message.status = $root.lebai.io.ButtonStatus.fromObject(object.status);
                }
                return message;
            };

            /**
             * Creates a plain object from a Condition message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.trigger.Condition
             * @static
             * @param {lebai.trigger.Condition} message Condition
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Condition.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.pressed = [];
                if (options.defaults) {
                    object.button = null;
                    object.status = null;
                }
                if (message.pressed && message.pressed.length) {
                    object.pressed = [];
                    for (var j = 0; j < message.pressed.length; ++j)
                        object.pressed[j] = $root.lebai.io.ButtonIndex.toObject(message.pressed[j], options);
                }
                if (message.button != null && message.hasOwnProperty("button"))
                    object.button = $root.lebai.io.ButtonIndex.toObject(message.button, options);
                if (message.status != null && message.hasOwnProperty("status"))
                    object.status = $root.lebai.io.ButtonStatus.toObject(message.status, options);
                return object;
            };

            /**
             * Converts this Condition to JSON.
             * @function toJSON
             * @memberof lebai.trigger.Condition
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Condition.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Condition
             * @function getTypeUrl
             * @memberof lebai.trigger.Condition
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Condition.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.trigger.Condition";
            };

            return Condition;
        })();

        /**
         * Function enum.
         * @name lebai.trigger.Function
         * @enum {number}
         * @property {number} NONE=0 NONE value
         * @property {number} START_TEACH_MODE=1 START_TEACH_MODE value
         * @property {number} END_TEACH_MODE=2 END_TEACH_MODE value
         * @property {number} SET_ZERO=3 SET_ZERO value
         * @property {number} CHANGE_POWER=4 CHANGE_POWER value
         * @property {number} SHORT_TASK1=11 SHORT_TASK1 value
         * @property {number} SHORT_TASK2=12 SHORT_TASK2 value
         * @property {number} SHORT_TASK3=13 SHORT_TASK3 value
         * @property {number} SHORT_TASK4=14 SHORT_TASK4 value
         * @property {number} SHORT_TASK5=15 SHORT_TASK5 value
         * @property {number} SHORT_TASK6=16 SHORT_TASK6 value
         * @property {number} SHORT_TASK7=17 SHORT_TASK7 value
         * @property {number} SHORT_TASK8=18 SHORT_TASK8 value
         * @property {number} SHORT_TASK9=19 SHORT_TASK9 value
         */
        trigger.Function = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "NONE"] = 0;
            values[valuesById[1] = "START_TEACH_MODE"] = 1;
            values[valuesById[2] = "END_TEACH_MODE"] = 2;
            values[valuesById[3] = "SET_ZERO"] = 3;
            values[valuesById[4] = "CHANGE_POWER"] = 4;
            values[valuesById[11] = "SHORT_TASK1"] = 11;
            values[valuesById[12] = "SHORT_TASK2"] = 12;
            values[valuesById[13] = "SHORT_TASK3"] = 13;
            values[valuesById[14] = "SHORT_TASK4"] = 14;
            values[valuesById[15] = "SHORT_TASK5"] = 15;
            values[valuesById[16] = "SHORT_TASK6"] = 16;
            values[valuesById[17] = "SHORT_TASK7"] = 17;
            values[valuesById[18] = "SHORT_TASK8"] = 18;
            values[valuesById[19] = "SHORT_TASK9"] = 19;
            return values;
        })();

        trigger.Trigger = (function() {

            /**
             * Properties of a Trigger.
             * @memberof lebai.trigger
             * @interface ITrigger
             * @property {lebai.trigger.ICondition|null} [condition] Trigger condition
             * @property {lebai.trigger.Function|null} ["function"] Trigger function
             */

            /**
             * Constructs a new Trigger.
             * @memberof lebai.trigger
             * @classdesc Represents a Trigger.
             * @implements ITrigger
             * @constructor
             * @param {lebai.trigger.ITrigger=} [properties] Properties to set
             */
            function Trigger(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Trigger condition.
             * @member {lebai.trigger.ICondition|null|undefined} condition
             * @memberof lebai.trigger.Trigger
             * @instance
             */
            Trigger.prototype.condition = null;

            /**
             * Trigger function.
             * @member {lebai.trigger.Function} function
             * @memberof lebai.trigger.Trigger
             * @instance
             */
            Trigger.prototype["function"] = 0;

            /**
             * Creates a new Trigger instance using the specified properties.
             * @function create
             * @memberof lebai.trigger.Trigger
             * @static
             * @param {lebai.trigger.ITrigger=} [properties] Properties to set
             * @returns {lebai.trigger.Trigger} Trigger instance
             */
            Trigger.create = function create(properties) {
                return new Trigger(properties);
            };

            /**
             * Encodes the specified Trigger message. Does not implicitly {@link lebai.trigger.Trigger.verify|verify} messages.
             * @function encode
             * @memberof lebai.trigger.Trigger
             * @static
             * @param {lebai.trigger.ITrigger} message Trigger message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Trigger.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.condition != null && Object.hasOwnProperty.call(message, "condition"))
                    $root.lebai.trigger.Condition.encode(message.condition, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message["function"] != null && Object.hasOwnProperty.call(message, "function"))
                    writer.uint32(/* id 11, wireType 0 =*/88).int32(message["function"]);
                return writer;
            };

            /**
             * Encodes the specified Trigger message, length delimited. Does not implicitly {@link lebai.trigger.Trigger.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.trigger.Trigger
             * @static
             * @param {lebai.trigger.ITrigger} message Trigger message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Trigger.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Trigger message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.trigger.Trigger
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.trigger.Trigger} Trigger
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Trigger.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.trigger.Trigger();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.condition = $root.lebai.trigger.Condition.decode(reader, reader.uint32());
                            break;
                        }
                    case 11: {
                            message["function"] = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Trigger message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.trigger.Trigger
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.trigger.Trigger} Trigger
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Trigger.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Trigger message.
             * @function verify
             * @memberof lebai.trigger.Trigger
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Trigger.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.condition != null && message.hasOwnProperty("condition")) {
                    var error = $root.lebai.trigger.Condition.verify(message.condition);
                    if (error)
                        return "condition." + error;
                }
                if (message["function"] != null && message.hasOwnProperty("function"))
                    switch (message["function"]) {
                    default:
                        return "function: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                    case 16:
                    case 17:
                    case 18:
                    case 19:
                        break;
                    }
                return null;
            };

            /**
             * Creates a Trigger message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.trigger.Trigger
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.trigger.Trigger} Trigger
             */
            Trigger.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.trigger.Trigger)
                    return object;
                var message = new $root.lebai.trigger.Trigger();
                if (object.condition != null) {
                    if (typeof object.condition !== "object")
                        throw TypeError(".lebai.trigger.Trigger.condition: object expected");
                    message.condition = $root.lebai.trigger.Condition.fromObject(object.condition);
                }
                switch (object["function"]) {
                default:
                    if (typeof object["function"] === "number") {
                        message["function"] = object["function"];
                        break;
                    }
                    break;
                case "NONE":
                case 0:
                    message["function"] = 0;
                    break;
                case "START_TEACH_MODE":
                case 1:
                    message["function"] = 1;
                    break;
                case "END_TEACH_MODE":
                case 2:
                    message["function"] = 2;
                    break;
                case "SET_ZERO":
                case 3:
                    message["function"] = 3;
                    break;
                case "CHANGE_POWER":
                case 4:
                    message["function"] = 4;
                    break;
                case "SHORT_TASK1":
                case 11:
                    message["function"] = 11;
                    break;
                case "SHORT_TASK2":
                case 12:
                    message["function"] = 12;
                    break;
                case "SHORT_TASK3":
                case 13:
                    message["function"] = 13;
                    break;
                case "SHORT_TASK4":
                case 14:
                    message["function"] = 14;
                    break;
                case "SHORT_TASK5":
                case 15:
                    message["function"] = 15;
                    break;
                case "SHORT_TASK6":
                case 16:
                    message["function"] = 16;
                    break;
                case "SHORT_TASK7":
                case 17:
                    message["function"] = 17;
                    break;
                case "SHORT_TASK8":
                case 18:
                    message["function"] = 18;
                    break;
                case "SHORT_TASK9":
                case 19:
                    message["function"] = 19;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a Trigger message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.trigger.Trigger
             * @static
             * @param {lebai.trigger.Trigger} message Trigger
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Trigger.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.condition = null;
                    object["function"] = options.enums === String ? "NONE" : 0;
                }
                if (message.condition != null && message.hasOwnProperty("condition"))
                    object.condition = $root.lebai.trigger.Condition.toObject(message.condition, options);
                if (message["function"] != null && message.hasOwnProperty("function"))
                    object["function"] = options.enums === String ? $root.lebai.trigger.Function[message["function"]] === undefined ? message["function"] : $root.lebai.trigger.Function[message["function"]] : message["function"];
                return object;
            };

            /**
             * Converts this Trigger to JSON.
             * @function toJSON
             * @memberof lebai.trigger.Trigger
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Trigger.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Trigger
             * @function getTypeUrl
             * @memberof lebai.trigger.Trigger
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Trigger.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.trigger.Trigger";
            };

            return Trigger;
        })();

        trigger.Triggers = (function() {

            /**
             * Properties of a Triggers.
             * @memberof lebai.trigger
             * @interface ITriggers
             * @property {Array.<lebai.trigger.ITrigger>|null} [triggers] Triggers triggers
             */

            /**
             * Constructs a new Triggers.
             * @memberof lebai.trigger
             * @classdesc Represents a Triggers.
             * @implements ITriggers
             * @constructor
             * @param {lebai.trigger.ITriggers=} [properties] Properties to set
             */
            function Triggers(properties) {
                this.triggers = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Triggers triggers.
             * @member {Array.<lebai.trigger.ITrigger>} triggers
             * @memberof lebai.trigger.Triggers
             * @instance
             */
            Triggers.prototype.triggers = $util.emptyArray;

            /**
             * Creates a new Triggers instance using the specified properties.
             * @function create
             * @memberof lebai.trigger.Triggers
             * @static
             * @param {lebai.trigger.ITriggers=} [properties] Properties to set
             * @returns {lebai.trigger.Triggers} Triggers instance
             */
            Triggers.create = function create(properties) {
                return new Triggers(properties);
            };

            /**
             * Encodes the specified Triggers message. Does not implicitly {@link lebai.trigger.Triggers.verify|verify} messages.
             * @function encode
             * @memberof lebai.trigger.Triggers
             * @static
             * @param {lebai.trigger.ITriggers} message Triggers message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Triggers.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.triggers != null && message.triggers.length)
                    for (var i = 0; i < message.triggers.length; ++i)
                        $root.lebai.trigger.Trigger.encode(message.triggers[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Triggers message, length delimited. Does not implicitly {@link lebai.trigger.Triggers.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.trigger.Triggers
             * @static
             * @param {lebai.trigger.ITriggers} message Triggers message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Triggers.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Triggers message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.trigger.Triggers
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.trigger.Triggers} Triggers
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Triggers.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.trigger.Triggers();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.triggers && message.triggers.length))
                                message.triggers = [];
                            message.triggers.push($root.lebai.trigger.Trigger.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Triggers message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.trigger.Triggers
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.trigger.Triggers} Triggers
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Triggers.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Triggers message.
             * @function verify
             * @memberof lebai.trigger.Triggers
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Triggers.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.triggers != null && message.hasOwnProperty("triggers")) {
                    if (!Array.isArray(message.triggers))
                        return "triggers: array expected";
                    for (var i = 0; i < message.triggers.length; ++i) {
                        var error = $root.lebai.trigger.Trigger.verify(message.triggers[i]);
                        if (error)
                            return "triggers." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Triggers message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.trigger.Triggers
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.trigger.Triggers} Triggers
             */
            Triggers.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.trigger.Triggers)
                    return object;
                var message = new $root.lebai.trigger.Triggers();
                if (object.triggers) {
                    if (!Array.isArray(object.triggers))
                        throw TypeError(".lebai.trigger.Triggers.triggers: array expected");
                    message.triggers = [];
                    for (var i = 0; i < object.triggers.length; ++i) {
                        if (typeof object.triggers[i] !== "object")
                            throw TypeError(".lebai.trigger.Triggers.triggers: object expected");
                        message.triggers[i] = $root.lebai.trigger.Trigger.fromObject(object.triggers[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a Triggers message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.trigger.Triggers
             * @static
             * @param {lebai.trigger.Triggers} message Triggers
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Triggers.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.triggers = [];
                if (message.triggers && message.triggers.length) {
                    object.triggers = [];
                    for (var j = 0; j < message.triggers.length; ++j)
                        object.triggers[j] = $root.lebai.trigger.Trigger.toObject(message.triggers[j], options);
                }
                return object;
            };

            /**
             * Converts this Triggers to JSON.
             * @function toJSON
             * @memberof lebai.trigger.Triggers
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Triggers.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Triggers
             * @function getTypeUrl
             * @memberof lebai.trigger.Triggers
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Triggers.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.trigger.Triggers";
            };

            return Triggers;
        })();

        trigger.TriggerService = (function() {

            /**
             * Constructs a new TriggerService service.
             * @memberof lebai.trigger
             * @classdesc Represents a TriggerService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function TriggerService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (TriggerService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = TriggerService;

            /**
             * Creates new TriggerService service using the specified rpc implementation.
             * @function create
             * @memberof lebai.trigger.TriggerService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {TriggerService} RPC service. Useful where requests and/or responses are streamed.
             */
            TriggerService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link lebai.trigger.TriggerService#setTrigger}.
             * @memberof lebai.trigger.TriggerService
             * @typedef SetTriggerCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls SetTrigger.
             * @function setTrigger
             * @memberof lebai.trigger.TriggerService
             * @instance
             * @param {lebai.trigger.ITrigger} request Trigger message or plain object
             * @param {lebai.trigger.TriggerService.SetTriggerCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(TriggerService.prototype.setTrigger = function setTrigger(request, callback) {
                return this.rpcCall(setTrigger, $root.lebai.trigger.Trigger, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "SetTrigger" });

            /**
             * Calls SetTrigger.
             * @function setTrigger
             * @memberof lebai.trigger.TriggerService
             * @instance
             * @param {lebai.trigger.ITrigger} request Trigger message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.trigger.TriggerService#getTriggers}.
             * @memberof lebai.trigger.TriggerService
             * @typedef GetTriggersCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.trigger.Triggers} [response] Triggers
             */

            /**
             * Calls GetTriggers.
             * @function getTriggers
             * @memberof lebai.trigger.TriggerService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {lebai.trigger.TriggerService.GetTriggersCallback} callback Node-style callback called with the error, if any, and Triggers
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(TriggerService.prototype.getTriggers = function getTriggers(request, callback) {
                return this.rpcCall(getTriggers, $root.google.protobuf.Empty, $root.lebai.trigger.Triggers, request, callback);
            }, "name", { value: "GetTriggers" });

            /**
             * Calls GetTriggers.
             * @function getTriggers
             * @memberof lebai.trigger.TriggerService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<lebai.trigger.Triggers>} Promise
             * @variation 2
             */

            return TriggerService;
        })();

        return trigger;
    })();

    lebai.upgrade = (function() {

        /**
         * Namespace upgrade.
         * @memberof lebai
         * @namespace
         */
        var upgrade = {};

        upgrade.CheckUpgradeResponse = (function() {

            /**
             * Properties of a CheckUpgradeResponse.
             * @memberof lebai.upgrade
             * @interface ICheckUpgradeResponse
             * @property {boolean|null} [needUpgrade] CheckUpgradeResponse needUpgrade
             * @property {string|null} [introduction] CheckUpgradeResponse introduction
             */

            /**
             * Constructs a new CheckUpgradeResponse.
             * @memberof lebai.upgrade
             * @classdesc Represents a CheckUpgradeResponse.
             * @implements ICheckUpgradeResponse
             * @constructor
             * @param {lebai.upgrade.ICheckUpgradeResponse=} [properties] Properties to set
             */
            function CheckUpgradeResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CheckUpgradeResponse needUpgrade.
             * @member {boolean} needUpgrade
             * @memberof lebai.upgrade.CheckUpgradeResponse
             * @instance
             */
            CheckUpgradeResponse.prototype.needUpgrade = false;

            /**
             * CheckUpgradeResponse introduction.
             * @member {string} introduction
             * @memberof lebai.upgrade.CheckUpgradeResponse
             * @instance
             */
            CheckUpgradeResponse.prototype.introduction = "";

            /**
             * Creates a new CheckUpgradeResponse instance using the specified properties.
             * @function create
             * @memberof lebai.upgrade.CheckUpgradeResponse
             * @static
             * @param {lebai.upgrade.ICheckUpgradeResponse=} [properties] Properties to set
             * @returns {lebai.upgrade.CheckUpgradeResponse} CheckUpgradeResponse instance
             */
            CheckUpgradeResponse.create = function create(properties) {
                return new CheckUpgradeResponse(properties);
            };

            /**
             * Encodes the specified CheckUpgradeResponse message. Does not implicitly {@link lebai.upgrade.CheckUpgradeResponse.verify|verify} messages.
             * @function encode
             * @memberof lebai.upgrade.CheckUpgradeResponse
             * @static
             * @param {lebai.upgrade.ICheckUpgradeResponse} message CheckUpgradeResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CheckUpgradeResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.needUpgrade != null && Object.hasOwnProperty.call(message, "needUpgrade"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.needUpgrade);
                if (message.introduction != null && Object.hasOwnProperty.call(message, "introduction"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.introduction);
                return writer;
            };

            /**
             * Encodes the specified CheckUpgradeResponse message, length delimited. Does not implicitly {@link lebai.upgrade.CheckUpgradeResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lebai.upgrade.CheckUpgradeResponse
             * @static
             * @param {lebai.upgrade.ICheckUpgradeResponse} message CheckUpgradeResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CheckUpgradeResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CheckUpgradeResponse message from the specified reader or buffer.
             * @function decode
             * @memberof lebai.upgrade.CheckUpgradeResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lebai.upgrade.CheckUpgradeResponse} CheckUpgradeResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CheckUpgradeResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lebai.upgrade.CheckUpgradeResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.needUpgrade = reader.bool();
                            break;
                        }
                    case 2: {
                            message.introduction = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CheckUpgradeResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lebai.upgrade.CheckUpgradeResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lebai.upgrade.CheckUpgradeResponse} CheckUpgradeResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CheckUpgradeResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CheckUpgradeResponse message.
             * @function verify
             * @memberof lebai.upgrade.CheckUpgradeResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CheckUpgradeResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.needUpgrade != null && message.hasOwnProperty("needUpgrade"))
                    if (typeof message.needUpgrade !== "boolean")
                        return "needUpgrade: boolean expected";
                if (message.introduction != null && message.hasOwnProperty("introduction"))
                    if (!$util.isString(message.introduction))
                        return "introduction: string expected";
                return null;
            };

            /**
             * Creates a CheckUpgradeResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lebai.upgrade.CheckUpgradeResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lebai.upgrade.CheckUpgradeResponse} CheckUpgradeResponse
             */
            CheckUpgradeResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.lebai.upgrade.CheckUpgradeResponse)
                    return object;
                var message = new $root.lebai.upgrade.CheckUpgradeResponse();
                if (object.needUpgrade != null)
                    message.needUpgrade = Boolean(object.needUpgrade);
                if (object.introduction != null)
                    message.introduction = String(object.introduction);
                return message;
            };

            /**
             * Creates a plain object from a CheckUpgradeResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lebai.upgrade.CheckUpgradeResponse
             * @static
             * @param {lebai.upgrade.CheckUpgradeResponse} message CheckUpgradeResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CheckUpgradeResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.needUpgrade = false;
                    object.introduction = "";
                }
                if (message.needUpgrade != null && message.hasOwnProperty("needUpgrade"))
                    object.needUpgrade = message.needUpgrade;
                if (message.introduction != null && message.hasOwnProperty("introduction"))
                    object.introduction = message.introduction;
                return object;
            };

            /**
             * Converts this CheckUpgradeResponse to JSON.
             * @function toJSON
             * @memberof lebai.upgrade.CheckUpgradeResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CheckUpgradeResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for CheckUpgradeResponse
             * @function getTypeUrl
             * @memberof lebai.upgrade.CheckUpgradeResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            CheckUpgradeResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lebai.upgrade.CheckUpgradeResponse";
            };

            return CheckUpgradeResponse;
        })();

        upgrade.UpgradeService = (function() {

            /**
             * Constructs a new UpgradeService service.
             * @memberof lebai.upgrade
             * @classdesc Represents an UpgradeService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function UpgradeService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (UpgradeService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = UpgradeService;

            /**
             * Creates new UpgradeService service using the specified rpc implementation.
             * @function create
             * @memberof lebai.upgrade.UpgradeService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {UpgradeService} RPC service. Useful where requests and/or responses are streamed.
             */
            UpgradeService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link lebai.upgrade.UpgradeService#checkUpgrade}.
             * @memberof lebai.upgrade.UpgradeService
             * @typedef CheckUpgradeCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.upgrade.CheckUpgradeResponse} [response] CheckUpgradeResponse
             */

            /**
             * Calls CheckUpgrade.
             * @function checkUpgrade
             * @memberof lebai.upgrade.UpgradeService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {lebai.upgrade.UpgradeService.CheckUpgradeCallback} callback Node-style callback called with the error, if any, and CheckUpgradeResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(UpgradeService.prototype.checkUpgrade = function checkUpgrade(request, callback) {
                return this.rpcCall(checkUpgrade, $root.google.protobuf.Empty, $root.lebai.upgrade.CheckUpgradeResponse, request, callback);
            }, "name", { value: "CheckUpgrade" });

            /**
             * Calls CheckUpgrade.
             * @function checkUpgrade
             * @memberof lebai.upgrade.UpgradeService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<lebai.upgrade.CheckUpgradeResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.upgrade.UpgradeService#startUpgrade}.
             * @memberof lebai.upgrade.UpgradeService
             * @typedef StartUpgradeCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls StartUpgrade.
             * @function startUpgrade
             * @memberof lebai.upgrade.UpgradeService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {lebai.upgrade.UpgradeService.StartUpgradeCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(UpgradeService.prototype.startUpgrade = function startUpgrade(request, callback) {
                return this.rpcCall(startUpgrade, $root.google.protobuf.Empty, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "StartUpgrade" });

            /**
             * Calls StartUpgrade.
             * @function startUpgrade
             * @memberof lebai.upgrade.UpgradeService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link lebai.upgrade.UpgradeService#getUpgradeStdout}.
             * @memberof lebai.upgrade.UpgradeService
             * @typedef GetUpgradeStdoutCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {lebai.CommandStdout} [response] CommandStdout
             */

            /**
             * Calls GetUpgradeStdout.
             * @function getUpgradeStdout
             * @memberof lebai.upgrade.UpgradeService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {lebai.upgrade.UpgradeService.GetUpgradeStdoutCallback} callback Node-style callback called with the error, if any, and CommandStdout
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(UpgradeService.prototype.getUpgradeStdout = function getUpgradeStdout(request, callback) {
                return this.rpcCall(getUpgradeStdout, $root.google.protobuf.Empty, $root.lebai.CommandStdout, request, callback);
            }, "name", { value: "GetUpgradeStdout" });

            /**
             * Calls GetUpgradeStdout.
             * @function getUpgradeStdout
             * @memberof lebai.upgrade.UpgradeService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<lebai.CommandStdout>} Promise
             * @variation 2
             */

            return UpgradeService;
        })();

        return upgrade;
    })();

    return lebai;
})();

$root.google = (function() {

    /**
     * Namespace google.
     * @exports google
     * @namespace
     */
    var google = {};

    google.protobuf = (function() {

        /**
         * Namespace protobuf.
         * @memberof google
         * @namespace
         */
        var protobuf = {};

        protobuf.Empty = (function() {

            /**
             * Properties of an Empty.
             * @memberof google.protobuf
             * @interface IEmpty
             */

            /**
             * Constructs a new Empty.
             * @memberof google.protobuf
             * @classdesc Represents an Empty.
             * @implements IEmpty
             * @constructor
             * @param {google.protobuf.IEmpty=} [properties] Properties to set
             */
            function Empty(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new Empty instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Empty
             * @static
             * @param {google.protobuf.IEmpty=} [properties] Properties to set
             * @returns {google.protobuf.Empty} Empty instance
             */
            Empty.create = function create(properties) {
                return new Empty(properties);
            };

            /**
             * Encodes the specified Empty message. Does not implicitly {@link google.protobuf.Empty.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Empty
             * @static
             * @param {google.protobuf.IEmpty} message Empty message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Empty.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified Empty message, length delimited. Does not implicitly {@link google.protobuf.Empty.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.Empty
             * @static
             * @param {google.protobuf.IEmpty} message Empty message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Empty.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Empty message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Empty
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Empty} Empty
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Empty.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Empty();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Empty message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.Empty
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Empty} Empty
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Empty.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Empty message.
             * @function verify
             * @memberof google.protobuf.Empty
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Empty.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates an Empty message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Empty
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Empty} Empty
             */
            Empty.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Empty)
                    return object;
                return new $root.google.protobuf.Empty();
            };

            /**
             * Creates a plain object from an Empty message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Empty
             * @static
             * @param {google.protobuf.Empty} message Empty
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Empty.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this Empty to JSON.
             * @function toJSON
             * @memberof google.protobuf.Empty
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Empty.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Empty
             * @function getTypeUrl
             * @memberof google.protobuf.Empty
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Empty.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.Empty";
            };

            return Empty;
        })();

        protobuf.Timestamp = (function() {

            /**
             * Properties of a Timestamp.
             * @memberof google.protobuf
             * @interface ITimestamp
             * @property {number|Long|null} [seconds] Timestamp seconds
             * @property {number|null} [nanos] Timestamp nanos
             */

            /**
             * Constructs a new Timestamp.
             * @memberof google.protobuf
             * @classdesc Represents a Timestamp.
             * @implements ITimestamp
             * @constructor
             * @param {google.protobuf.ITimestamp=} [properties] Properties to set
             */
            function Timestamp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Timestamp seconds.
             * @member {number|Long} seconds
             * @memberof google.protobuf.Timestamp
             * @instance
             */
            Timestamp.prototype.seconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Timestamp nanos.
             * @member {number} nanos
             * @memberof google.protobuf.Timestamp
             * @instance
             */
            Timestamp.prototype.nanos = 0;

            /**
             * Creates a new Timestamp instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {google.protobuf.ITimestamp=} [properties] Properties to set
             * @returns {google.protobuf.Timestamp} Timestamp instance
             */
            Timestamp.create = function create(properties) {
                return new Timestamp(properties);
            };

            /**
             * Encodes the specified Timestamp message. Does not implicitly {@link google.protobuf.Timestamp.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {google.protobuf.ITimestamp} message Timestamp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Timestamp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.seconds != null && Object.hasOwnProperty.call(message, "seconds"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.seconds);
                if (message.nanos != null && Object.hasOwnProperty.call(message, "nanos"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.nanos);
                return writer;
            };

            /**
             * Encodes the specified Timestamp message, length delimited. Does not implicitly {@link google.protobuf.Timestamp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {google.protobuf.ITimestamp} message Timestamp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Timestamp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Timestamp message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Timestamp} Timestamp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Timestamp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Timestamp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.seconds = reader.int64();
                            break;
                        }
                    case 2: {
                            message.nanos = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Timestamp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Timestamp} Timestamp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Timestamp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Timestamp message.
             * @function verify
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Timestamp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.seconds != null && message.hasOwnProperty("seconds"))
                    if (!$util.isInteger(message.seconds) && !(message.seconds && $util.isInteger(message.seconds.low) && $util.isInteger(message.seconds.high)))
                        return "seconds: integer|Long expected";
                if (message.nanos != null && message.hasOwnProperty("nanos"))
                    if (!$util.isInteger(message.nanos))
                        return "nanos: integer expected";
                return null;
            };

            /**
             * Creates a Timestamp message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Timestamp} Timestamp
             */
            Timestamp.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Timestamp)
                    return object;
                var message = new $root.google.protobuf.Timestamp();
                if (object.seconds != null)
                    if ($util.Long)
                        (message.seconds = $util.Long.fromValue(object.seconds)).unsigned = false;
                    else if (typeof object.seconds === "string")
                        message.seconds = parseInt(object.seconds, 10);
                    else if (typeof object.seconds === "number")
                        message.seconds = object.seconds;
                    else if (typeof object.seconds === "object")
                        message.seconds = new $util.LongBits(object.seconds.low >>> 0, object.seconds.high >>> 0).toNumber();
                if (object.nanos != null)
                    message.nanos = object.nanos | 0;
                return message;
            };

            /**
             * Creates a plain object from a Timestamp message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {google.protobuf.Timestamp} message Timestamp
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Timestamp.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.seconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.seconds = options.longs === String ? "0" : 0;
                    object.nanos = 0;
                }
                if (message.seconds != null && message.hasOwnProperty("seconds"))
                    if (typeof message.seconds === "number")
                        object.seconds = options.longs === String ? String(message.seconds) : message.seconds;
                    else
                        object.seconds = options.longs === String ? $util.Long.prototype.toString.call(message.seconds) : options.longs === Number ? new $util.LongBits(message.seconds.low >>> 0, message.seconds.high >>> 0).toNumber() : message.seconds;
                if (message.nanos != null && message.hasOwnProperty("nanos"))
                    object.nanos = message.nanos;
                return object;
            };

            /**
             * Converts this Timestamp to JSON.
             * @function toJSON
             * @memberof google.protobuf.Timestamp
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Timestamp.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Timestamp
             * @function getTypeUrl
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Timestamp.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.Timestamp";
            };

            return Timestamp;
        })();

        return protobuf;
    })();

    return google;
})();

module.exports = $root;
